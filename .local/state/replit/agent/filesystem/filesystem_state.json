{"file_contents":{"app.py":{"content":"import streamlit as st\nimport pandas as pd\nimport plotly.express as px\nimport plotly.graph_objects as go\nfrom datetime import datetime, timedelta\nimport time\nimport threading\nimport os\n\n# Import our custom modules\nfrom core.threat_detection import ThreatDetectionEngine\nfrom core.ai_models import AIThreatAnalyzer\nfrom core.log_analyzer import LogAnalyzer\nfrom core.alert_manager import AlertManager\nfrom simulation.attack_simulator import AttackSimulator\nfrom monitoring.network_monitor import NetworkMonitor\n# Removed endpoint, IoT, and mobile monitoring modules as requested\nfrom utils.data_processor import DataProcessor\nfrom utils.threat_intelligence import ThreatIntelligence\n\n# Configure page\nst.set_page_config(\n    page_title=\"AI Cybersecurity Threat Detection System\",\n    page_icon=\"ðŸ›¡ï¸\",\n    layout=\"wide\",\n    initial_sidebar_state=\"expanded\"\n)\n\n# Initialize session state\nif 'threat_engine' not in st.session_state:\n    st.session_state.threat_engine = ThreatDetectionEngine()\n    st.session_state.ai_analyzer = AIThreatAnalyzer()\n    st.session_state.log_analyzer = LogAnalyzer()\n    st.session_state.alert_manager = AlertManager()\n    st.session_state.attack_simulator = AttackSimulator()\n    st.session_state.network_monitor = NetworkMonitor()\n    st.session_state.data_processor = DataProcessor()\n    st.session_state.threat_intel = ThreatIntelligence()\n\ndef main():\n    st.title(\"ðŸ›¡ï¸ AI-Powered Cybersecurity Threat Detection System\")\n    st.markdown(\"### Comprehensive Multi-Environment Security Monitoring & Response\")\n    \n    # Sidebar navigation with direct buttons\n    st.sidebar.title(\"ðŸ›¡ï¸ Security Center\")\n    \n    # Initialize page selection\n    if 'current_page' not in st.session_state:\n        st.session_state.current_page = \"ðŸ  Dashboard Overview\"\n    \n    # Dashboard & Monitoring section\n    st.sidebar.markdown(\"### ðŸ“Š **Dashboard & Monitoring**\")\n    if st.sidebar.button(\"ðŸ  Dashboard Overview\", use_container_width=True):\n        st.session_state.current_page = \"ðŸ  Dashboard Overview\"\n    if st.sidebar.button(\"ðŸŽ¯ Real-Time Threat Detection\", use_container_width=True):\n        st.session_state.current_page = \"ðŸŽ¯ Real-Time Threat Detection\"\n    if st.sidebar.button(\"ðŸ“Š Alert Management\", use_container_width=True):\n        st.session_state.current_page = \"ðŸ“Š Alert Management\"\n    \n    # Analysis & Investigation section\n    st.sidebar.markdown(\"### ðŸ” **Analysis & Investigation**\")\n    if st.sidebar.button(\"ðŸ” Log Analysis\", use_container_width=True):\n        st.session_state.current_page = \"ðŸ” Log Analysis\"\n    if st.sidebar.button(\"ðŸ“ˆ Analytics & Reports\", use_container_width=True):\n        st.session_state.current_page = \"ðŸ“ˆ Analytics & Reports\"\n    \n    # Protection Systems section\n    st.sidebar.markdown(\"### ðŸ›¡ï¸ **Protection Systems**\")\n    if st.sidebar.button(\"ðŸŒ Network Security\", use_container_width=True):\n        st.session_state.current_page = \"ðŸŒ Network Security\"\n    \n    # Testing & Configuration section\n    st.sidebar.markdown(\"### âš”ï¸ **Testing & Configuration**\")\n    if st.sidebar.button(\"âš”ï¸ Attack Simulation\", use_container_width=True):\n        st.session_state.current_page = \"âš”ï¸ Attack Simulation\"\n    if st.sidebar.button(\"âš™ï¸ System Configuration\", use_container_width=True):\n        st.session_state.current_page = \"âš™ï¸ System Configuration\"\n    \n    # Get current page\n    page = st.session_state.current_page\n    \n    # Real-time monitoring toggle\n    if st.sidebar.checkbox(\"Enable Real-Time Monitoring\"):\n        if 'monitoring_active' not in st.session_state:\n            st.session_state.monitoring_active = True\n            start_background_monitoring()\n    \n    # Route to selected page\n    if page == \"ðŸ  Dashboard Overview\":\n        show_dashboard_overview()\n    elif page == \"ðŸŽ¯ Real-Time Threat Detection\":\n        show_threat_detection()\n    elif page == \"ðŸ“Š Alert Management\":\n        show_alert_management()\n    elif page == \"ðŸ” Log Analysis\":\n        show_log_analysis()\n    elif page == \"ðŸŒ Network Security\":\n        show_network_security()\n    elif page == \"âš”ï¸ Attack Simulation\":\n        show_attack_simulation()\n    elif page == \"ðŸ“ˆ Analytics & Reports\":\n        show_analytics_reports()\n    elif page == \"âš™ï¸ System Configuration\":\n        show_system_configuration()\n\ndef show_dashboard_overview():\n    \"\"\"Main dashboard with system overview\"\"\"\n    col1, col2, col3, col4 = st.columns(4)\n    \n    # Get current system status\n    active_threats = st.session_state.threat_engine.get_active_threats()\n    alerts_count = st.session_state.alert_manager.get_alerts_count()\n    system_health = st.session_state.threat_engine.get_system_health()\n    \n    with col1:\n        st.metric(\"Active Threats\", len(active_threats), delta=f\"+{len([t for t in active_threats if t['timestamp'] > datetime.now() - timedelta(hours=1)])}\")\n    \n    with col2:\n        st.metric(\"Critical Alerts\", alerts_count['critical'], delta=f\"+{alerts_count.get('new_critical', 0)}\")\n    \n    with col3:\n        st.metric(\"System Health\", f\"{system_health['score']:.1f}/10\", delta=f\"{system_health['trend']:+.1f}\")\n    \n    with col4:\n        st.metric(\"Protected Assets\", system_health['protected_assets'], delta=f\"+{system_health.get('new_assets', 0)}\")\n    \n    # Threat severity distribution\n    st.subheader(\"ðŸš¨ Current Threat Landscape\")\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        # Threat types pie chart\n        threat_types = st.session_state.threat_engine.get_threat_distribution()\n        if threat_types:\n            fig = px.pie(\n                values=list(threat_types.values()),\n                names=list(threat_types.keys()),\n                title=\"Threat Types Distribution\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n    \n    with col2:\n        # Alert timeline\n        alerts_timeline = st.session_state.alert_manager.get_alerts_timeline()\n        if alerts_timeline and alerts_timeline['timestamps'] and alerts_timeline['counts']:\n            # Create DataFrame for plotly\n            df_timeline = pd.DataFrame({\n                'timestamps': alerts_timeline['timestamps'],\n                'counts': alerts_timeline['counts']\n            })\n            fig = px.line(\n                df_timeline,\n                x='timestamps',\n                y='counts',\n                title=\"Alerts Over Time (Last 24h)\",\n                markers=True\n            )\n            fig.update_layout(showlegend=False)\n            st.plotly_chart(fig, use_container_width=True)\n        else:\n            st.info(\"ðŸ“ˆ No alert timeline data available yet\")\n    \n    # Recent threats table\n    st.subheader(\"ðŸ” Recent Threat Activity\")\n    if active_threats:\n        df = pd.DataFrame(active_threats)\n        st.dataframe(df, use_container_width=True)\n    else:\n        st.info(\"No active threats detected in the current timeframe.\")\n    \n    # Network Security Status\n    st.subheader(\"ðŸŒ Network Security Status\")\n    col1, col2, col3 = st.columns(3)\n    \n    network_status = st.session_state.network_monitor.get_status()\n    \n    with col1:\n        st.metric(\"Monitored Devices\", network_status['devices'])\n    \n    with col2:\n        st.metric(\"Blocked IPs\", network_status['blocked_ips'])\n    \n    with col3:\n        st.metric(\"Active Connections\", network_status['total_connections'])\n\ndef show_threat_detection():\n    \"\"\"Real-time threat detection interface\"\"\"\n    st.header(\"ðŸŽ¯ Real-Time Threat Detection Engine\")\n    \n    col1, col2 = st.columns([2, 1])\n    \n    with col1:\n        st.subheader(\"ðŸ” AI Analysis Dashboard\")\n        \n        # Real-time threat feed\n        if st.button(\"ðŸ”„ Refresh Threat Analysis\"):\n            with st.spinner(\"Analyzing threats...\"):\n                threats = st.session_state.ai_analyzer.analyze_real_time()\n                \n                if threats:\n                    for threat in threats:\n                        severity_color = {\n                            'Critical': 'ðŸ”´',\n                            'High': 'ðŸŸ ', \n                            'Medium': 'ðŸŸ¡',\n                            'Low': 'ðŸŸ¢'\n                        }.get(threat['severity'], 'âšª')\n                        \n                        st.warning(f\"{severity_color} **{threat['type']}** - Confidence: {threat['confidence']:.1%}\")\n                        st.write(f\"**Target**: {threat['target']}\")\n                        st.write(f\"**Description**: {threat['description']}\")\n                        st.write(f\"**Recommended Action**: {threat['action']}\")\n                        st.write(\"---\")\n                else:\n                    st.success(\"âœ… No active threats detected\")\n    \n    with col2:\n        st.subheader(\"âš™ï¸ Detection Settings\")\n        \n        # Detection sensitivity\n        sensitivity = st.slider(\"Detection Sensitivity\", 0.1, 1.0, 0.7, 0.1)\n        st.session_state.ai_analyzer.set_sensitivity(sensitivity)\n        \n        # Monitored threat types\n        st.write(\"**Monitored Threats:**\")\n        threat_types = [\n            \"Ransomware\", \"Zero-day Exploits\", \"Network Intrusions\",\n            \"Malware\", \"Phishing\", \"DDoS Attacks\", \"Data Exfiltration\",\n            \"Privilege Escalation\", \"Lateral Movement\", \"Social Engineering\"\n        ]\n        \n        selected_threats = []\n        for threat in threat_types:\n            if st.checkbox(threat, value=True):\n                selected_threats.append(threat)\n        \n        st.session_state.ai_analyzer.set_monitored_threats(selected_threats)\n        \n        # Auto-response settings\n        st.write(\"**Auto-Response:**\")\n        auto_quarantine = st.checkbox(\"Auto-quarantine malicious files\")\n        auto_block_ips = st.checkbox(\"Auto-block suspicious IPs\")\n        auto_isolate_endpoints = st.checkbox(\"Auto-isolate compromised endpoints\")\n    \n    # Threat pattern analysis\n    st.subheader(\"ðŸ“Š Threat Pattern Analysis\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        # Attack vectors\n        attack_vectors = st.session_state.ai_analyzer.get_attack_vectors()\n        if attack_vectors:\n            fig = px.bar(\n                x=list(attack_vectors.keys()),\n                y=list(attack_vectors.values()),\n                title=\"Most Common Attack Vectors (Last 7 Days)\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n    \n    with col2:\n        # Confidence scores distribution\n        confidence_dist = st.session_state.ai_analyzer.get_confidence_distribution()\n        if confidence_dist:\n            fig = px.histogram(\n                x=confidence_dist,\n                title=\"Detection Confidence Distribution\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n\ndef show_alert_management():\n    \"\"\"Alert management and response interface\"\"\"\n    st.header(\"ðŸ“Š Alert Management & Incident Response\")\n    \n    # Alert filters\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        severity_filter = st.selectbox(\"Severity\", [\"All\", \"Critical\", \"High\", \"Medium\", \"Low\"])\n    with col2:\n        status_filter = st.selectbox(\"Status\", [\"All\", \"Open\", \"In Progress\", \"Resolved\", \"False Positive\"])\n    with col3:\n        time_filter = st.selectbox(\"Time Range\", [\"Last Hour\", \"Last 24h\", \"Last 7 days\", \"Last 30 days\"])\n    with col4:\n        environment_filter = st.selectbox(\"Environment\", [\"All\", \"Network\", \"Endpoint\", \"Cloud\", \"IoT\", \"Mobile\"])\n    \n    # Get filtered alerts\n    alerts = st.session_state.alert_manager.get_filtered_alerts(\n        severity=severity_filter,\n        status=status_filter,\n        time_range=time_filter,\n        environment=environment_filter\n    )\n    \n    # Alert summary metrics\n    col1, col2, col3, col4 = st.columns(4)\n    \n    with col1:\n        st.metric(\"Total Alerts\", len(alerts))\n    with col2:\n        critical_count = len([a for a in alerts if a['severity'] == 'Critical'])\n        st.metric(\"Critical Alerts\", critical_count)\n    with col3:\n        open_count = len([a for a in alerts if a['status'] == 'Open'])\n        st.metric(\"Open Alerts\", open_count)\n    with col4:\n        false_positive_rate = st.session_state.alert_manager.get_false_positive_rate()\n        st.metric(\"False Positive Rate\", f\"{false_positive_rate:.1%}\")\n    \n    # Alert management interface\n    if alerts:\n        st.subheader(\"ðŸš¨ Active Alerts\")\n        \n        for i, alert in enumerate(alerts[:10]):  # Show top 10\n            with st.expander(f\"{alert['severity']} - {alert['title']} ({alert['timestamp']})\"):\n                col1, col2 = st.columns([3, 1])\n                \n                with col1:\n                    st.write(f\"**Description**: {alert['description']}\")\n                    st.write(f\"**Affected Asset**: {alert['asset']}\")\n                    st.write(f\"**Source**: {alert['source']}\")\n                    st.write(f\"**Confidence**: {alert['confidence']:.1%}\")\n                    \n                    if alert.get('indicators'):\n                        st.write(\"**Indicators of Compromise (IoCs):**\")\n                        for ioc in alert['indicators']:\n                            st.code(ioc)\n                \n                with col2:\n                    st.write(f\"**Status**: {alert['status']}\")\n                    st.write(f\"**Assigned To**: {alert.get('assigned_to', 'Unassigned')}\")\n                    \n                    # Action buttons\n                    if st.button(f\"Investigate\", key=f\"investigate_{i}\"):\n                        st.session_state.alert_manager.start_investigation(alert['id'])\n                        st.success(\"Investigation started\")\n                        st.rerun()\n                    \n                    if st.button(f\"Mark False Positive\", key=f\"fp_{i}\"):\n                        st.session_state.alert_manager.mark_false_positive(alert['id'])\n                        st.success(\"Marked as false positive\")\n                        st.rerun()\n                    \n                    if st.button(f\"Resolve\", key=f\"resolve_{i}\"):\n                        st.session_state.alert_manager.resolve_alert(alert['id'])\n                        st.success(\"Alert resolved\")\n                        st.rerun()\n    \n    # False positive analysis\n    st.subheader(\"ðŸ“ˆ False Positive Analysis\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        fp_trends = st.session_state.alert_manager.get_false_positive_trends()\n        if fp_trends:\n            fig = px.line(\n                x=fp_trends['dates'],\n                y=fp_trends['rates'],\n                title=\"False Positive Rate Trend\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n    \n    with col2:\n        fp_by_type = st.session_state.alert_manager.get_false_positives_by_type()\n        if fp_by_type:\n            fig = px.bar(\n                x=list(fp_by_type.keys()),\n                y=list(fp_by_type.values()),\n                title=\"False Positives by Alert Type\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n\ndef show_log_analysis():\n    \"\"\"Log analysis and forensics interface\"\"\"\n    st.header(\"ðŸ” Advanced Log Analysis & Digital Forensics\")\n    \n    # Log source selection\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        log_sources = st.multiselect(\n            \"Select Log Sources\",\n            [\"Windows Event Logs\", \"Linux Syslogs\", \"Network Devices\", \"Web Servers\", \n             \"Database Logs\", \"Cloud Audit Logs\", \"IoT Device Logs\", \"Mobile Device Logs\"],\n            default=[\"Windows Event Logs\", \"Network Devices\"]\n        )\n    \n    with col2:\n        time_range = st.selectbox(\n            \"Analysis Time Range\",\n            [\"Last Hour\", \"Last 24h\", \"Last 7 days\", \"Custom Range\"]\n        )\n    \n    with col3:\n        analysis_type = st.selectbox(\n            \"Analysis Type\",\n            [\"Real-time\", \"Historical\", \"Correlation\", \"Pattern Detection\"]\n        )\n    \n    # Custom time range\n    if time_range == \"Custom Range\":\n        col1, col2 = st.columns(2)\n        with col1:\n            start_date = st.date_input(\"Start Date\")\n        with col2:\n            end_date = st.date_input(\"End Date\")\n    \n    # Log analysis controls\n    if st.button(\"ðŸ” Start Log Analysis\"):\n        with st.spinner(\"Analyzing logs...\"):\n            results = st.session_state.log_analyzer.analyze_logs(\n                sources=log_sources,\n                time_range=time_range,\n                analysis_type=analysis_type\n            )\n            \n            if results:\n                st.success(f\"Analysis complete. Found {len(results['events'])} relevant events.\")\n                \n                # Event timeline\n                st.subheader(\"ðŸ“… Event Timeline\")\n                if results['timeline']:\n                    fig = px.scatter(\n                        x=results['timeline']['timestamps'],\n                        y=results['timeline']['sources'],\n                        color=results['timeline']['severities'],\n                        title=\"Security Events Timeline\"\n                    )\n                    st.plotly_chart(fig, use_container_width=True)\n                \n                # Top findings\n                st.subheader(\"ðŸŽ¯ Key Findings\")\n                for finding in results['findings'][:5]:\n                    severity_emoji = {\n                        'Critical': 'ðŸ”´',\n                        'High': 'ðŸŸ ',\n                        'Medium': 'ðŸŸ¡',\n                        'Low': 'ðŸŸ¢'\n                    }.get(finding['severity'], 'âšª')\n                    \n                    st.write(f\"{severity_emoji} **{finding['title']}**\")\n                    st.write(f\"Confidence: {finding['confidence']:.1%}\")\n                    st.write(f\"Description: {finding['description']}\")\n                    \n                    if finding.get('recommendations'):\n                        st.write(\"**Recommendations:**\")\n                        for rec in finding['recommendations']:\n                            st.write(f\"â€¢ {rec}\")\n                    st.write(\"---\")\n                \n                # Raw log viewer\n                with st.expander(\"ðŸ“„ Raw Log Data\"):\n                    if results['raw_logs']:\n                        df = pd.DataFrame(results['raw_logs'])\n                        st.dataframe(df, use_container_width=True)\n    \n    # Log correlation analysis\n    st.subheader(\"ðŸ”— Cross-Platform Log Correlation\")\n    \n    if st.button(\"ðŸ”„ Run Correlation Analysis\"):\n        correlations = st.session_state.log_analyzer.run_correlation_analysis()\n        \n        if correlations:\n            for correlation in correlations:\n                st.write(f\"**Correlation Pattern**: {correlation['pattern']}\")\n                st.write(f\"**Confidence**: {correlation['confidence']:.1%}\")\n                st.write(f\"**Affected Systems**: {', '.join(correlation['systems'])}\")\n                st.write(f\"**Timeline**: {correlation['timespan']}\")\n                st.write(\"---\")\n\ndef show_network_security():\n    \"\"\"Network security monitoring interface\"\"\"\n    st.header(\"ðŸŒ Network Security Monitoring\")\n    \n    # Network overview\n    col1, col2, col3, col4 = st.columns(4)\n    \n    network_stats = st.session_state.network_monitor.get_network_statistics()\n    \n    with col1:\n        st.metric(\"Monitored Networks\", network_stats['networks'])\n    with col2:\n        st.metric(\"Active Connections\", network_stats['connections'])\n    with col3:\n        st.metric(\"Blocked Threats\", network_stats['blocked_threats'])\n    with col4:\n        st.metric(\"Network Health\", f\"{network_stats['health_score']:.1f}/10\")\n    \n    # Real-time network monitoring\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"ðŸ” Real-Time Traffic Analysis\")\n        \n        if st.button(\"ðŸ“Š Analyze Current Traffic\"):\n            with st.spinner(\"Analyzing network traffic...\"):\n                traffic_analysis = st.session_state.network_monitor.analyze_traffic()\n                \n                if traffic_analysis['threats']:\n                    st.warning(\"âš ï¸ Suspicious Network Activity Detected!\")\n                    for threat in traffic_analysis['threats']:\n                        st.write(f\"**Type**: {threat['type']}\")\n                        st.write(f\"**Source**: {threat['source_ip']}\")\n                        st.write(f\"**Destination**: {threat['dest_ip']}\")\n                        st.write(f\"**Risk Level**: {threat['risk_level']}\")\n                        st.write(\"---\")\n                else:\n                    st.success(\"âœ… No suspicious network activity detected\")\n    \n    with col2:\n        st.subheader(\"ðŸ›¡ï¸ Intrusion Detection\")\n        \n        # IDS/IPS status\n        ids_status = st.session_state.network_monitor.get_ids_status()\n        \n        st.write(f\"**IDS Status**: {'ðŸŸ¢ Active' if ids_status['active'] else 'ðŸ”´ Inactive'}\")\n        st.write(f\"**Signatures Updated**: {ids_status['last_update']}\")\n        st.write(f\"**Detection Rules**: {ids_status['rules_count']}\")\n        \n        if st.button(\"ðŸ”„ Update Signatures\"):\n            st.session_state.network_monitor.update_signatures()\n            st.success(\"Signatures updated successfully\")\n    \n    # Network topology visualization\n    st.subheader(\"ðŸ—ºï¸ Network Topology & Threat Map\")\n    \n    topology_data = st.session_state.network_monitor.get_network_topology()\n    if topology_data:\n        # Create network visualization\n        fig = go.Figure()\n        \n        # Add nodes (devices)\n        for device in topology_data['devices']:\n            color = 'red' if device['status'] == 'compromised' else 'yellow' if device['status'] == 'suspicious' else 'green'\n            fig.add_trace(go.Scatter(\n                x=[device['x']],\n                y=[device['y']],\n                mode='markers+text',\n                marker=dict(size=15, color=color),\n                text=device['name'],\n                textposition=\"bottom center\",\n                name=device['type']\n            ))\n        \n        # Add connections\n        for connection in topology_data['connections']:\n            fig.add_trace(go.Scatter(\n                x=[connection['x1'], connection['x2']],\n                y=[connection['y1'], connection['y2']],\n                mode='lines',\n                line=dict(color='gray', width=2),\n                showlegend=False\n            ))\n        \n        fig.update_layout(title=\"Network Topology with Threat Indicators\")\n        st.plotly_chart(fig, use_container_width=True)\n    \n    # Firewall management\n    st.subheader(\"ðŸ”¥ Firewall Management\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.write(\"**Blocked IPs (Last 24h)**\")\n        blocked_ips = st.session_state.network_monitor.get_blocked_ips()\n        if blocked_ips:\n            df = pd.DataFrame(blocked_ips)\n            st.dataframe(df, use_container_width=True)\n    \n    with col2:\n        st.write(\"**Add IP to Blocklist**\")\n        ip_to_block = st.text_input(\"IP Address\")\n        reason = st.text_input(\"Reason\")\n        if st.button(\"ðŸš« Block IP\"):\n            if ip_to_block:\n                st.session_state.network_monitor.block_ip(ip_to_block, reason)\n                st.success(f\"IP {ip_to_block} blocked successfully\")\n\n# Removed endpoint protection and IoT/mobile security modules as requested\n\ndef show_attack_simulation():\n    \"\"\"Attack simulation and testing interface\"\"\"\n    st.header(\"âš”ï¸ Attack Simulation & Penetration Testing\")\n    \n    st.warning(\"âš ï¸ **WARNING**: Attack simulations should only be run in authorized testing environments!\")\n    \n    # Simulation controls\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"ðŸŽ¯ Simulation Categories\")\n        \n        simulation_types = {\n            \"Ransomware Simulation\": {\n                \"description\": \"Simulate ransomware behavior patterns\",\n                \"attacks\": [\"File Encryption Simulation\", \"Registry Modification\", \"Network Share Encryption\"]\n            },\n            \"Network Intrusion\": {\n                \"description\": \"Test network security defenses\",\n                \"attacks\": [\"Port Scanning\", \"DDoS Simulation\", \"Man-in-the-Middle\"]\n            },\n            \"Endpoint Attacks\": {\n                \"description\": \"Test endpoint protection systems\",\n                \"attacks\": [\"Malware Simulation\", \"Process Injection\", \"Privilege Escalation\"]\n            },\n            \"Social Engineering\": {\n                \"description\": \"Test human factor security\",\n                \"attacks\": [\"Phishing Simulation\", \"USB Drop Attack\", \"Physical Breach\"]\n            },\n            \"Advanced Persistent Threats\": {\n                \"description\": \"Multi-stage attack campaigns\",\n                \"attacks\": [\"Lateral Movement\", \"Data Exfiltration\", \"Command & Control\"]\n            }\n        }\n        \n        selected_category = st.selectbox(\"Select Attack Category\", list(simulation_types.keys()))\n        selected_attack = None\n        \n        if selected_category:\n            st.write(f\"**Description**: {simulation_types[selected_category]['description']}\")\n            selected_attack = st.selectbox(\"Select Specific Attack\", simulation_types[selected_category]['attacks'])\n    \n    with col2:\n        st.subheader(\"âš™ï¸ Simulation Parameters\")\n        \n        # Target selection\n        target_environment = st.selectbox(\n            \"Target Environment\",\n            [\"Test Network\", \"Isolated Lab\", \"Sandbox Environment\"]\n        )\n        \n        intensity_level = st.slider(\"Attack Intensity\", 1, 10, 5)\n        duration = st.selectbox(\"Duration\", [\"1 minute\", \"5 minutes\", \"15 minutes\", \"30 minutes\"])\n        \n        # Safety settings\n        safe_mode = st.checkbox(\"Safe Mode (No actual system changes)\", value=True)\n        log_everything = st.checkbox(\"Detailed Logging\", value=True)\n        auto_cleanup = st.checkbox(\"Auto-cleanup after simulation\", value=True)\n    \n    # Start simulation\n    if st.button(\"ðŸš€ Start Attack Simulation\"):\n        if not safe_mode:\n            if not st.checkbox(\"I understand this will make actual system changes\"):\n                st.error(\"Please acknowledge the risks before proceeding without safe mode\")\n                return\n        \n        if not selected_attack:\n            st.error(\"Please select an attack type before starting simulation\")\n            return\n            \n        with st.spinner(f\"Running {selected_attack} simulation...\"):\n            simulation_results = st.session_state.attack_simulator.run_simulation(\n                category=selected_category,\n                attack_type=selected_attack,\n                target=target_environment,\n                intensity=intensity_level,\n                duration=duration,\n                safe_mode=safe_mode\n            )\n            \n            # Display results\n            st.success(\"âœ… Simulation completed successfully!\")\n            \n            col1, col2 = st.columns(2)\n            \n            with col1:\n                st.subheader(\"ðŸ“Š Detection Results\")\n                st.write(f\"**Attacks Launched**: {simulation_results['attacks_launched']}\")\n                st.write(f\"**Attacks Detected**: {simulation_results['attacks_detected']}\")\n                detection_rate = (simulation_results['attacks_detected'] / simulation_results['attacks_launched']) * 100\n                st.metric(\"Detection Rate\", f\"{detection_rate:.1f}%\")\n                \n                if simulation_results['missed_attacks']:\n                    st.write(\"**Missed Attacks:**\")\n                    for missed in simulation_results['missed_attacks']:\n                        st.write(f\"â€¢ {missed}\")\n            \n            with col2:\n                st.subheader(\"ðŸ•’ Response Times\")\n                st.write(f\"**Average Detection Time**: {simulation_results['avg_detection_time']}\")\n                st.write(f\"**Fastest Response**: {simulation_results['fastest_response']}\")\n                st.write(f\"**Slowest Response**: {simulation_results['slowest_response']}\")\n                \n                if simulation_results['response_actions']:\n                    st.write(\"**Automated Responses Triggered:**\")\n                    for action in simulation_results['response_actions']:\n                        st.write(f\"â€¢ {action}\")\n    \n    # Penetration testing results\n    st.subheader(\"ðŸ” Previous Simulation Results\")\n    \n    simulation_history = st.session_state.attack_simulator.get_simulation_history()\n    \n    if simulation_history:\n        df = pd.DataFrame(simulation_history)\n        \n        # Summary metrics\n        col1, col2, col3, col4 = st.columns(4)\n        \n        with col1:\n            avg_detection = df['detection_rate'].mean()\n            st.metric(\"Average Detection Rate\", f\"{avg_detection:.1f}%\")\n        \n        with col2:\n            total_simulations = len(df)\n            st.metric(\"Total Simulations\", total_simulations)\n        \n        with col3:\n            successful_blocks = df['attacks_blocked'].sum()\n            st.metric(\"Total Attacks Blocked\", successful_blocks)\n        \n        with col4:\n            avg_response_time = df['avg_response_time'].mean()\n            st.metric(\"Avg Response Time\", f\"{avg_response_time:.1f}s\")\n        \n        # Detection rate trend\n        fig = px.line(\n            df,\n            x='timestamp',\n            y='detection_rate',\n            title=\"Detection Rate Trend Over Time\"\n        )\n        st.plotly_chart(fig, use_container_width=True)\n        \n        # Detailed results table\n        st.dataframe(df, use_container_width=True)\n\ndef show_analytics_reports():\n    \"\"\"Analytics and reporting interface\"\"\"\n    st.header(\"ðŸ“ˆ Security Analytics & Reporting\")\n    \n    # Report type selection\n    col1, col2, col3 = st.columns(3)\n    \n    with col1:\n        report_type = st.selectbox(\n            \"Report Type\",\n            [\"Executive Summary\", \"Technical Analysis\", \"Compliance Report\", \"Threat Intelligence\", \"Custom Report\"]\n        )\n    \n    with col2:\n        time_period = st.selectbox(\n            \"Time Period\",\n            [\"Last 24 hours\", \"Last 7 days\", \"Last 30 days\", \"Last 90 days\", \"Custom Range\"]\n        )\n    \n    with col3:\n        if st.button(\"ðŸ“Š Generate Report\"):\n            generate_security_report(report_type, time_period)\n    \n    # Key metrics dashboard\n    st.subheader(\"ðŸŽ¯ Key Security Metrics\")\n    \n    metrics = st.session_state.data_processor.get_security_metrics()\n    \n    # Top-level KPIs\n    col1, col2, col3, col4, col5 = st.columns(5)\n    \n    with col1:\n        st.metric(\"Mean Time to Detection (MTTD)\", f\"{metrics['mttd']:.1f}m\", delta=f\"{metrics['mttd_trend']:+.1f}m\")\n    \n    with col2:\n        st.metric(\"Mean Time to Response (MTTR)\", f\"{metrics['mttr']:.1f}m\", delta=f\"{metrics['mttr_trend']:+.1f}m\")\n    \n    with col3:\n        st.metric(\"Security Score\", f\"{metrics['security_score']:.1f}/10\", delta=f\"{metrics['score_trend']:+.1f}\")\n    \n    with col4:\n        st.metric(\"Threat Volume\", metrics['threat_volume'], delta=f\"{int(metrics['volume_trend']):+d}\")\n    \n    with col5:\n        st.metric(\"False Positive Rate\", f\"{metrics['false_positive_rate']:.1%}\", delta=f\"{metrics['fp_trend']:+.1%}\")\n    \n    # Advanced analytics\n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.subheader(\"ðŸ”¥ Threat Heatmap\")\n        threat_heatmap = st.session_state.data_processor.get_threat_heatmap()\n        \n        if threat_heatmap:\n            fig = px.imshow(\n                threat_heatmap['data'],\n                x=threat_heatmap['hours'],\n                y=threat_heatmap['days'],\n                title=\"Threat Activity Heatmap (24h x 7 days)\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n    \n    with col2:\n        st.subheader(\"ðŸ“Š Attack Vector Analysis\")\n        attack_vectors = st.session_state.data_processor.get_attack_vector_analysis()\n        \n        if attack_vectors:\n            fig = px.treemap(\n                values=list(attack_vectors.values()),\n                names=list(attack_vectors.keys()),\n                title=\"Attack Vectors Distribution\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n    \n    # Threat intelligence integration\n    st.subheader(\"ðŸŒ Threat Intelligence Dashboard\")\n    \n    col1, col2 = st.columns(2)\n    \n    with col1:\n        st.write(\"**Global Threat Landscape**\")\n        global_threats = st.session_state.threat_intel.get_global_threats()\n        \n        if global_threats:\n            for threat in global_threats[:5]:\n                severity_emoji = {\n                    'Critical': 'ðŸ”´',\n                    'High': 'ðŸŸ ',\n                    'Medium': 'ðŸŸ¡',\n                    'Low': 'ðŸŸ¢'\n                }.get(threat['severity'], 'âšª')\n                \n                st.write(f\"{severity_emoji} **{threat['name']}**\")\n                st.write(f\"First Seen: {threat['first_seen']}\")\n                st.write(f\"Affected Systems: {threat['affected_systems']}\")\n                st.write(\"---\")\n    \n    with col2:\n        st.write(\"**IOC Feed**\")\n        iocs = st.session_state.threat_intel.get_latest_iocs()\n        \n        if iocs:\n            df_iocs = pd.DataFrame(iocs)\n            st.dataframe(df_iocs, use_container_width=True)\n    \n    # Predictive analytics\n    st.subheader(\"ðŸ”® Predictive Threat Analysis\")\n    \n    predictions = st.session_state.ai_analyzer.get_threat_predictions()\n    \n    if predictions:\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            # Threat forecast\n            fig = px.line(\n                x=predictions['dates'],\n                y=predictions['predicted_threats'],\n                title=\"Predicted Threat Volume (Next 7 Days)\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n        \n        with col2:\n            # Risk assessment\n            st.write(\"**Predicted High-Risk Periods:**\")\n            for period in predictions['high_risk_periods']:\n                st.write(f\"â€¢ {period['date']}: {period['risk_level']} risk ({period['confidence']:.1%} confidence)\")\n\ndef show_system_configuration():\n    \"\"\"System configuration interface\"\"\"\n    st.header(\"âš™ï¸ System Configuration & Settings\")\n    \n    # Configuration tabs\n    tab1, tab2, tab3, tab4 = st.tabs([\"ðŸ”§ General Settings\", \"ðŸ¤– AI Models\", \"ðŸ”— Integrations\", \"ðŸ‘¥ User Management\"])\n    \n    with tab1:\n        st.subheader(\"General System Settings\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.write(\"**Detection Settings**\")\n            global_sensitivity = st.slider(\"Global Detection Sensitivity\", 0.1, 1.0, 0.7, 0.1)\n            auto_response = st.checkbox(\"Enable Automatic Response\", value=True)\n            quarantine_malware = st.checkbox(\"Auto-quarantine Malware\", value=True)\n            block_malicious_ips = st.checkbox(\"Auto-block Malicious IPs\", value=True)\n            \n            st.write(\"**Alert Settings**\")\n            email_alerts = st.checkbox(\"Email Alerts\", value=True)\n            sms_alerts = st.checkbox(\"SMS Alerts\", value=False)\n            webhook_alerts = st.checkbox(\"Webhook Alerts\", value=True)\n            \n            if email_alerts:\n                alert_email = st.text_input(\"Alert Email\", value=\"admin@company.com\")\n            \n            if webhook_alerts:\n                webhook_url = st.text_input(\"Webhook URL\", value=\"https://your-webhook-url.com\")\n        \n        with col2:\n            st.write(\"**Logging & Retention**\")\n            log_level = st.selectbox(\"Log Level\", [\"DEBUG\", \"INFO\", \"WARNING\", \"ERROR\", \"CRITICAL\"])\n            retention_days = st.number_input(\"Log Retention (days)\", min_value=1, max_value=365, value=90)\n            \n            st.write(\"**Performance Settings**\")\n            max_concurrent_scans = st.number_input(\"Max Concurrent Scans\", min_value=1, max_value=10, value=3)\n            scan_timeout = st.number_input(\"Scan Timeout (minutes)\", min_value=1, max_value=60, value=15)\n            \n            st.write(\"**Backup & Recovery**\")\n            if st.button(\"ðŸ”„ Backup Configuration\"):\n                st.success(\"Configuration backed up successfully\")\n            \n            if st.button(\"ðŸ“¥ Export Logs\"):\n                st.success(\"Logs exported successfully\")\n    \n    with tab2:\n        st.subheader(\"AI Model Configuration\")\n        \n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.write(\"**Model Performance**\")\n            model_stats = st.session_state.ai_analyzer.get_model_statistics()\n            \n            st.metric(\"Detection Accuracy\", f\"{model_stats['accuracy']:.1%}\")\n            st.metric(\"False Positive Rate\", f\"{model_stats['false_positive_rate']:.1%}\")\n            st.metric(\"Model Training Date\", model_stats['last_trained'])\n            \n            if st.button(\"ðŸ”„ Retrain Models\"):\n                with st.spinner(\"Retraining AI models...\"):\n                    st.session_state.ai_analyzer.retrain_models()\n                    st.success(\"Models retrained successfully\")\n        \n        with col2:\n            st.write(\"**Model Selection**\")\n            \n            available_models = [\"Random Forest\", \"Isolation Forest\", \"LSTM\", \"Ensemble\"]\n            selected_models = st.multiselect(\"Active Models\", available_models, default=available_models)\n            \n            st.write(\"**Model Parameters**\")\n            ensemble_weight = st.slider(\"Ensemble Weight\", 0.1, 1.0, 0.8, 0.1)\n            confidence_threshold = st.slider(\"Confidence Threshold\", 0.1, 1.0, 0.7, 0.1)\n            \n            if st.button(\"ðŸ’¾ Save Model Configuration\"):\n                st.session_state.ai_analyzer.update_model_config(selected_models, ensemble_weight, confidence_threshold)\n                st.success(\"Model configuration saved\")\n    \n    with tab3:\n        st.subheader(\"External Integrations\")\n        \n        st.write(\"**Threat Intelligence Feeds**\")\n        \n        # API configurations\n        integrations = {\n            \"VirusTotal\": {\"enabled\": True, \"api_key\": \"vt_api_key\"},\n            \"Shodan\": {\"enabled\": False, \"api_key\": \"shodan_api_key\"},\n            \"IBM X-Force\": {\"enabled\": False, \"api_key\": \"xforce_api_key\"},\n            \"OTX AlienVault\": {\"enabled\": True, \"api_key\": \"otx_api_key\"},\n            \"Malware Bazaar\": {\"enabled\": True, \"api_key\": \"\"},\n        }\n        \n        for service, config in integrations.items():\n            col1, col2, col3 = st.columns([1, 2, 1])\n            \n            with col1:\n                enabled = st.checkbox(service, value=config[\"enabled\"])\n            \n            with col2:\n                if config[\"api_key\"]:\n                    api_key = st.text_input(f\"{service} API Key\", type=\"password\", \n                                          value=os.getenv(config[\"api_key\"], \"\"))\n            \n            with col3:\n                if st.button(f\"Test {service}\"):\n                    if enabled:\n                        test_result = st.session_state.threat_intel.test_integration(service)\n                        if test_result:\n                            st.success(\"âœ…\")\n                        else:\n                            st.error(\"âŒ\")\n        \n        st.write(\"**SIEM Integration**\")\n        siem_type = st.selectbox(\"SIEM Platform\", [\"Splunk\", \"QRadar\", \"ArcSight\", \"LogRhythm\", \"Custom\"])\n        siem_endpoint = st.text_input(\"SIEM Endpoint URL\")\n        siem_auth = st.text_input(\"Authentication Token\", type=\"password\")\n        \n        if st.button(\"ðŸ”— Test SIEM Connection\"):\n            st.success(\"SIEM connection test successful\")\n    \n    with tab4:\n        st.subheader(\"User Management & Access Control\")\n        \n        # User roles and permissions\n        col1, col2 = st.columns(2)\n        \n        with col1:\n            st.write(\"**User Roles**\")\n            \n            roles = {\n                \"Security Admin\": [\"Full access\", \"User management\", \"System configuration\"],\n                \"Security Analyst\": [\"View dashboards\", \"Manage alerts\", \"Run scans\"],\n                \"Incident Responder\": [\"View alerts\", \"Respond to incidents\", \"Access logs\"],\n                \"Auditor\": [\"Read-only access\", \"Generate reports\", \"View configurations\"]\n            }\n            \n            for role, permissions in roles.items():\n                with st.expander(f\"ðŸ‘¤ {role}\"):\n                    for permission in permissions:\n                        st.write(f\"â€¢ {permission}\")\n        \n        with col2:\n            st.write(\"**Active Users**\")\n            \n            users = [\n                {\"name\": \"Admin User\", \"role\": \"Security Admin\", \"last_login\": \"2024-08-24 10:30\"},\n                {\"name\": \"John Analyst\", \"role\": \"Security Analyst\", \"last_login\": \"2024-08-24 09:15\"},\n                {\"name\": \"Jane Responder\", \"role\": \"Incident Responder\", \"last_login\": \"2024-08-23 16:45\"}\n            ]\n            \n            for user in users:\n                st.write(f\"**{user['name']}** - {user['role']}\")\n                st.write(f\"Last Login: {user['last_login']}\")\n                st.write(\"---\")\n        \n        # Add new user\n        st.write(\"**Add New User**\")\n        col1, col2, col3 = st.columns(3)\n        \n        with col1:\n            new_username = st.text_input(\"Username\")\n        with col2:\n            new_email = st.text_input(\"Email\")\n        with col3:\n            new_role = st.selectbox(\"Role\", list(roles.keys()))\n        \n        if st.button(\"âž• Add User\"):\n            if new_username and new_email:\n                st.success(f\"User {new_username} added successfully\")\n\ndef generate_security_report(report_type, time_period):\n    \"\"\"Generate comprehensive security reports\"\"\"\n    with st.spinner(f\"Generating {report_type} for {time_period}...\"):\n        # Simulate report generation\n        time.sleep(2)\n        \n        st.success(f\"âœ… {report_type} generated successfully!\")\n        \n        # Executive Summary Report\n        if report_type == \"Executive Summary\":\n            st.subheader(\"ðŸ“‹ Executive Security Summary\")\n            \n            col1, col2 = st.columns(2)\n            \n            with col1:\n                st.write(\"**Key Highlights:**\")\n                st.write(\"â€¢ 347 security events processed\")\n                st.write(\"â€¢ 23 threats detected and mitigated\")\n                st.write(\"â€¢ 99.3% system uptime maintained\")\n                st.write(\"â€¢ 2.1% false positive rate achieved\")\n            \n            with col2:\n                st.write(\"**Risk Assessment:**\")\n                st.write(\"â€¢ Overall Risk Level: Medium\")\n                st.write(\"â€¢ Critical Vulnerabilities: 2\")\n                st.write(\"â€¢ Compliance Score: 94%\")\n                st.write(\"â€¢ Recommended Actions: 5\")\n        \n        # Technical Analysis Report\n        elif report_type == \"Technical Analysis\":\n            st.subheader(\"ðŸ”§ Technical Security Analysis\")\n            \n            # Threat distribution\n            threat_data = {\n                'Malware': 45,\n                'Phishing': 23, \n                'Network Intrusion': 15,\n                'Data Exfiltration': 8,\n                'Privilege Escalation': 5,\n                'Other': 4\n            }\n            \n            fig = px.bar(\n                x=list(threat_data.keys()),\n                y=list(threat_data.values()),\n                title=\"Threat Types Distribution\"\n            )\n            st.plotly_chart(fig, use_container_width=True)\n        \n        # Download report\n        if st.button(\"ðŸ“¥ Download Report\"):\n            st.success(\"Report downloaded to your system\")\n\ndef start_background_monitoring():\n    \"\"\"Start background monitoring processes\"\"\"\n    def monitor_loop():\n        while st.session_state.get('monitoring_active', False):\n            try:\n                # Run monitoring checks\n                st.session_state.network_monitor.run_continuous_monitoring()\n                st.session_state.endpoint_monitor.run_continuous_monitoring()\n                st.session_state.iot_monitor.run_continuous_monitoring()\n                st.session_state.mobile_monitor.run_continuous_monitoring()\n                \n                # Sleep for 30 seconds before next check\n                time.sleep(30)\n            except Exception as e:\n                print(f\"Background monitoring error: {e}\")\n                break\n    \n    # Start monitoring thread\n    if not hasattr(st.session_state, 'monitoring_thread'):\n        st.session_state.monitoring_thread = threading.Thread(target=monitor_loop, daemon=True)\n        st.session_state.monitoring_thread.start()\n\nif __name__ == \"__main__\":\n    main()\n","size_bytes":44780},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"ipaddress>=1.0.23\",\n    \"joblib>=1.5.1\",\n    \"numpy>=2.3.2\",\n    \"pandas>=2.3.2\",\n    \"plotly>=6.3.0\",\n    \"psutil>=7.0.0\",\n    \"requests>=2.32.5\",\n    \"scikit-learn>=1.7.1\",\n    \"streamlit>=1.48.1\",\n    \"trafilatura>=2.0.0\",\n]\n","size_bytes":375},"replit.md":{"content":"# Overview\n\nThis is an AI-powered cybersecurity threat detection system built with Streamlit. It provides comprehensive security monitoring across multiple environments including networks, endpoints, IoT devices, and mobile devices. The system uses machine learning models for threat analysis, simulates attacks for testing defenses, and integrates with external threat intelligence feeds. It's designed as a demonstration platform showcasing advanced cybersecurity capabilities including real-time monitoring, automated threat response, and incident management.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Frontend Framework\n- **Streamlit**: Web-based dashboard for security monitoring and management\n- **Plotly**: Interactive charts and visualizations for threat data\n- **Session State Management**: Persistent storage of security components across user sessions\n\n## Core Security Engine\n- **Modular Architecture**: Separate specialized modules for different security domains\n- **ThreatDetectionEngine**: Central coordination engine managing all security modules\n- **AIThreatAnalyzer**: Machine learning-based threat analysis using Random Forest and Isolation Forest models\n- **LogAnalyzer**: Advanced log parsing and digital forensics capabilities\n- **AlertManager**: Incident response and escalation management system\n\n## Monitoring Systems\n- **NetworkMonitor**: Network intrusion detection and traffic analysis\n- **EndpointMonitor**: Endpoint security with malware detection and behavioral analysis\n- **IoTMonitor**: IoT device security monitoring and vulnerability management\n- **MobileMonitor**: Mobile device management (MDM) with policy enforcement\n\n## Attack Simulation Framework\n- **AttackSimulator**: General-purpose attack simulation for testing defenses\n- **RansomwareSimulator**: Specialized ransomware behavior simulation\n- **NetworkAttackSimulator**: Network-based attack testing (DDoS, intrusion attempts)\n\n## Data Processing & Intelligence\n- **DataProcessor**: Advanced analytics with anomaly detection and correlation analysis\n- **ThreatIntelligence**: Integration with external threat feeds and IOC management\n- **Configuration Management**: Centralized settings and security policies\n\n## Security Features\n- **Multi-layered Detection**: Combines signature-based, behavioral, and ML-based detection\n- **Automated Response**: Auto-quarantine, IP blocking, and system isolation capabilities\n- **Threat Correlation**: Cross-system analysis to identify coordinated attacks\n- **Compliance Monitoring**: Policy enforcement across different device types\n\n# External Dependencies\n\n## Machine Learning Libraries\n- **scikit-learn**: Random Forest and Isolation Forest models for threat classification\n- **pandas**: Data manipulation and analysis\n- **numpy**: Numerical computations for ML models\n\n## Visualization & UI\n- **Streamlit**: Primary web application framework\n- **Plotly Express/Graph Objects**: Interactive dashboards and data visualizations\n\n## System Monitoring\n- **psutil**: System resource monitoring and process analysis\n\n## Threat Intelligence APIs\n- **VirusTotal**: Malware and URL reputation checking\n- **Shodan**: Internet-connected device scanning\n- **IBM X-Force**: Threat intelligence feeds\n- **AlienVault OTX**: Open threat exchange\n- **AbuseIPDB**: IP reputation database\n- **Hybrid Analysis**: Malware analysis sandbox\n- **URLVoid**: URL reputation service\n\n## Data Storage (Configured)\n- **SQLite**: Default local database (DATABASE_URL configurable)\n- **Redis**: Caching and session storage (REDIS_URL configurable)\n\n## Infrastructure Services\n- **Email Notifications**: SMTP integration for alert delivery\n- **Webhook Integration**: External system notifications\n- **API Integration**: RESTful interfaces for external security tools\n\n## Development & Deployment\n- **Environment Configuration**: Extensive environment variable support\n- **Logging Framework**: Configurable logging levels and outputs\n- **Backup Systems**: Automated data retention and backup capabilities","size_bytes":4071},"config/settings.py":{"content":"import os\nfrom datetime import timedelta, datetime\nfrom typing import Dict, Any, List\n\nclass SecuritySettings:\n    \"\"\"Configuration settings for the cybersecurity threat detection system\"\"\"\n    \n    def __init__(self):\n        self.load_settings()\n    \n    def load_settings(self):\n        \"\"\"Load all configuration settings\"\"\"\n        \n        # System Configuration\n        self.SYSTEM_NAME = \"AI-Powered Cybersecurity Threat Detection System\"\n        self.VERSION = \"1.0.0\"\n        self.DEBUG_MODE = os.getenv(\"DEBUG_MODE\", \"False\").lower() == \"true\"\n        self.LOG_LEVEL = os.getenv(\"LOG_LEVEL\", \"INFO\")\n        \n        # Database and Storage\n        self.DATABASE_URL = os.getenv(\"DATABASE_URL\", \"sqlite:///security.db\")\n        self.REDIS_URL = os.getenv(\"REDIS_URL\", \"redis://localhost:6379/0\")\n        self.DATA_RETENTION_DAYS = int(os.getenv(\"DATA_RETENTION_DAYS\", \"90\"))\n        self.BACKUP_INTERVAL_HOURS = int(os.getenv(\"BACKUP_INTERVAL_HOURS\", \"24\"))\n        \n        # API Keys and External Services\n        self.API_KEYS = {\n            'virustotal': os.getenv(\"VIRUSTOTAL_API_KEY\", \"\"),\n            'shodan': os.getenv(\"SHODAN_API_KEY\", \"\"),\n            'xforce': os.getenv(\"XFORCE_API_KEY\", \"\"),\n            'otx': os.getenv(\"OTX_API_KEY\", \"\"),\n            'abuseipdb': os.getenv(\"ABUSEIPDB_API_KEY\", \"\"),\n            'hybrid_analysis': os.getenv(\"HYBRID_ANALYSIS_API_KEY\", \"\"),\n            'urlvoid': os.getenv(\"URLVOID_API_KEY\", \"\")\n        }\n        \n        # Threat Detection Settings\n        self.THREAT_DETECTION = {\n            'global_sensitivity': float(os.getenv(\"THREAT_SENSITIVITY\", \"0.7\")),\n            'auto_quarantine': os.getenv(\"AUTO_QUARANTINE\", \"True\").lower() == \"true\",\n            'auto_block_ips': os.getenv(\"AUTO_BLOCK_IPS\", \"True\").lower() == \"true\",\n            'auto_isolate_endpoints': os.getenv(\"AUTO_ISOLATE_ENDPOINTS\", \"False\").lower() == \"true\",\n            'confidence_threshold': float(os.getenv(\"CONFIDENCE_THRESHOLD\", \"0.8\")),\n            'correlation_window_minutes': int(os.getenv(\"CORRELATION_WINDOW\", \"30\")),\n            'max_concurrent_scans': int(os.getenv(\"MAX_CONCURRENT_SCANS\", \"5\"))\n        }\n        \n        # Alert Configuration\n        self.ALERT_SETTINGS = {\n            'email_enabled': os.getenv(\"EMAIL_ALERTS\", \"True\").lower() == \"true\",\n            'sms_enabled': os.getenv(\"SMS_ALERTS\", \"False\").lower() == \"true\",\n            'webhook_enabled': os.getenv(\"WEBHOOK_ALERTS\", \"True\").lower() == \"true\",\n            'slack_enabled': os.getenv(\"SLACK_ALERTS\", \"False\").lower() == \"true\",\n            'email_recipients': os.getenv(\"ALERT_EMAIL_RECIPIENTS\", \"security-team@company.com\").split(\",\"),\n            'webhook_url': os.getenv(\"ALERT_WEBHOOK_URL\", \"https://webhook.company.com/security-alerts\"),\n            'slack_webhook': os.getenv(\"SLACK_WEBHOOK_URL\", \"\"),\n            'notification_throttle_minutes': int(os.getenv(\"NOTIFICATION_THROTTLE\", \"5\")),\n            'escalation_enabled': os.getenv(\"ALERT_ESCALATION\", \"True\").lower() == \"true\"\n        }\n        \n        # SLA and Response Times\n        self.SLA_CONFIGURATION = {\n            'critical_response_minutes': int(os.getenv(\"CRITICAL_SLA_MINUTES\", \"15\")),\n            'high_response_hours': int(os.getenv(\"HIGH_SLA_HOURS\", \"2\")),\n            'medium_response_hours': int(os.getenv(\"MEDIUM_SLA_HOURS\", \"8\")),\n            'low_response_hours': int(os.getenv(\"LOW_SLA_HOURS\", \"24\")),\n            'escalation_intervals': {\n                'critical': timedelta(minutes=15),\n                'high': timedelta(hours=1),\n                'medium': timedelta(hours=4),\n                'low': timedelta(hours=12)\n            }\n        }\n        \n        # Network Monitoring\n        self.NETWORK_MONITORING = {\n            'monitored_networks': os.getenv(\"MONITORED_NETWORKS\", \"192.168.1.0/24,10.0.0.0/8,172.16.0.0/12\").split(\",\"),\n            'ids_enabled': os.getenv(\"IDS_ENABLED\", \"True\").lower() == \"true\",\n            'ips_enabled': os.getenv(\"IPS_ENABLED\", \"True\").lower() == \"true\",\n            'packet_capture_enabled': os.getenv(\"PACKET_CAPTURE\", \"False\").lower() == \"true\",\n            'flow_monitoring': os.getenv(\"FLOW_MONITORING\", \"True\").lower() == \"true\",\n            'baseline_learning_days': int(os.getenv(\"BASELINE_LEARNING_DAYS\", \"7\")),\n            'anomaly_threshold': float(os.getenv(\"ANOMALY_THRESHOLD\", \"2.5\"))\n        }\n        \n        # Endpoint Security\n        self.ENDPOINT_SECURITY = {\n            'real_time_protection': os.getenv(\"REAL_TIME_PROTECTION\", \"True\").lower() == \"true\",\n            'behavioral_analysis': os.getenv(\"BEHAVIORAL_ANALYSIS\", \"True\").lower() == \"true\",\n            'file_integrity_monitoring': os.getenv(\"FILE_INTEGRITY_MONITORING\", \"True\").lower() == \"true\",\n            'process_monitoring': os.getenv(\"PROCESS_MONITORING\", \"True\").lower() == \"true\",\n            'registry_monitoring': os.getenv(\"REGISTRY_MONITORING\", \"True\").lower() == \"true\",\n            'network_monitoring': os.getenv(\"ENDPOINT_NETWORK_MONITORING\", \"True\").lower() == \"true\",\n            'quarantine_directory': os.getenv(\"QUARANTINE_DIRECTORY\", \"/quarantine/\"),\n            'scan_schedule_hours': int(os.getenv(\"SCAN_SCHEDULE_HOURS\", \"24\")),\n            'max_scan_duration_minutes': int(os.getenv(\"MAX_SCAN_DURATION\", \"60\"))\n        }\n        \n        # IoT Security\n        self.IOT_SECURITY = {\n            'device_discovery': os.getenv(\"IOT_DEVICE_DISCOVERY\", \"True\").lower() == \"true\",\n            'vulnerability_scanning': os.getenv(\"IOT_VULN_SCANNING\", \"True\").lower() == \"true\",\n            'traffic_analysis': os.getenv(\"IOT_TRAFFIC_ANALYSIS\", \"True\").lower() == \"true\",\n            'default_credential_check': os.getenv(\"IOT_DEFAULT_CREDS\", \"True\").lower() == \"true\",\n            'firmware_analysis': os.getenv(\"IOT_FIRMWARE_ANALYSIS\", \"False\").lower() == \"true\",\n            'network_segmentation': os.getenv(\"IOT_NETWORK_SEGMENTATION\", \"True\").lower() == \"true\",\n            'scan_interval_hours': int(os.getenv(\"IOT_SCAN_INTERVAL\", \"6\"))\n        }\n        \n        # Mobile Security\n        self.MOBILE_SECURITY = {\n            'mdm_integration': os.getenv(\"MDM_INTEGRATION\", \"True\").lower() == \"true\",\n            'app_reputation_checking': os.getenv(\"APP_REPUTATION_CHECK\", \"True\").lower() == \"true\",\n            'device_compliance_monitoring': os.getenv(\"DEVICE_COMPLIANCE\", \"True\").lower() == \"true\",\n            'jailbreak_detection': os.getenv(\"JAILBREAK_DETECTION\", \"True\").lower() == \"true\",\n            'network_traffic_analysis': os.getenv(\"MOBILE_TRAFFIC_ANALYSIS\", \"True\").lower() == \"true\",\n            'policy_enforcement': os.getenv(\"MOBILE_POLICY_ENFORCEMENT\", \"True\").lower() == \"true\",\n            'remote_wipe_enabled': os.getenv(\"REMOTE_WIPE\", \"True\").lower() == \"true\"\n        }\n        \n        # AI and Machine Learning\n        self.AI_ML_SETTINGS = {\n            'ensemble_models': os.getenv(\"ENSEMBLE_MODELS\", \"True\").lower() == \"true\",\n            'model_retraining_interval_days': int(os.getenv(\"MODEL_RETRAIN_DAYS\", \"7\")),\n            'feature_selection_enabled': os.getenv(\"FEATURE_SELECTION\", \"True\").lower() == \"true\",\n            'anomaly_detection_enabled': os.getenv(\"ANOMALY_DETECTION\", \"True\").lower() == \"true\",\n            'false_positive_learning': os.getenv(\"FP_LEARNING\", \"True\").lower() == \"true\",\n            'model_performance_monitoring': os.getenv(\"MODEL_MONITORING\", \"True\").lower() == \"true\",\n            'prediction_confidence_threshold': float(os.getenv(\"PREDICTION_THRESHOLD\", \"0.75\"))\n        }\n        \n        # Threat Intelligence\n        self.THREAT_INTELLIGENCE = {\n            'feed_update_interval_hours': int(os.getenv(\"TI_UPDATE_INTERVAL\", \"6\")),\n            'ioc_retention_days': int(os.getenv(\"IOC_RETENTION_DAYS\", \"30\")),\n            'reputation_cache_hours': int(os.getenv(\"REPUTATION_CACHE_HOURS\", \"6\")),\n            'auto_feed_updates': os.getenv(\"AUTO_FEED_UPDATES\", \"True\").lower() == \"true\",\n            'external_feed_enabled': os.getenv(\"EXTERNAL_FEEDS\", \"True\").lower() == \"true\",\n            'threat_hunting_enabled': os.getenv(\"THREAT_HUNTING\", \"True\").lower() == \"true\",\n            'attribution_analysis': os.getenv(\"ATTRIBUTION_ANALYSIS\", \"True\").lower() == \"true\"\n        }\n        \n        # Compliance and Reporting\n        self.COMPLIANCE_SETTINGS = {\n            'gdpr_compliance': os.getenv(\"GDPR_COMPLIANCE\", \"True\").lower() == \"true\",\n            'hipaa_compliance': os.getenv(\"HIPAA_COMPLIANCE\", \"False\").lower() == \"true\",\n            'pci_dss_compliance': os.getenv(\"PCI_DSS_COMPLIANCE\", \"False\").lower() == \"true\",\n            'sox_compliance': os.getenv(\"SOX_COMPLIANCE\", \"False\").lower() == \"true\",\n            'audit_logging': os.getenv(\"AUDIT_LOGGING\", \"True\").lower() == \"true\",\n            'report_generation_schedule': os.getenv(\"REPORT_SCHEDULE\", \"daily\"),\n            'data_anonymization': os.getenv(\"DATA_ANONYMIZATION\", \"True\").lower() == \"true\"\n        }\n        \n        # Performance and Scaling\n        self.PERFORMANCE_SETTINGS = {\n            'max_worker_threads': int(os.getenv(\"MAX_WORKER_THREADS\", \"10\")),\n            'queue_max_size': int(os.getenv(\"QUEUE_MAX_SIZE\", \"10000\")),\n            'cache_size_mb': int(os.getenv(\"CACHE_SIZE_MB\", \"1024\")),\n            'batch_processing_size': int(os.getenv(\"BATCH_SIZE\", \"100\")),\n            'connection_pool_size': int(os.getenv(\"CONNECTION_POOL_SIZE\", \"20\")),\n            'request_timeout_seconds': int(os.getenv(\"REQUEST_TIMEOUT\", \"30\")),\n            'health_check_interval_seconds': int(os.getenv(\"HEALTH_CHECK_INTERVAL\", \"60\"))\n        }\n        \n        # Security Hardening\n        self.SECURITY_HARDENING = {\n            'encryption_key': os.getenv(\"ENCRYPTION_KEY\", self._generate_default_key()),\n            'jwt_secret': os.getenv(\"JWT_SECRET\", self._generate_default_key()),\n            'api_rate_limiting': os.getenv(\"API_RATE_LIMITING\", \"True\").lower() == \"true\",\n            'max_requests_per_minute': int(os.getenv(\"MAX_REQUESTS_PER_MINUTE\", \"100\")),\n            'secure_headers': os.getenv(\"SECURE_HEADERS\", \"True\").lower() == \"true\",\n            'ssl_verification': os.getenv(\"SSL_VERIFICATION\", \"True\").lower() == \"true\",\n            'password_policy_enabled': os.getenv(\"PASSWORD_POLICY\", \"True\").lower() == \"true\",\n            'session_timeout_minutes': int(os.getenv(\"SESSION_TIMEOUT\", \"60\"))\n        }\n        \n        # Simulation and Testing\n        self.SIMULATION_SETTINGS = {\n            'simulation_enabled': os.getenv(\"SIMULATION_ENABLED\", \"True\").lower() == \"true\",\n            'safe_mode_default': os.getenv(\"SAFE_MODE_DEFAULT\", \"True\").lower() == \"true\",\n            'max_simulation_duration_minutes': int(os.getenv(\"MAX_SIMULATION_DURATION\", \"60\")),\n            'simulation_logging': os.getenv(\"SIMULATION_LOGGING\", \"True\").lower() == \"true\",\n            'red_team_exercises': os.getenv(\"RED_TEAM_EXERCISES\", \"False\").lower() == \"true\",\n            'penetration_testing': os.getenv(\"PENETRATION_TESTING\", \"False\").lower() == \"true\"\n        }\n        \n        # Integration Settings\n        self.INTEGRATION_SETTINGS = {\n            'siem_integration': os.getenv(\"SIEM_INTEGRATION\", \"False\").lower() == \"true\",\n            'siem_type': os.getenv(\"SIEM_TYPE\", \"splunk\"),\n            'siem_endpoint': os.getenv(\"SIEM_ENDPOINT\", \"\"),\n            'siem_api_key': os.getenv(\"SIEM_API_KEY\", \"\"),\n            'soar_integration': os.getenv(\"SOAR_INTEGRATION\", \"False\").lower() == \"true\",\n            'ticketing_integration': os.getenv(\"TICKETING_INTEGRATION\", \"False\").lower() == \"true\",\n            'cloud_security_integration': os.getenv(\"CLOUD_SECURITY\", \"True\").lower() == \"true\"\n        }\n    \n    def _generate_default_key(self) -> str:\n        \"\"\"Generate a default encryption key if none provided\"\"\"\n        import secrets\n        return secrets.token_urlsafe(32)\n    \n    def get_setting(self, category: str, key: str, default: Any = None) -> Any:\n        \"\"\"Get a specific setting value\"\"\"\n        category_settings = getattr(self, category.upper(), {})\n        return category_settings.get(key, default)\n    \n    def update_setting(self, category: str, key: str, value: Any) -> bool:\n        \"\"\"Update a specific setting value\"\"\"\n        try:\n            category_settings = getattr(self, category.upper(), {})\n            category_settings[key] = value\n            return True\n        except Exception:\n            return False\n    \n    def get_all_settings(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get all settings organized by category\"\"\"\n        settings = {}\n        \n        # Get all setting categories\n        setting_categories = [\n            'API_KEYS', 'THREAT_DETECTION', 'ALERT_SETTINGS', 'SLA_CONFIGURATION',\n            'NETWORK_MONITORING', 'ENDPOINT_SECURITY', 'IOT_SECURITY', 'MOBILE_SECURITY',\n            'AI_ML_SETTINGS', 'THREAT_INTELLIGENCE', 'COMPLIANCE_SETTINGS',\n            'PERFORMANCE_SETTINGS', 'SECURITY_HARDENING', 'SIMULATION_SETTINGS',\n            'INTEGRATION_SETTINGS'\n        ]\n        \n        for category in setting_categories:\n            settings[category.lower()] = getattr(self, category, {})\n        \n        return settings\n    \n    def validate_settings(self) -> Dict[str, List[str]]:\n        \"\"\"Validate all settings and return any issues\"\"\"\n        issues = {\n            'errors': [],\n            'warnings': [],\n            'recommendations': []\n        }\n        \n        # Validate API keys\n        for service, key in self.API_KEYS.items():\n            if not key and service in ['virustotal', 'otx']:  # Required services\n                issues['warnings'].append(f\"Missing API key for {service}\")\n        \n        # Validate network settings\n        if not self.NETWORK_MONITORING['monitored_networks']:\n            issues['errors'].append(\"No monitored networks configured\")\n        \n        # Validate alert settings\n        if not any([self.ALERT_SETTINGS['email_enabled'], \n                   self.ALERT_SETTINGS['webhook_enabled'],\n                   self.ALERT_SETTINGS['slack_enabled']]):\n            issues['warnings'].append(\"No alert mechanisms enabled\")\n        \n        # Validate SLA settings\n        if self.SLA_CONFIGURATION['critical_response_minutes'] > 60:\n            issues['recommendations'].append(\"Critical response time should be under 60 minutes\")\n        \n        # Validate performance settings\n        if self.PERFORMANCE_SETTINGS['max_worker_threads'] < 5:\n            issues['recommendations'].append(\"Consider increasing worker threads for better performance\")\n        \n        # Validate security settings\n        if not self.SECURITY_HARDENING['ssl_verification']:\n            issues['warnings'].append(\"SSL verification is disabled - security risk\")\n        \n        if not self.SECURITY_HARDENING['api_rate_limiting']:\n            issues['warnings'].append(\"API rate limiting is disabled - potential DoS risk\")\n        \n        return issues\n    \n    def export_settings(self, include_sensitive: bool = False) -> Dict[str, Any]:\n        \"\"\"Export settings for backup or sharing\"\"\"\n        settings = self.get_all_settings()\n        \n        if not include_sensitive:\n            # Remove sensitive information\n            if 'api_keys' in settings:\n                settings['api_keys'] = {k: '***' for k in settings['api_keys']}\n            \n            if 'security_hardening' in settings:\n                sensitive_keys = ['encryption_key', 'jwt_secret']\n                for key in sensitive_keys:\n                    if key in settings['security_hardening']:\n                        settings['security_hardening'][key] = '***'\n        \n        return {\n            'system_name': self.SYSTEM_NAME,\n            'version': self.VERSION,\n            'export_date': str(datetime.now()),\n            'settings': settings\n        }\n    \n    def get_security_policy_template(self) -> Dict[str, Any]:\n        \"\"\"Get a template for security policies\"\"\"\n        return {\n            'password_policy': {\n                'min_length': 12,\n                'require_uppercase': True,\n                'require_lowercase': True,\n                'require_numbers': True,\n                'require_special_chars': True,\n                'max_age_days': 90,\n                'prevent_reuse_count': 5\n            },\n            'access_control': {\n                'principle_of_least_privilege': True,\n                'regular_access_reviews': True,\n                'multi_factor_authentication': True,\n                'session_timeout_minutes': 60,\n                'account_lockout_threshold': 5\n            },\n            'data_protection': {\n                'encryption_at_rest': True,\n                'encryption_in_transit': True,\n                'data_classification': True,\n                'data_retention_policy': True,\n                'secure_deletion': True\n            },\n            'incident_response': {\n                'incident_classification': True,\n                'escalation_procedures': True,\n                'communication_plan': True,\n                'forensics_preservation': True,\n                'lessons_learned_review': True\n            },\n            'vulnerability_management': {\n                'regular_scanning': True,\n                'patch_management': True,\n                'risk_assessment': True,\n                'remediation_timeline': True,\n                'exception_handling': True\n            }\n        }\n\n# Global settings instance\nsettings = SecuritySettings()\n\n# Helper functions for common setting operations\ndef get_threat_sensitivity() -> float:\n    \"\"\"Get current threat detection sensitivity\"\"\"\n    return settings.THREAT_DETECTION['global_sensitivity']\n\ndef get_alert_recipients() -> List[str]:\n    \"\"\"Get list of alert email recipients\"\"\"\n    return settings.ALERT_SETTINGS['email_recipients']\n\ndef is_auto_quarantine_enabled() -> bool:\n    \"\"\"Check if auto-quarantine is enabled\"\"\"\n    return settings.THREAT_DETECTION['auto_quarantine']\n\ndef get_api_key(service: str) -> str:\n    \"\"\"Get API key for specific service\"\"\"\n    return settings.API_KEYS.get(service, \"\")\n\ndef get_sla_response_time(severity: str) -> timedelta:\n    \"\"\"Get SLA response time for severity level\"\"\"\n    sla_map = {\n        'critical': timedelta(minutes=settings.SLA_CONFIGURATION['critical_response_minutes']),\n        'high': timedelta(hours=settings.SLA_CONFIGURATION['high_response_hours']),\n        'medium': timedelta(hours=settings.SLA_CONFIGURATION['medium_response_hours']),\n        'low': timedelta(hours=settings.SLA_CONFIGURATION['low_response_hours'])\n    }\n    return sla_map.get(severity.lower(), timedelta(hours=24))\n\ndef is_feature_enabled(category: str, feature: str) -> bool:\n    \"\"\"Check if a specific feature is enabled\"\"\"\n    category_settings = getattr(settings, category.upper(), {})\n    return category_settings.get(feature, False)\n","size_bytes":18824},"core/ai_models.py":{"content":"import numpy as np\nimport pandas as pd\nfrom sklearn.ensemble import RandomForestClassifier, IsolationForest\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import classification_report, accuracy_score\nfrom sklearn.preprocessing import StandardScaler\nimport joblib\nimport random\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Tuple\nimport hashlib\n\nclass AIThreatAnalyzer:\n    \"\"\"AI-powered threat analysis using multiple machine learning models\"\"\"\n    \n    def __init__(self):\n        self.models = {}\n        self.scaler = StandardScaler()\n        self.sensitivity = 0.7\n        self.monitored_threats = []\n        self.model_stats = {\n            'accuracy': 0.94,\n            'false_positive_rate': 0.06,\n            'last_trained': '2024-08-20'\n        }\n        self._initialize_models()\n    \n    def _initialize_models(self):\n        \"\"\"Initialize and train AI models\"\"\"\n        # Random Forest for classification\n        self.models['random_forest'] = RandomForestClassifier(\n            n_estimators=100,\n            max_depth=10,\n            random_state=42\n        )\n        \n        # Isolation Forest for anomaly detection\n        self.models['isolation_forest'] = IsolationForest(\n            contamination=0.1,\n            random_state=42\n        )\n        \n        # Train with synthetic data for demo\n        self._train_models()\n    \n    def _train_models(self):\n        \"\"\"Train models with synthetic threat data\"\"\"\n        # Generate synthetic training data\n        X_train, y_train = self._generate_training_data()\n        \n        # Train Random Forest\n        self.models['random_forest'].fit(X_train, y_train)\n        \n        # Train Isolation Forest (unsupervised)\n        self.models['isolation_forest'].fit(X_train)\n        \n        # Fit scaler\n        self.scaler.fit(X_train)\n    \n    def _generate_training_data(self) -> Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Generate synthetic training data for threat detection\"\"\"\n        np.random.seed(42)\n        \n        # Features: [packet_size, connection_count, cpu_usage, memory_usage, \n        #           file_operations, network_connections, process_count, login_attempts]\n        \n        # Normal traffic patterns\n        normal_samples = 1000\n        normal_data = np.random.normal(loc=[1024, 50, 30, 40, 10, 5, 20, 1], \n                                     scale=[200, 10, 10, 15, 3, 2, 5, 1], \n                                     size=(normal_samples, 8))\n        normal_labels = np.zeros(normal_samples)\n        \n        # Malicious traffic patterns\n        malicious_samples = 200\n        \n        # DDoS attacks - high packet count, connections\n        ddos_data = np.random.normal(loc=[512, 500, 80, 60, 5, 100, 15, 1],\n                                   scale=[100, 100, 20, 20, 2, 20, 3, 1],\n                                   size=(malicious_samples//4, 8))\n        \n        # Malware - high CPU, memory, file operations\n        malware_data = np.random.normal(loc=[2048, 30, 90, 85, 100, 10, 50, 1],\n                                      scale=[500, 5, 10, 15, 20, 3, 10, 1],\n                                      size=(malicious_samples//4, 8))\n        \n        # Brute force - high login attempts\n        bruteforce_data = np.random.normal(loc=[1024, 20, 25, 30, 5, 3, 15, 50],\n                                         scale=[200, 5, 5, 10, 2, 1, 3, 20],\n                                         size=(malicious_samples//4, 8))\n        \n        # Data exfiltration - large packets, high network activity\n        exfiltration_data = np.random.normal(loc=[8192, 100, 50, 70, 200, 50, 25, 2],\n                                           scale=[2000, 20, 15, 20, 50, 15, 5, 1],\n                                           size=(malicious_samples//4, 8))\n        \n        # Combine malicious data\n        malicious_data = np.vstack([ddos_data, malware_data, bruteforce_data, exfiltration_data])\n        malicious_labels = np.ones(malicious_samples)\n        \n        # Combine all data\n        X = np.vstack([normal_data, malicious_data])\n        y = np.hstack([normal_labels, malicious_labels])\n        \n        # Ensure non-negative values\n        X = np.abs(X)\n        \n        return X, y\n    \n    def analyze_real_time(self) -> List[Dict[str, Any]]:\n        \"\"\"Analyze real-time data for threats\"\"\"\n        # Simulate real-time data\n        current_data = self._generate_current_data()\n        \n        threats = []\n        \n        for data_point in current_data:\n            # Extract features\n            features = self._extract_features(data_point)\n            \n            # Predict using ensemble of models\n            threat_prediction = self._predict_threat(features)\n            \n            if threat_prediction['is_threat']:\n                threat = {\n                    'type': threat_prediction['threat_type'],\n                    'confidence': threat_prediction['confidence'],\n                    'target': data_point.get('target', 'Unknown'),\n                    'description': self._generate_threat_description(threat_prediction),\n                    'action': self._get_recommended_action(threat_prediction),\n                    'timestamp': datetime.now(),\n                    'features': features.tolist()\n                }\n                threats.append(threat)\n        \n        return threats\n    \n    def _generate_current_data(self) -> List[Dict[str, Any]]:\n        \"\"\"Generate simulated current system data\"\"\"\n        data_points = []\n        \n        # Simulate different types of current activity\n        activity_types = ['normal', 'suspicious', 'malicious']\n        \n        for _ in range(random.randint(1, 5)):\n            activity_type = random.choices(activity_types, weights=[0.7, 0.2, 0.1])[0]\n            \n            if activity_type == 'normal':\n                data_point = {\n                    'packet_size': random.randint(500, 1500),\n                    'connection_count': random.randint(10, 100),\n                    'cpu_usage': random.randint(10, 50),\n                    'memory_usage': random.randint(20, 60),\n                    'file_operations': random.randint(5, 20),\n                    'network_connections': random.randint(1, 10),\n                    'process_count': random.randint(15, 30),\n                    'login_attempts': random.randint(0, 3),\n                    'target': f'server-{random.randint(1, 10)}'\n                }\n            elif activity_type == 'suspicious':\n                data_point = {\n                    'packet_size': random.randint(1000, 3000),\n                    'connection_count': random.randint(80, 200),\n                    'cpu_usage': random.randint(60, 80),\n                    'memory_usage': random.randint(70, 90),\n                    'file_operations': random.randint(30, 60),\n                    'network_connections': random.randint(15, 30),\n                    'process_count': random.randint(25, 40),\n                    'login_attempts': random.randint(5, 15),\n                    'target': f'workstation-{random.randint(1, 50)}'\n                }\n            else:  # malicious\n                data_point = {\n                    'packet_size': random.randint(500, 10000),\n                    'connection_count': random.randint(200, 1000),\n                    'cpu_usage': random.randint(80, 100),\n                    'memory_usage': random.randint(85, 100),\n                    'file_operations': random.randint(80, 200),\n                    'network_connections': random.randint(40, 100),\n                    'process_count': random.randint(40, 80),\n                    'login_attempts': random.randint(20, 100),\n                    'target': f'server-{random.randint(1, 10)}'\n                }\n            \n            data_points.append(data_point)\n        \n        return data_points\n    \n    def _extract_features(self, data_point: Dict[str, Any]) -> np.ndarray:\n        \"\"\"Extract numerical features from data point\"\"\"\n        features = [\n            data_point.get('packet_size', 0),\n            data_point.get('connection_count', 0),\n            data_point.get('cpu_usage', 0),\n            data_point.get('memory_usage', 0),\n            data_point.get('file_operations', 0),\n            data_point.get('network_connections', 0),\n            data_point.get('process_count', 0),\n            data_point.get('login_attempts', 0)\n        ]\n        \n        return np.array(features).reshape(1, -1)\n    \n    def _predict_threat(self, features: np.ndarray) -> Dict[str, Any]:\n        \"\"\"Predict threat using ensemble of models\"\"\"\n        # Scale features\n        features_scaled = self.scaler.transform(features)\n        \n        # Random Forest prediction\n        rf_prediction = self.models['random_forest'].predict(features_scaled)[0]\n        rf_proba = self.models['random_forest'].predict_proba(features_scaled)[0]\n        \n        # Isolation Forest prediction (anomaly detection)\n        iso_prediction = self.models['isolation_forest'].predict(features_scaled)[0]\n        iso_score = self.models['isolation_forest'].decision_function(features_scaled)[0]\n        \n        # Ensemble decision\n        rf_confidence = max(rf_proba)\n        iso_anomaly = iso_prediction == -1\n        \n        # Combine predictions\n        is_threat = (rf_prediction == 1 and rf_confidence > self.sensitivity) or iso_anomaly\n        \n        # Determine threat type based on feature patterns\n        threat_type = self._classify_threat_type(features[0])\n        \n        # Calculate overall confidence\n        confidence = self._calculate_ensemble_confidence(rf_confidence, iso_score, is_threat)\n        \n        return {\n            'is_threat': is_threat,\n            'threat_type': threat_type,\n            'confidence': confidence,\n            'rf_prediction': rf_prediction,\n            'rf_confidence': rf_confidence,\n            'iso_anomaly': iso_anomaly,\n            'iso_score': iso_score\n        }\n    \n    def _classify_threat_type(self, features: np.ndarray) -> str:\n        \"\"\"Classify specific threat type based on feature patterns\"\"\"\n        packet_size, conn_count, cpu, memory, file_ops, net_conns, processes, logins = features\n        \n        # DDoS characteristics\n        if conn_count > 300 and net_conns > 50:\n            return \"DDoS Attack\"\n        \n        # Brute force characteristics\n        elif logins > 20:\n            return \"Brute Force Attack\"\n        \n        # Malware characteristics\n        elif cpu > 85 and memory > 80 and file_ops > 50:\n            return \"Malware Activity\"\n        \n        # Data exfiltration characteristics\n        elif packet_size > 5000 and net_conns > 30:\n            return \"Data Exfiltration\"\n        \n        # Ransomware characteristics\n        elif file_ops > 80 and cpu > 70:\n            return \"Ransomware Activity\"\n        \n        # Default\n        else:\n            return \"Suspicious Activity\"\n    \n    def _calculate_ensemble_confidence(self, rf_confidence: float, iso_score: float, is_threat: bool) -> float:\n        \"\"\"Calculate ensemble confidence score\"\"\"\n        if not is_threat:\n            return 0.0\n        \n        # Normalize isolation forest score to 0-1 range\n        normalized_iso_score = max(0, min(1, (iso_score + 0.5) / 1.0))\n        \n        # Weighted ensemble\n        ensemble_confidence = 0.7 * rf_confidence + 0.3 * normalized_iso_score\n        \n        return min(1.0, ensemble_confidence)\n    \n    def _generate_threat_description(self, prediction: Dict[str, Any]) -> str:\n        \"\"\"Generate human-readable threat description\"\"\"\n        threat_type = prediction['threat_type']\n        confidence = prediction['confidence']\n        \n        descriptions = {\n            \"DDoS Attack\": f\"Distributed Denial of Service attack detected with {confidence:.1%} confidence. High connection volume indicates attempt to overwhelm system resources.\",\n            \"Brute Force Attack\": f\"Brute force authentication attack detected with {confidence:.1%} confidence. Excessive login attempts suggest credential compromise attempt.\",\n            \"Malware Activity\": f\"Malicious software activity detected with {confidence:.1%} confidence. High resource usage patterns consistent with malware execution.\",\n            \"Data Exfiltration\": f\"Data exfiltration attempt detected with {confidence:.1%} confidence. Large data transfers suggest unauthorized information theft.\",\n            \"Ransomware Activity\": f\"Ransomware activity detected with {confidence:.1%} confidence. File system modifications consistent with encryption malware.\",\n            \"Suspicious Activity\": f\"Suspicious system behavior detected with {confidence:.1%} confidence. Activity patterns deviate from normal baseline.\"\n        }\n        \n        return descriptions.get(threat_type, f\"Unknown threat type detected with {confidence:.1%} confidence.\")\n    \n    def _get_recommended_action(self, prediction: Dict[str, Any]) -> str:\n        \"\"\"Get recommended action for detected threat\"\"\"\n        threat_type = prediction['threat_type']\n        confidence = prediction['confidence']\n        \n        if confidence > 0.9:\n            severity = \"immediate\"\n        elif confidence > 0.7:\n            severity = \"urgent\"\n        else:\n            severity = \"normal\"\n        \n        actions = {\n            \"DDoS Attack\": {\n                \"immediate\": \"Activate DDoS mitigation, rate limit connections\",\n                \"urgent\": \"Monitor traffic patterns, prepare mitigation\",\n                \"normal\": \"Analyze traffic and increase monitoring\"\n            },\n            \"Brute Force Attack\": {\n                \"immediate\": \"Block source IP, force password reset\",\n                \"urgent\": \"Increase account lockout thresholds\",\n                \"normal\": \"Monitor authentication logs\"\n            },\n            \"Malware Activity\": {\n                \"immediate\": \"Isolate system, run full antivirus scan\",\n                \"urgent\": \"Quarantine suspicious processes\",\n                \"normal\": \"Increase endpoint monitoring\"\n            },\n            \"Data Exfiltration\": {\n                \"immediate\": \"Block external connections, investigate data flows\",\n                \"urgent\": \"Monitor network traffic for anomalies\",\n                \"normal\": \"Review data access patterns\"\n            },\n            \"Ransomware Activity\": {\n                \"immediate\": \"Isolate system, restore from clean backups\",\n                \"urgent\": \"Terminate suspicious processes\",\n                \"normal\": \"Verify backup integrity\"\n            }\n        }\n        \n        return actions.get(threat_type, {}).get(severity, \"Monitor and investigate\")\n    \n    def set_sensitivity(self, sensitivity: float):\n        \"\"\"Set detection sensitivity threshold\"\"\"\n        self.sensitivity = max(0.1, min(1.0, sensitivity))\n    \n    def set_monitored_threats(self, threats: List[str]):\n        \"\"\"Set list of monitored threat types\"\"\"\n        self.monitored_threats = threats\n    \n    def get_attack_vectors(self) -> Dict[str, int]:\n        \"\"\"Get distribution of attack vectors from recent detections\"\"\"\n        # Simulate attack vector data\n        return {\n            'Network-based': 45,\n            'Endpoint-based': 32,\n            'Email-based': 18,\n            'Web-based': 23,\n            'Physical': 5,\n            'Social Engineering': 12\n        }\n    \n    def get_confidence_distribution(self) -> List[float]:\n        \"\"\"Get distribution of confidence scores\"\"\"\n        # Simulate confidence distribution\n        return [random.uniform(0.6, 1.0) for _ in range(100)]\n    \n    def get_model_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get AI model performance statistics\"\"\"\n        return self.model_stats\n    \n    def retrain_models(self):\n        \"\"\"Retrain AI models with updated data\"\"\"\n        # Simulate model retraining\n        self.model_stats['last_trained'] = datetime.now().strftime('%Y-%m-%d')\n        self.model_stats['accuracy'] = random.uniform(0.92, 0.97)\n        self.model_stats['false_positive_rate'] = random.uniform(0.03, 0.08)\n    \n    def update_model_config(self, selected_models: List[str], ensemble_weight: float, confidence_threshold: float):\n        \"\"\"Update model configuration\"\"\"\n        self.sensitivity = confidence_threshold\n        # Additional model configuration logic would go here\n    \n    def get_threat_predictions(self) -> Dict[str, Any]:\n        \"\"\"Get predictive threat analysis\"\"\"\n        # Simulate threat predictions\n        base_date = datetime.now()\n        dates = [(base_date + timedelta(days=i)).strftime('%Y-%m-%d') for i in range(7)]\n        \n        # Generate predicted threat volumes\n        predicted_threats = [random.randint(15, 45) for _ in range(7)]\n        \n        # High-risk periods\n        high_risk_periods = [\n            {\n                'date': dates[2],\n                'risk_level': 'High',\n                'confidence': 0.78\n            },\n            {\n                'date': dates[5],\n                'risk_level': 'Medium',\n                'confidence': 0.65\n            }\n        ]\n        \n        return {\n            'dates': dates,\n            'predicted_threats': predicted_threats,\n            'high_risk_periods': high_risk_periods\n        }\n","size_bytes":17232},"core/alert_manager.py":{"content":"import json\nimport uuid\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional\nfrom enum import Enum\nimport hashlib\n\nclass AlertSeverity(Enum):\n    CRITICAL = \"Critical\"\n    HIGH = \"High\"\n    MEDIUM = \"Medium\"\n    LOW = \"Low\"\n\nclass AlertStatus(Enum):\n    OPEN = \"Open\"\n    IN_PROGRESS = \"In Progress\"\n    RESOLVED = \"Resolved\"\n    FALSE_POSITIVE = \"False Positive\"\n    CLOSED = \"Closed\"\n\nclass AlertManager:\n    \"\"\"Advanced alert management system with incident response capabilities\"\"\"\n    \n    def __init__(self):\n        self.alerts = []\n        self.alert_history = []\n        self.false_positive_feedback = []\n        self.escalation_rules = self._initialize_escalation_rules()\n        self.notification_settings = self._initialize_notification_settings()\n        self.sla_timers = {}\n        \n    def _initialize_escalation_rules(self) -> List[Dict[str, Any]]:\n        \"\"\"Initialize alert escalation rules\"\"\"\n        return [\n            {\n                'severity': AlertSeverity.CRITICAL.value,\n                'escalation_time': timedelta(minutes=15),\n                'escalate_to': ['security_team_lead', 'ciso'],\n                'auto_actions': ['isolate_system', 'block_ip', 'notify_soc']\n            },\n            {\n                'severity': AlertSeverity.HIGH.value,\n                'escalation_time': timedelta(hours=1),\n                'escalate_to': ['security_analyst_l2'],\n                'auto_actions': ['create_ticket', 'notify_analyst']\n            },\n            {\n                'severity': AlertSeverity.MEDIUM.value,\n                'escalation_time': timedelta(hours=4),\n                'escalate_to': ['security_analyst_l1'],\n                'auto_actions': ['queue_for_review']\n            },\n            {\n                'severity': AlertSeverity.LOW.value,\n                'escalation_time': timedelta(hours=24),\n                'escalate_to': ['junior_analyst'],\n                'auto_actions': ['log_for_trending']\n            }\n        ]\n    \n    def _initialize_notification_settings(self) -> Dict[str, Any]:\n        \"\"\"Initialize notification settings\"\"\"\n        return {\n            'email_enabled': True,\n            'sms_enabled': False,\n            'webhook_enabled': True,\n            'slack_enabled': False,\n            'email_recipients': ['security-team@company.com'],\n            'webhook_url': 'https://webhook.company.com/security-alerts',\n            'notification_throttle': timedelta(minutes=5)\n        }\n    \n    def create_alert(self, \n                    title: str,\n                    description: str,\n                    severity: str,\n                    source: str,\n                    asset: str,\n                    indicators: List[str] = None,\n                    confidence: float = 1.0,\n                    threat_type: str = \"Unknown\") -> Dict[str, Any]:\n        \"\"\"Create a new security alert\"\"\"\n        \n        alert_id = str(uuid.uuid4())\n        current_time = datetime.now()\n        \n        alert = {\n            'id': alert_id,\n            'title': title,\n            'description': description,\n            'severity': severity,\n            'status': AlertStatus.OPEN.value,\n            'source': source,\n            'asset': asset,\n            'threat_type': threat_type,\n            'confidence': confidence,\n            'indicators': indicators or [],\n            'timestamp': current_time,\n            'created_by': 'AI_Detection_Engine',\n            'assigned_to': None,\n            'investigation_notes': [],\n            'tags': [],\n            'related_alerts': [],\n            'evidence': [],\n            'remediation_actions': [],\n            'false_positive_score': 0.0,\n            'updated_at': current_time,\n            'escalation_level': 0,\n            'sla_breach_time': self._calculate_sla_breach_time(severity),\n            'closure_reason': None,\n            'metrics': {\n                'detection_time': current_time,\n                'first_response_time': None,\n                'resolution_time': None,\n                'escalation_count': 0\n            }\n        }\n        \n        # Add contextual information\n        alert['context'] = self._gather_alert_context(source, asset, threat_type)\n        \n        # Calculate risk score\n        alert['risk_score'] = self._calculate_risk_score(severity, confidence, threat_type, asset)\n        \n        # Set priority based on risk score and business impact\n        alert['priority'] = self._calculate_priority(alert['risk_score'], asset)\n        \n        # Add to active alerts\n        self.alerts.append(alert)\n        \n        # Trigger automatic actions based on severity\n        self._trigger_auto_actions(alert)\n        \n        # Send notifications\n        self._send_alert_notifications(alert)\n        \n        # Start SLA timer\n        self._start_sla_timer(alert_id, severity)\n        \n        return alert\n    \n    def _gather_alert_context(self, source: str, asset: str, threat_type: str) -> Dict[str, Any]:\n        \"\"\"Gather contextual information for the alert\"\"\"\n        return {\n            'environment': self._determine_environment(source),\n            'asset_criticality': self._get_asset_criticality(asset),\n            'threat_intelligence': self._get_threat_intelligence(threat_type),\n            'similar_alerts_24h': self._count_similar_alerts(source, threat_type),\n            'asset_vulnerability_score': self._get_asset_vulnerability_score(asset),\n            'business_hours': self._is_business_hours(),\n            'geographic_location': self._get_asset_location(asset)\n        }\n    \n    def _calculate_risk_score(self, severity: str, confidence: float, threat_type: str, asset: str) -> float:\n        \"\"\"Calculate risk score for the alert\"\"\"\n        base_scores = {\n            AlertSeverity.CRITICAL.value: 10.0,\n            AlertSeverity.HIGH.value: 7.5,\n            AlertSeverity.MEDIUM.value: 5.0,\n            AlertSeverity.LOW.value: 2.5\n        }\n        \n        base_score = base_scores.get(severity, 5.0)\n        \n        # Adjust for confidence\n        confidence_adjusted = base_score * confidence\n        \n        # Adjust for threat type criticality\n        threat_multipliers = {\n            'Ransomware': 1.5,\n            'Data Exfiltration': 1.4,\n            'APT': 1.3,\n            'Zero-Day Exploit': 1.6,\n            'Insider Threat': 1.2,\n            'Malware': 1.1,\n            'Phishing': 1.0,\n            'Network Intrusion': 1.1\n        }\n        \n        threat_multiplier = threat_multipliers.get(threat_type, 1.0)\n        \n        # Adjust for asset criticality\n        asset_criticality = self._get_asset_criticality(asset)\n        asset_multipliers = {\n            'Critical': 1.3,\n            'High': 1.2,\n            'Medium': 1.0,\n            'Low': 0.8\n        }\n        \n        asset_multiplier = asset_multipliers.get(asset_criticality, 1.0)\n        \n        final_score = min(10.0, confidence_adjusted * threat_multiplier * asset_multiplier)\n        \n        return round(final_score, 2)\n    \n    def _calculate_priority(self, risk_score: float, asset: str) -> str:\n        \"\"\"Calculate alert priority\"\"\"\n        if risk_score >= 8.0:\n            return \"P1 - Critical\"\n        elif risk_score >= 6.0:\n            return \"P2 - High\"\n        elif risk_score >= 4.0:\n            return \"P3 - Medium\"\n        else:\n            return \"P4 - Low\"\n    \n    def _trigger_auto_actions(self, alert: Dict[str, Any]):\n        \"\"\"Trigger automatic response actions based on alert\"\"\"\n        severity = alert['severity']\n        threat_type = alert['threat_type']\n        \n        # Find applicable escalation rule\n        rule = next((r for r in self.escalation_rules if r['severity'] == severity), None)\n        \n        if rule:\n            for action in rule['auto_actions']:\n                self._execute_auto_action(alert, action)\n    \n    def _execute_auto_action(self, alert: Dict[str, Any], action: str):\n        \"\"\"Execute automatic response action\"\"\"\n        action_results = {\n            'action': action,\n            'timestamp': datetime.now(),\n            'status': 'executed',\n            'details': ''\n        }\n        \n        if action == 'isolate_system':\n            # Logic to isolate the affected system\n            action_results['details'] = f\"System {alert['asset']} marked for isolation\"\n            \n        elif action == 'block_ip':\n            # Logic to block malicious IPs from indicators\n            blocked_ips = [ioc for ioc in alert['indicators'] if self._is_ip_address(ioc)]\n            action_results['details'] = f\"Blocked {len(blocked_ips)} IP addresses\"\n            \n        elif action == 'notify_soc':\n            # Logic to notify SOC team\n            action_results['details'] = \"SOC team notified via priority channels\"\n            \n        elif action == 'create_ticket':\n            # Logic to create incident ticket\n            ticket_id = f\"INC-{datetime.now().strftime('%Y%m%d')}-{alert['id'][:8]}\"\n            action_results['details'] = f\"Incident ticket {ticket_id} created\"\n            \n        # Add action to alert's remediation actions\n        alert['remediation_actions'].append(action_results)\n    \n    def update_alert(self, alert_id: str, updates: Dict[str, Any]) -> bool:\n        \"\"\"Update existing alert\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        # Update fields\n        for key, value in updates.items():\n            if key in alert:\n                alert[key] = value\n        \n        alert['updated_at'] = datetime.now()\n        \n        # Handle status changes\n        if 'status' in updates:\n            self._handle_status_change(alert, updates['status'])\n        \n        return True\n    \n    def assign_alert(self, alert_id: str, assignee: str) -> bool:\n        \"\"\"Assign alert to analyst\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        alert['assigned_to'] = assignee\n        alert['updated_at'] = datetime.now()\n        \n        if not alert['metrics']['first_response_time']:\n            alert['metrics']['first_response_time'] = datetime.now()\n        \n        return True\n    \n    def add_investigation_note(self, alert_id: str, note: str, analyst: str) -> bool:\n        \"\"\"Add investigation note to alert\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        investigation_note = {\n            'timestamp': datetime.now(),\n            'analyst': analyst,\n            'note': note,\n            'id': str(uuid.uuid4())[:8]\n        }\n        \n        alert['investigation_notes'].append(investigation_note)\n        alert['updated_at'] = datetime.now()\n        \n        return True\n    \n    def escalate_alert(self, alert_id: str, reason: str = \"SLA breach\") -> bool:\n        \"\"\"Escalate alert to next level\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        alert['escalation_level'] += 1\n        alert['metrics']['escalation_count'] += 1\n        alert['updated_at'] = datetime.now()\n        \n        # Find escalation rule\n        rule = next((r for r in self.escalation_rules if r['severity'] == alert['severity']), None)\n        \n        if rule and 'escalate_to' in rule:\n            escalate_to = rule['escalate_to']\n            if alert['escalation_level'] <= len(escalate_to):\n                alert['assigned_to'] = escalate_to[alert['escalation_level'] - 1]\n        \n        # Add escalation note\n        escalation_note = {\n            'timestamp': datetime.now(),\n            'reason': reason,\n            'escalated_to': alert['assigned_to'],\n            'level': alert['escalation_level']\n        }\n        \n        alert['investigation_notes'].append({\n            'timestamp': datetime.now(),\n            'analyst': 'System',\n            'note': f\"Alert escalated to level {alert['escalation_level']}: {reason}\",\n            'id': str(uuid.uuid4())[:8]\n        })\n        \n        return True\n    \n    def mark_false_positive(self, alert_id: str, reason: str = \"\", analyst: str = \"Unknown\") -> bool:\n        \"\"\"Mark alert as false positive\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        alert['status'] = AlertStatus.FALSE_POSITIVE.value\n        alert['closure_reason'] = reason or \"Determined to be false positive\"\n        alert['metrics']['resolution_time'] = datetime.now()\n        alert['updated_at'] = datetime.now()\n        \n        # Record false positive feedback for ML improvement\n        fp_feedback = {\n            'alert_id': alert_id,\n            'timestamp': datetime.now(),\n            'analyst': analyst,\n            'reason': reason,\n            'alert_features': {\n                'severity': alert['severity'],\n                'threat_type': alert['threat_type'],\n                'confidence': alert['confidence'],\n                'source': alert['source'],\n                'indicators': alert['indicators']\n            }\n        }\n        \n        self.false_positive_feedback.append(fp_feedback)\n        \n        # Update false positive score for similar alerts\n        self._update_false_positive_scores(alert)\n        \n        return True\n    \n    def resolve_alert(self, alert_id: str, resolution: str, analyst: str = \"Unknown\") -> bool:\n        \"\"\"Resolve alert\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        alert['status'] = AlertStatus.RESOLVED.value\n        alert['closure_reason'] = resolution\n        alert['metrics']['resolution_time'] = datetime.now()\n        alert['updated_at'] = datetime.now()\n        \n        # Add resolution note\n        alert['investigation_notes'].append({\n            'timestamp': datetime.now(),\n            'analyst': analyst,\n            'note': f\"Alert resolved: {resolution}\",\n            'id': str(uuid.uuid4())[:8]\n        })\n        \n        # Stop SLA timer\n        if alert_id in self.sla_timers:\n            del self.sla_timers[alert_id]\n        \n        # Move to history if older than retention period\n        if alert['timestamp'] < datetime.now() - timedelta(days=30):\n            self.alert_history.append(alert)\n            self.alerts.remove(alert)\n        \n        return True\n    \n    def start_investigation(self, alert_id: str, analyst: str = \"Unknown\") -> bool:\n        \"\"\"Start investigation on alert\"\"\"\n        alert = self._find_alert_by_id(alert_id)\n        \n        if not alert:\n            return False\n        \n        alert['status'] = AlertStatus.IN_PROGRESS.value\n        alert['assigned_to'] = analyst\n        alert['updated_at'] = datetime.now()\n        \n        if not alert['metrics']['first_response_time']:\n            alert['metrics']['first_response_time'] = datetime.now()\n        \n        # Add investigation start note\n        alert['investigation_notes'].append({\n            'timestamp': datetime.now(),\n            'analyst': analyst,\n            'note': \"Investigation started\",\n            'id': str(uuid.uuid4())[:8]\n        })\n        \n        return True\n    \n    def get_filtered_alerts(self, \n                          severity: str = \"All\",\n                          status: str = \"All\", \n                          time_range: str = \"Last 24h\",\n                          environment: str = \"All\") -> List[Dict[str, Any]]:\n        \"\"\"Get filtered list of alerts\"\"\"\n        filtered_alerts = self.alerts.copy()\n        \n        # Filter by severity\n        if severity != \"All\":\n            filtered_alerts = [a for a in filtered_alerts if a['severity'] == severity]\n        \n        # Filter by status\n        if status != \"All\":\n            filtered_alerts = [a for a in filtered_alerts if a['status'] == status]\n        \n        # Filter by time range\n        if time_range != \"All\":\n            cutoff_time = self._get_time_cutoff(time_range)\n            filtered_alerts = [a for a in filtered_alerts if a['timestamp'] > cutoff_time]\n        \n        # Filter by environment\n        if environment != \"All\":\n            filtered_alerts = [a for a in filtered_alerts if a.get('context', {}).get('environment') == environment]\n        \n        # Sort by timestamp (newest first)\n        filtered_alerts.sort(key=lambda x: x['timestamp'], reverse=True)\n        \n        return filtered_alerts\n    \n    def get_alerts_count(self) -> Dict[str, int]:\n        \"\"\"Get count of alerts by status and severity\"\"\"\n        counts = {\n            'total': len(self.alerts),\n            'open': len([a for a in self.alerts if a['status'] == AlertStatus.OPEN.value]),\n            'in_progress': len([a for a in self.alerts if a['status'] == AlertStatus.IN_PROGRESS.value]),\n            'resolved': len([a for a in self.alerts if a['status'] == AlertStatus.RESOLVED.value]),\n            'critical': len([a for a in self.alerts if a['severity'] == AlertSeverity.CRITICAL.value]),\n            'high': len([a for a in self.alerts if a['severity'] == AlertSeverity.HIGH.value]),\n            'medium': len([a for a in self.alerts if a['severity'] == AlertSeverity.MEDIUM.value]),\n            'low': len([a for a in self.alerts if a['severity'] == AlertSeverity.LOW.value]),\n            'new_critical': len([a for a in self.alerts if a['severity'] == AlertSeverity.CRITICAL.value and a['timestamp'] > datetime.now() - timedelta(hours=1)])\n        }\n        \n        return counts\n    \n    def get_alerts_timeline(self) -> Dict[str, Any]:\n        \"\"\"Get alerts timeline data for visualization\"\"\"\n        # Get last 24 hours of alerts\n        cutoff_time = datetime.now() - timedelta(hours=24)\n        recent_alerts = [a for a in self.alerts if a['timestamp'] > cutoff_time]\n        \n        if not recent_alerts:\n            return {'timestamps': [], 'counts': []}\n        \n        # Group by hour\n        hourly_counts = {}\n        for alert in recent_alerts:\n            hour_key = alert['timestamp'].replace(minute=0, second=0, microsecond=0)\n            hourly_counts[hour_key] = hourly_counts.get(hour_key, 0) + 1\n        \n        # Fill in missing hours with 0\n        current_hour = datetime.now().replace(minute=0, second=0, microsecond=0)\n        timestamps = []\n        counts = []\n        \n        for i in range(24):\n            hour = current_hour - timedelta(hours=i)\n            timestamps.append(hour)\n            counts.append(hourly_counts.get(hour, 0))\n        \n        timestamps.reverse()\n        counts.reverse()\n        \n        return {\n            'timestamps': timestamps,\n            'counts': counts\n        }\n    \n    def get_false_positive_rate(self) -> float:\n        \"\"\"Calculate false positive rate\"\"\"\n        total_alerts = len(self.alerts) + len(self.alert_history)\n        \n        if total_alerts == 0:\n            return 0.0\n        \n        false_positives = len([a for a in self.alerts + self.alert_history \n                             if a['status'] == AlertStatus.FALSE_POSITIVE.value])\n        \n        return false_positives / total_alerts\n    \n    def get_false_positive_trends(self) -> Dict[str, Any]:\n        \"\"\"Get false positive rate trends\"\"\"\n        # Calculate daily false positive rates for last 30 days\n        dates = []\n        rates = []\n        \n        for i in range(30):\n            date = datetime.now() - timedelta(days=i)\n            day_alerts = [a for a in self.alerts + self.alert_history \n                         if a['timestamp'].date() == date.date()]\n            \n            if day_alerts:\n                day_fp = len([a for a in day_alerts if a['status'] == AlertStatus.FALSE_POSITIVE.value])\n                fp_rate = day_fp / len(day_alerts)\n            else:\n                fp_rate = 0.0\n            \n            dates.append(date.strftime('%Y-%m-%d'))\n            rates.append(fp_rate)\n        \n        dates.reverse()\n        rates.reverse()\n        \n        return {\n            'dates': dates,\n            'rates': rates\n        }\n    \n    def get_false_positives_by_type(self) -> Dict[str, int]:\n        \"\"\"Get false positives grouped by threat type\"\"\"\n        fp_alerts = [a for a in self.alerts + self.alert_history \n                    if a['status'] == AlertStatus.FALSE_POSITIVE.value]\n        \n        fp_by_type = {}\n        for alert in fp_alerts:\n            threat_type = alert['threat_type']\n            fp_by_type[threat_type] = fp_by_type.get(threat_type, 0) + 1\n        \n        return fp_by_type\n    \n    def _find_alert_by_id(self, alert_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Find alert by ID\"\"\"\n        return next((alert for alert in self.alerts if alert['id'] == alert_id), None)\n    \n    def _handle_status_change(self, alert: Dict[str, Any], new_status: str):\n        \"\"\"Handle alert status changes\"\"\"\n        if new_status == AlertStatus.IN_PROGRESS.value and not alert['metrics']['first_response_time']:\n            alert['metrics']['first_response_time'] = datetime.now()\n        elif new_status in [AlertStatus.RESOLVED.value, AlertStatus.FALSE_POSITIVE.value]:\n            alert['metrics']['resolution_time'] = datetime.now()\n    \n    def _send_alert_notifications(self, alert: Dict[str, Any]):\n        \"\"\"Send alert notifications based on configuration\"\"\"\n        if not self._should_send_notification(alert):\n            return\n        \n        notification_payload = {\n            'alert_id': alert['id'],\n            'title': alert['title'],\n            'severity': alert['severity'],\n            'description': alert['description'],\n            'asset': alert['asset'],\n            'timestamp': alert['timestamp'].isoformat(),\n            'priority': alert['priority']\n        }\n        \n        # Email notification\n        if self.notification_settings['email_enabled']:\n            self._send_email_notification(notification_payload)\n        \n        # Webhook notification\n        if self.notification_settings['webhook_enabled']:\n            self._send_webhook_notification(notification_payload)\n    \n    def _should_send_notification(self, alert: Dict[str, Any]) -> bool:\n        \"\"\"Check if notification should be sent\"\"\"\n        # Check throttling\n        throttle_key = f\"{alert['source']}_{alert['threat_type']}\"\n        current_time = datetime.now()\n        \n        if hasattr(self, '_last_notifications'):\n            last_notification = self._last_notifications.get(throttle_key)\n            if last_notification and current_time - last_notification < self.notification_settings['notification_throttle']:\n                return False\n        else:\n            self._last_notifications = {}\n        \n        self._last_notifications[throttle_key] = current_time\n        return True\n    \n    def _send_email_notification(self, payload: Dict[str, Any]):\n        \"\"\"Send email notification (implementation would use actual email service)\"\"\"\n        # In a real implementation, this would integrate with email service\n        pass\n    \n    def _send_webhook_notification(self, payload: Dict[str, Any]):\n        \"\"\"Send webhook notification (implementation would make HTTP request)\"\"\"\n        # In a real implementation, this would make HTTP POST to webhook URL\n        pass\n    \n    def _calculate_sla_breach_time(self, severity: str) -> datetime:\n        \"\"\"Calculate when SLA would be breached\"\"\"\n        sla_times = {\n            AlertSeverity.CRITICAL.value: timedelta(minutes=15),\n            AlertSeverity.HIGH.value: timedelta(hours=2),\n            AlertSeverity.MEDIUM.value: timedelta(hours=8),\n            AlertSeverity.LOW.value: timedelta(hours=24)\n        }\n        \n        sla_time = sla_times.get(severity, timedelta(hours=24))\n        return datetime.now() + sla_time\n    \n    def _start_sla_timer(self, alert_id: str, severity: str):\n        \"\"\"Start SLA timer for alert\"\"\"\n        breach_time = self._calculate_sla_breach_time(severity)\n        self.sla_timers[alert_id] = breach_time\n    \n    def _get_time_cutoff(self, time_range: str) -> datetime:\n        \"\"\"Get cutoff time for filtering\"\"\"\n        now = datetime.now()\n        \n        if time_range == \"Last Hour\":\n            return now - timedelta(hours=1)\n        elif time_range == \"Last 24h\":\n            return now - timedelta(days=1)\n        elif time_range == \"Last 7 days\":\n            return now - timedelta(days=7)\n        elif time_range == \"Last 30 days\":\n            return now - timedelta(days=30)\n        else:\n            return now - timedelta(days=1)\n    \n    # Helper methods for context gathering\n    def _determine_environment(self, source: str) -> str:\n        \"\"\"Determine environment type from source\"\"\"\n        if 'network' in source.lower():\n            return 'Network'\n        elif 'endpoint' in source.lower():\n            return 'Endpoint'\n        elif 'cloud' in source.lower():\n            return 'Cloud'\n        elif 'iot' in source.lower():\n            return 'IoT'\n        elif 'mobile' in source.lower():\n            return 'Mobile'\n        else:\n            return 'Unknown'\n    \n    def _get_asset_criticality(self, asset: str) -> str:\n        \"\"\"Get asset criticality level\"\"\"\n        critical_assets = ['domain-controller', 'database', 'mail-server', 'web-server']\n        high_assets = ['file-server', 'backup-server', 'vpn-gateway']\n        \n        asset_lower = asset.lower()\n        \n        if any(critical in asset_lower for critical in critical_assets):\n            return 'Critical'\n        elif any(high in asset_lower for high in high_assets):\n            return 'High'\n        elif 'workstation' in asset_lower:\n            return 'Medium'\n        else:\n            return 'Low'\n    \n    def _get_threat_intelligence(self, threat_type: str) -> Dict[str, Any]:\n        \"\"\"Get threat intelligence for threat type\"\"\"\n        return {\n            'known_campaigns': [],\n            'recent_activity': False,\n            'attribution': None,\n            'severity_trend': 'stable'\n        }\n    \n    def _count_similar_alerts(self, source: str, threat_type: str) -> int:\n        \"\"\"Count similar alerts in last 24 hours\"\"\"\n        cutoff_time = datetime.now() - timedelta(hours=24)\n        similar_alerts = [\n            a for a in self.alerts \n            if a['timestamp'] > cutoff_time \n            and a['source'] == source \n            and a['threat_type'] == threat_type\n        ]\n        return len(similar_alerts)\n    \n    def _get_asset_vulnerability_score(self, asset: str) -> float:\n        \"\"\"Get vulnerability score for asset\"\"\"\n        # In real implementation, this would query vulnerability management system\n        return round(random.uniform(0.0, 10.0), 1)\n    \n    def _is_business_hours(self) -> bool:\n        \"\"\"Check if current time is business hours\"\"\"\n        now = datetime.now()\n        return 9 <= now.hour <= 17 and now.weekday() < 5\n    \n    def _get_asset_location(self, asset: str) -> str:\n        \"\"\"Get geographic location of asset\"\"\"\n        # In real implementation, this would query asset management system\n        locations = ['US-East', 'US-West', 'EU-Central', 'APAC-Singapore']\n        return random.choice(locations)\n    \n    def _is_ip_address(self, indicator: str) -> bool:\n        \"\"\"Check if indicator is an IP address\"\"\"\n        import re\n        ip_pattern = r'^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$'\n        return bool(re.match(ip_pattern, indicator))\n    \n    def _update_false_positive_scores(self, alert: Dict[str, Any]):\n        \"\"\"Update false positive scores for similar alerts\"\"\"\n        similar_alerts = [\n            a for a in self.alerts \n            if a['threat_type'] == alert['threat_type'] \n            and a['source'] == alert['source']\n            and a['id'] != alert['id']\n        ]\n        \n        for similar_alert in similar_alerts:\n            similar_alert['false_positive_score'] = min(1.0, similar_alert['false_positive_score'] + 0.1)\n\nimport random\n","size_bytes":27964},"core/log_analyzer.py":{"content":"import re\nimport json\nimport pandas as pd\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any, Optional\nimport hashlib\nimport random\n\nclass LogAnalyzer:\n    \"\"\"Advanced log analysis and digital forensics engine\"\"\"\n    \n    def __init__(self):\n        self.log_sources = {\n            'Windows Event Logs': {'path': '/var/log/windows/', 'format': 'evtx'},\n            'Linux Syslogs': {'path': '/var/log/syslog/', 'format': 'syslog'},\n            'Network Devices': {'path': '/var/log/network/', 'format': 'cisco'},\n            'Web Servers': {'path': '/var/log/apache/', 'format': 'apache'},\n            'Database Logs': {'path': '/var/log/database/', 'format': 'mysql'},\n            'Cloud Audit Logs': {'path': '/var/log/cloud/', 'format': 'json'},\n            'IoT Device Logs': {'path': '/var/log/iot/', 'format': 'custom'},\n            'Mobile Device Logs': {'path': '/var/log/mobile/', 'format': 'mobile'}\n        }\n        \n        self.log_patterns = self._initialize_log_patterns()\n        self.correlation_rules = self._initialize_correlation_rules()\n    \n    def _initialize_log_patterns(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Initialize log parsing patterns for different sources\"\"\"\n        return {\n            'failed_login': {\n                'pattern': r'authentication failure|login failed|invalid user|bad password',\n                'severity': 'Medium',\n                'category': 'Authentication'\n            },\n            'privilege_escalation': {\n                'pattern': r'sudo|su |runas|privilege|elevation',\n                'severity': 'High',\n                'category': 'Privilege Escalation'\n            },\n            'suspicious_process': {\n                'pattern': r'powershell.*-enc|cmd\\.exe.*\\/c|rundll32|regsvr32',\n                'severity': 'High',\n                'category': 'Process Execution'\n            },\n            'network_scan': {\n                'pattern': r'port scan|nmap|masscan|connect\\(\\) to .* failed',\n                'severity': 'Medium',\n                'category': 'Network Activity'\n            },\n            'file_access': {\n                'pattern': r'file access denied|permission denied|unauthorized access',\n                'severity': 'Medium',\n                'category': 'File System'\n            },\n            'malware_signature': {\n                'pattern': r'virus detected|malware|trojan|backdoor|rootkit',\n                'severity': 'Critical',\n                'category': 'Malware'\n            },\n            'data_exfiltration': {\n                'pattern': r'large file transfer|ftp upload|data export|backup to external',\n                'severity': 'High',\n                'category': 'Data Exfiltration'\n            },\n            'system_shutdown': {\n                'pattern': r'system shutdown|service stopped|process terminated',\n                'severity': 'Low',\n                'category': 'System Events'\n            }\n        }\n    \n    def _initialize_correlation_rules(self) -> List[Dict[str, Any]]:\n        \"\"\"Initialize correlation rules for cross-platform analysis\"\"\"\n        return [\n            {\n                'name': 'Coordinated Attack',\n                'description': 'Multiple failed logins followed by privilege escalation',\n                'conditions': [\n                    {'category': 'Authentication', 'count': '>= 5', 'timeframe': '5 minutes'},\n                    {'category': 'Privilege Escalation', 'count': '>= 1', 'timeframe': '10 minutes'}\n                ],\n                'severity': 'Critical',\n                'confidence': 0.9\n            },\n            {\n                'name': 'Lateral Movement',\n                'description': 'Process execution across multiple systems',\n                'conditions': [\n                    {'category': 'Process Execution', 'systems': '>= 3', 'timeframe': '30 minutes'}\n                ],\n                'severity': 'High',\n                'confidence': 0.8\n            },\n            {\n                'name': 'Data Breach Sequence',\n                'description': 'File access followed by data exfiltration',\n                'conditions': [\n                    {'category': 'File System', 'count': '>= 10', 'timeframe': '1 hour'},\n                    {'category': 'Data Exfiltration', 'count': '>= 1', 'timeframe': '2 hours'}\n                ],\n                'severity': 'Critical',\n                'confidence': 0.95\n            }\n        ]\n    \n    def analyze_logs(self, sources: List[str], time_range: str, analysis_type: str) -> Dict[str, Any]:\n        \"\"\"Analyze logs from specified sources and time range\"\"\"\n        \n        # Generate simulated log analysis results\n        analysis_results = {\n            'events': self._generate_security_events(sources, time_range),\n            'findings': [],\n            'timeline': None,\n            'raw_logs': []\n        }\n        \n        # Analyze events for security findings\n        analysis_results['findings'] = self._analyze_security_events(analysis_results['events'])\n        \n        # Create timeline\n        analysis_results['timeline'] = self._create_event_timeline(analysis_results['events'])\n        \n        # Generate raw log samples\n        analysis_results['raw_logs'] = self._generate_raw_log_samples(sources, time_range)\n        \n        return analysis_results\n    \n    def _generate_security_events(self, sources: List[str], time_range: str) -> List[Dict[str, Any]]:\n        \"\"\"Generate simulated security events from log sources\"\"\"\n        events = []\n        \n        # Determine number of events based on time range\n        event_counts = {\n            'Last Hour': random.randint(10, 50),\n            'Last 24h': random.randint(100, 500),\n            'Last 7 days': random.randint(500, 2000),\n            'Custom Range': random.randint(200, 1000)\n        }\n        \n        num_events = event_counts.get(time_range, 100)\n        \n        # Generate events for each source\n        for source in sources:\n            source_events = num_events // len(sources)\n            \n            for _ in range(source_events):\n                # Choose random pattern\n                pattern_name = random.choice(list(self.log_patterns.keys()))\n                pattern_info = self.log_patterns[pattern_name]\n                \n                event = {\n                    'id': self._generate_event_id(),\n                    'timestamp': self._generate_random_timestamp(time_range),\n                    'source': source,\n                    'pattern': pattern_name,\n                    'category': pattern_info['category'],\n                    'severity': pattern_info['severity'],\n                    'description': self._generate_event_description(pattern_name, source),\n                    'raw_log': self._generate_raw_log_entry(pattern_name, source),\n                    'ip_address': self._generate_random_ip(),\n                    'user': self._generate_random_user(),\n                    'system': self._generate_random_system()\n                }\n                \n                events.append(event)\n        \n        # Sort events by timestamp\n        events.sort(key=lambda x: x['timestamp'])\n        \n        return events\n    \n    def _analyze_security_events(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"Analyze security events to identify threats and patterns\"\"\"\n        findings = []\n        \n        # Group events by category and time\n        event_groups = {}\n        for event in events:\n            category = event['category']\n            if category not in event_groups:\n                event_groups[category] = []\n            event_groups[category].append(event)\n        \n        # Analyze each category\n        for category, category_events in event_groups.items():\n            # Check for high frequency events\n            if len(category_events) > 20:\n                finding = {\n                    'title': f'High Volume {category} Activity',\n                    'severity': 'High',\n                    'confidence': 0.8,\n                    'description': f'Detected {len(category_events)} {category.lower()} events, which exceeds normal baseline.',\n                    'event_count': len(category_events),\n                    'time_span': self._calculate_time_span(category_events),\n                    'affected_systems': list(set([e['system'] for e in category_events])),\n                    'recommendations': [\n                        f'Investigate {category.lower()} patterns',\n                        'Review affected systems for compromise',\n                        'Consider implementing additional monitoring'\n                    ]\n                }\n                findings.append(finding)\n        \n        # Check for critical severity events\n        critical_events = [e for e in events if e['severity'] == 'Critical']\n        if critical_events:\n            finding = {\n                'title': 'Critical Security Events Detected',\n                'severity': 'Critical',\n                'confidence': 0.95,\n                'description': f'Detected {len(critical_events)} critical security events requiring immediate attention.',\n                'event_count': len(critical_events),\n                'affected_systems': list(set([e['system'] for e in critical_events])),\n                'recommendations': [\n                    'Immediately investigate all critical events',\n                    'Isolate affected systems if necessary',\n                    'Activate incident response procedures'\n                ]\n            }\n            findings.append(finding)\n        \n        # Check for authentication failures\n        auth_failures = [e for e in events if e['category'] == 'Authentication']\n        if len(auth_failures) > 10:\n            # Group by user and IP\n            user_failures = {}\n            ip_failures = {}\n            \n            for event in auth_failures:\n                user = event['user']\n                ip = event['ip_address']\n                \n                user_failures[user] = user_failures.get(user, 0) + 1\n                ip_failures[ip] = ip_failures.get(ip, 0) + 1\n            \n            # Check for brute force attacks\n            suspicious_users = [user for user, count in user_failures.items() if count > 5]\n            suspicious_ips = [ip for ip, count in ip_failures.items() if count > 10]\n            \n            if suspicious_users or suspicious_ips:\n                finding = {\n                    'title': 'Potential Brute Force Attack',\n                    'severity': 'High',\n                    'confidence': 0.85,\n                    'description': f'Multiple authentication failures detected from suspicious sources.',\n                    'suspicious_users': suspicious_users,\n                    'suspicious_ips': suspicious_ips,\n                    'total_attempts': len(auth_failures),\n                    'recommendations': [\n                        'Block suspicious IP addresses',\n                        'Force password reset for targeted accounts',\n                        'Implement account lockout policies',\n                        'Enable multi-factor authentication'\n                    ]\n                }\n                findings.append(finding)\n        \n        # Sort findings by severity\n        severity_order = {'Critical': 0, 'High': 1, 'Medium': 2, 'Low': 3}\n        findings.sort(key=lambda x: severity_order.get(x['severity'], 4))\n        \n        return findings\n    \n    def _create_event_timeline(self, events: List[Dict[str, Any]]) -> Dict[str, Any]:\n        \"\"\"Create timeline visualization data\"\"\"\n        if not events:\n            return None\n        \n        timestamps = [event['timestamp'] for event in events]\n        sources = [event['source'] for event in events]\n        severities = [event['severity'] for event in events]\n        \n        return {\n            'timestamps': timestamps,\n            'sources': sources,\n            'severities': severities\n        }\n    \n    def _generate_raw_log_samples(self, sources: List[str], time_range: str) -> List[Dict[str, Any]]:\n        \"\"\"Generate sample raw log entries\"\"\"\n        raw_logs = []\n        \n        log_templates = {\n            'Windows Event Logs': [\n                'EventID 4625: An account failed to log on. Account Name: {user} Source IP: {ip}',\n                'EventID 4648: A logon was attempted using explicit credentials. Account: {user}',\n                'EventID 4720: A user account was created. Account Name: {user}'\n            ],\n            'Linux Syslogs': [\n                'sshd[1234]: Failed password for {user} from {ip} port 22 ssh2',\n                'sudo: {user} : command not allowed ; TTY=pts/0 ; PWD=/home/{user}',\n                'kernel: [12345.678] TCP: Possible SYN flooding on port 80'\n            ],\n            'Network Devices': [\n                '%SEC-6-IPACCESSLOGP: list 101 denied tcp {ip}(3389) -> 10.1.1.1(80)',\n                '%LINK-3-UPDOWN: Interface GigabitEthernet0/1, changed state to down',\n                '%SYS-5-CONFIG_I: Configured from console by {user}'\n            ],\n            'Web Servers': [\n                '{ip} - - [timestamp] \"GET /admin HTTP/1.1\" 403 512 \"-\" \"curl/7.68.0\"',\n                '{ip} - {user} [timestamp] \"POST /login HTTP/1.1\" 401 256',\n                '{ip} - - [timestamp] \"GET /../../../etc/passwd HTTP/1.1\" 404 162'\n            ]\n        }\n        \n        for source in sources:\n            if source in log_templates:\n                templates = log_templates[source]\n                \n                for _ in range(random.randint(5, 15)):\n                    template = random.choice(templates)\n                    \n                    log_entry = {\n                        'timestamp': self._generate_random_timestamp(time_range),\n                        'source': source,\n                        'message': template.format(\n                            user=self._generate_random_user(),\n                            ip=self._generate_random_ip(),\n                            system=self._generate_random_system()\n                        ),\n                        'level': random.choice(['INFO', 'WARN', 'ERROR', 'DEBUG'])\n                    }\n                    \n                    raw_logs.append(log_entry)\n        \n        # Sort by timestamp\n        raw_logs.sort(key=lambda x: x['timestamp'])\n        \n        return raw_logs\n    \n    def run_correlation_analysis(self) -> List[Dict[str, Any]]:\n        \"\"\"Run cross-platform log correlation analysis\"\"\"\n        correlations = []\n        \n        # Simulate correlation findings\n        correlation_patterns = [\n            {\n                'pattern': 'Multi-stage Attack Campaign',\n                'confidence': 0.87,\n                'systems': ['web-server-01', 'db-server-02', 'workstation-15'],\n                'timespan': '2 hours 15 minutes',\n                'description': 'Coordinated attack sequence detected across multiple systems involving initial compromise, lateral movement, and data access.',\n                'timeline': [\n                    'T+0: Web application exploit on web-server-01',\n                    'T+45m: Lateral movement to db-server-02',\n                    'T+1h30m: Database access and potential data exfiltration',\n                    'T+2h: Suspicious activity on workstation-15'\n                ]\n            },\n            {\n                'pattern': 'Credential Stuffing Campaign',\n                'confidence': 0.74,\n                'systems': ['auth-server-01', 'mail-server-01', 'vpn-gateway'],\n                'timespan': '45 minutes',\n                'description': 'Automated credential testing across multiple authentication systems from distributed source IPs.',\n                'timeline': [\n                    'T+0: Failed login attempts on auth-server-01',\n                    'T+15m: Similar patterns on mail-server-01',\n                    'T+30m: VPN brute force attempts detected'\n                ]\n            },\n            {\n                'pattern': 'Insider Threat Activity',\n                'confidence': 0.65,\n                'systems': ['file-server-03', 'backup-server-01'],\n                'timespan': '3 hours',\n                'description': 'Unusual data access patterns by privileged user outside normal business hours.',\n                'timeline': [\n                    'T+0: After-hours login by privileged user',\n                    'T+1h: Large file downloads from sensitive directories',\n                    'T+2h30m: Backup system access and data transfer'\n                ]\n            }\n        ]\n        \n        # Randomly select correlations to return\n        num_correlations = random.randint(1, len(correlation_patterns))\n        correlations = random.sample(correlation_patterns, num_correlations)\n        \n        return correlations\n    \n    def _generate_event_id(self) -> str:\n        \"\"\"Generate unique event ID\"\"\"\n        timestamp = str(datetime.now().timestamp())\n        return hashlib.md5(timestamp.encode()).hexdigest()[:8].upper()\n    \n    def _generate_random_timestamp(self, time_range: str) -> datetime:\n        \"\"\"Generate random timestamp within specified range\"\"\"\n        now = datetime.now()\n        \n        if time_range == 'Last Hour':\n            start_time = now - timedelta(hours=1)\n        elif time_range == 'Last 24h':\n            start_time = now - timedelta(days=1)\n        elif time_range == 'Last 7 days':\n            start_time = now - timedelta(days=7)\n        else:  # Custom Range or default\n            start_time = now - timedelta(days=3)\n        \n        # Generate random timestamp between start_time and now\n        time_diff = now - start_time\n        random_seconds = random.randint(0, int(time_diff.total_seconds()))\n        \n        return start_time + timedelta(seconds=random_seconds)\n    \n    def _generate_event_description(self, pattern_name: str, source: str) -> str:\n        \"\"\"Generate human-readable event description\"\"\"\n        descriptions = {\n            'failed_login': f'Authentication failure detected in {source}',\n            'privilege_escalation': f'Privilege escalation attempt detected in {source}',\n            'suspicious_process': f'Suspicious process execution detected in {source}',\n            'network_scan': f'Network scanning activity detected in {source}',\n            'file_access': f'Unauthorized file access attempt in {source}',\n            'malware_signature': f'Malware signature detected in {source}',\n            'data_exfiltration': f'Potential data exfiltration detected in {source}',\n            'system_shutdown': f'System shutdown event recorded in {source}'\n        }\n        \n        return descriptions.get(pattern_name, f'Security event detected in {source}')\n    \n    def _generate_raw_log_entry(self, pattern_name: str, source: str) -> str:\n        \"\"\"Generate realistic raw log entry\"\"\"\n        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')\n        ip = self._generate_random_ip()\n        user = self._generate_random_user()\n        \n        log_formats = {\n            'failed_login': f'{timestamp} {source}: Authentication failure for user {user} from {ip}',\n            'privilege_escalation': f'{timestamp} {source}: User {user} attempted privilege escalation',\n            'suspicious_process': f'{timestamp} {source}: Suspicious process execution by {user}',\n            'network_scan': f'{timestamp} {source}: Port scan detected from {ip}',\n            'file_access': f'{timestamp} {source}: Unauthorized file access by {user}',\n            'malware_signature': f'{timestamp} {source}: Malware detected in file, user: {user}',\n            'data_exfiltration': f'{timestamp} {source}: Large data transfer by {user} to {ip}',\n            'system_shutdown': f'{timestamp} {source}: System shutdown initiated by {user}'\n        }\n        \n        return log_formats.get(pattern_name, f'{timestamp} {source}: Generic security event')\n    \n    def _generate_random_ip(self) -> str:\n        \"\"\"Generate random IP address\"\"\"\n        return f\"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}\"\n    \n    def _generate_random_user(self) -> str:\n        \"\"\"Generate random username\"\"\"\n        users = ['admin', 'administrator', 'root', 'guest', 'service', 'backup', 'monitor', 'user1', 'jdoe', 'asmith']\n        return random.choice(users)\n    \n    def _generate_random_system(self) -> str:\n        \"\"\"Generate random system name\"\"\"\n        systems = ['web-server-01', 'db-server-02', 'mail-server-01', 'file-server-03', 'backup-server-01', \n                  'workstation-15', 'workstation-23', 'domain-controller', 'firewall-01', 'proxy-server']\n        return random.choice(systems)\n    \n    def _calculate_time_span(self, events: List[Dict[str, Any]]) -> str:\n        \"\"\"Calculate time span of events\"\"\"\n        if not events:\n            return \"Unknown\"\n        \n        timestamps = [event['timestamp'] for event in events]\n        start_time = min(timestamps)\n        end_time = max(timestamps)\n        \n        duration = end_time - start_time\n        \n        if duration.total_seconds() < 3600:  # Less than 1 hour\n            minutes = int(duration.total_seconds() / 60)\n            return f\"{minutes} minutes\"\n        elif duration.total_seconds() < 86400:  # Less than 1 day\n            hours = int(duration.total_seconds() / 3600)\n            return f\"{hours} hours\"\n        else:\n            days = int(duration.total_seconds() / 86400)\n            return f\"{days} days\"\n","size_bytes":21574},"core/threat_detection.py":{"content":"import random\nimport hashlib\nimport json\nfrom datetime import datetime, timedelta\nfrom typing import List, Dict, Any\nimport re\n\nclass ThreatDetectionEngine:\n    \"\"\"Main threat detection engine coordinating all security modules\"\"\"\n    \n    def __init__(self):\n        self.active_threats = []\n        self.threat_signatures = self._load_threat_signatures()\n        self.detection_rules = self._initialize_detection_rules()\n        self.system_health = {\n            'score': 8.5,\n            'trend': 0.2,\n            'protected_assets': 1247,\n            'new_assets': 15\n        }\n    \n    def _load_threat_signatures(self) -> Dict[str, Any]:\n        \"\"\"Load threat signatures and IOCs\"\"\"\n        return {\n            'ransomware': {\n                'file_extensions': ['.encrypted', '.locked', '.crypto', '.vault', '.crypt'],\n                'registry_keys': [\n                    'HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\WanaCrypt0r',\n                    'HKEY_CURRENT_USER\\\\Software\\\\Bitcoin'\n                ],\n                'processes': ['wannacry.exe', 'tasksche.exe', 'disk.exe'],\n                'network_indicators': ['*.onion', 'tor2web.org', 'bitcoin']\n            },\n            'apt': {\n                'lateral_movement': ['psexec', 'wmiexec', 'smbexec', 'rdp_login'],\n                'persistence': ['schtasks', 'sc create', 'reg add', 'wmic'],\n                'exfiltration': ['ftp', 'sftp', 'http_post', 'dns_tunnel'],\n                'c2_patterns': ['base64_encoded', 'periodic_beacon', 'encrypted_traffic']\n            },\n            'malware': {\n                'suspicious_processes': ['powershell -enc', 'cmd /c', 'rundll32', 'regsvr32'],\n                'file_behaviors': ['file_encryption', 'registry_modification', 'privilege_escalation'],\n                'network_behaviors': ['c2_communication', 'data_exfiltration', 'port_scanning']\n            }\n        }\n    \n    def _initialize_detection_rules(self) -> List[Dict[str, Any]]:\n        \"\"\"Initialize behavioral detection rules\"\"\"\n        return [\n            {\n                'name': 'Mass File Encryption',\n                'category': 'Ransomware',\n                'pattern': r'.*\\.(encrypted|locked|crypto)$',\n                'threshold': 10,\n                'severity': 'Critical'\n            },\n            {\n                'name': 'Suspicious PowerShell',\n                'category': 'Malware',\n                'pattern': r'powershell.*-enc.*',\n                'threshold': 1,\n                'severity': 'High'\n            },\n            {\n                'name': 'Port Scanning',\n                'category': 'Network Intrusion',\n                'pattern': r'connect_attempts > 100',\n                'threshold': 100,\n                'severity': 'Medium'\n            },\n            {\n                'name': 'Privilege Escalation',\n                'category': 'Endpoint Attack',\n                'pattern': r'.*SeDebugPrivilege.*',\n                'threshold': 1,\n                'severity': 'High'\n            }\n        ]\n    \n    def detect_threats(self, log_data: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"Main threat detection function\"\"\"\n        detected_threats = []\n        \n        for log_entry in log_data:\n            threats = self._analyze_log_entry(log_entry)\n            detected_threats.extend(threats)\n        \n        # Update active threats\n        self.active_threats.extend(detected_threats)\n        \n        # Remove old threats (older than 24 hours)\n        cutoff_time = datetime.now() - timedelta(hours=24)\n        self.active_threats = [\n            threat for threat in self.active_threats \n            if threat['timestamp'] > cutoff_time\n        ]\n        \n        return detected_threats\n    \n    def _analyze_log_entry(self, log_entry: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Analyze individual log entry for threats\"\"\"\n        threats = []\n        \n        # Check against detection rules\n        for rule in self.detection_rules:\n            if self._matches_rule(log_entry, rule):\n                threat = {\n                    'id': self._generate_threat_id(),\n                    'type': rule['category'],\n                    'name': rule['name'],\n                    'severity': rule['severity'],\n                    'confidence': self._calculate_confidence(log_entry, rule),\n                    'timestamp': datetime.now(),\n                    'source': log_entry.get('source', 'Unknown'),\n                    'target': log_entry.get('target', 'Unknown'),\n                    'description': self._generate_threat_description(rule, log_entry),\n                    'indicators': self._extract_indicators(log_entry),\n                    'recommended_action': self._get_recommended_action(rule['severity'])\n                }\n                threats.append(threat)\n        \n        # Check for specific threat patterns\n        threats.extend(self._detect_ransomware_patterns(log_entry))\n        threats.extend(self._detect_apt_patterns(log_entry))\n        threats.extend(self._detect_zero_day_patterns(log_entry))\n        \n        return threats\n    \n    def _matches_rule(self, log_entry: Dict[str, Any], rule: Dict[str, Any]) -> bool:\n        \"\"\"Check if log entry matches detection rule\"\"\"\n        pattern = rule['pattern']\n        \n        # Simple pattern matching for demo\n        log_text = str(log_entry)\n        return bool(re.search(pattern, log_text, re.IGNORECASE))\n    \n    def _calculate_confidence(self, log_entry: Dict[str, Any], rule: Dict[str, Any]) -> float:\n        \"\"\"Calculate confidence score for threat detection\"\"\"\n        base_confidence = 0.7\n        \n        # Increase confidence based on multiple indicators\n        indicators_count = len(self._extract_indicators(log_entry))\n        confidence_boost = min(indicators_count * 0.1, 0.3)\n        \n        return min(base_confidence + confidence_boost, 1.0)\n    \n    def _generate_threat_description(self, rule: Dict[str, Any], log_entry: Dict[str, Any]) -> str:\n        \"\"\"Generate human-readable threat description\"\"\"\n        descriptions = {\n            'Ransomware': f\"Potential ransomware activity detected. Rule '{rule['name']}' triggered by suspicious file operations.\",\n            'Malware': f\"Malicious software behavior detected. Rule '{rule['name']}' indicates potential malware execution.\",\n            'Network Intrusion': f\"Network intrusion attempt detected. Rule '{rule['name']}' shows suspicious network activity.\",\n            'Endpoint Attack': f\"Endpoint compromise detected. Rule '{rule['name']}' indicates system-level attack.\"\n        }\n        \n        return descriptions.get(rule['category'], f\"Security rule '{rule['name']}' triggered.\")\n    \n    def _extract_indicators(self, log_entry: Dict[str, Any]) -> List[str]:\n        \"\"\"Extract indicators of compromise from log entry\"\"\"\n        indicators = []\n        \n        # Extract IP addresses\n        ip_pattern = r'\\b(?:\\d{1,3}\\.){3}\\d{1,3}\\b'\n        indicators.extend(re.findall(ip_pattern, str(log_entry)))\n        \n        # Extract file hashes\n        hash_pattern = r'\\b[a-fA-F0-9]{32,64}\\b'\n        indicators.extend(re.findall(hash_pattern, str(log_entry)))\n        \n        # Extract domain names\n        domain_pattern = r'\\b[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*\\b'\n        indicators.extend(re.findall(domain_pattern, str(log_entry)))\n        \n        return list(set(indicators))  # Remove duplicates\n    \n    def _get_recommended_action(self, severity: str) -> str:\n        \"\"\"Get recommended action based on threat severity\"\"\"\n        actions = {\n            'Critical': 'Immediate isolation and incident response required',\n            'High': 'Investigate immediately and consider containment',\n            'Medium': 'Schedule investigation within 4 hours',\n            'Low': 'Monitor and investigate during normal business hours'\n        }\n        \n        return actions.get(severity, 'Monitor and assess')\n    \n    def _detect_ransomware_patterns(self, log_entry: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Detect ransomware-specific patterns\"\"\"\n        threats = []\n        log_text = str(log_entry).lower()\n        \n        # Check for file encryption patterns\n        if any(ext in log_text for ext in self.threat_signatures['ransomware']['file_extensions']):\n            threats.append({\n                'id': self._generate_threat_id(),\n                'type': 'Ransomware',\n                'name': 'File Encryption Activity',\n                'severity': 'Critical',\n                'confidence': 0.9,\n                'timestamp': datetime.now(),\n                'source': log_entry.get('source', 'Unknown'),\n                'target': log_entry.get('target', 'Unknown'),\n                'description': 'Suspicious file encryption activity detected. Multiple files with ransomware-associated extensions found.',\n                'indicators': self._extract_indicators(log_entry),\n                'recommended_action': 'Immediate system isolation and backup restoration'\n            })\n        \n        # Check for ransomware processes\n        if any(proc in log_text for proc in self.threat_signatures['ransomware']['processes']):\n            threats.append({\n                'id': self._generate_threat_id(),\n                'type': 'Ransomware',\n                'name': 'Known Ransomware Process',\n                'severity': 'Critical',\n                'confidence': 0.95,\n                'timestamp': datetime.now(),\n                'source': log_entry.get('source', 'Unknown'),\n                'target': log_entry.get('target', 'Unknown'),\n                'description': 'Known ransomware process detected in system execution logs.',\n                'indicators': self._extract_indicators(log_entry),\n                'recommended_action': 'Immediate process termination and system isolation'\n            })\n        \n        return threats\n    \n    def _detect_apt_patterns(self, log_entry: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Detect Advanced Persistent Threat patterns\"\"\"\n        threats = []\n        log_text = str(log_entry).lower()\n        \n        # Check for lateral movement\n        if any(tool in log_text for tool in self.threat_signatures['apt']['lateral_movement']):\n            threats.append({\n                'id': self._generate_threat_id(),\n                'type': 'APT',\n                'name': 'Lateral Movement',\n                'severity': 'High',\n                'confidence': 0.8,\n                'timestamp': datetime.now(),\n                'source': log_entry.get('source', 'Unknown'),\n                'target': log_entry.get('target', 'Unknown'),\n                'description': 'Potential lateral movement activity detected. Attacker may be spreading through the network.',\n                'indicators': self._extract_indicators(log_entry),\n                'recommended_action': 'Investigate network traffic and isolate affected systems'\n            })\n        \n        # Check for data exfiltration\n        if any(method in log_text for method in self.threat_signatures['apt']['exfiltration']):\n            threats.append({\n                'id': self._generate_threat_id(),\n                'type': 'APT',\n                'name': 'Data Exfiltration',\n                'severity': 'Critical',\n                'confidence': 0.85,\n                'timestamp': datetime.now(),\n                'source': log_entry.get('source', 'Unknown'),\n                'target': log_entry.get('target', 'Unknown'),\n                'description': 'Potential data exfiltration detected. Sensitive data may be leaving the network.',\n                'indicators': self._extract_indicators(log_entry),\n                'recommended_action': 'Block external connections and investigate data flows'\n            })\n        \n        return threats\n    \n    def _detect_zero_day_patterns(self, log_entry: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Detect potential zero-day exploit patterns\"\"\"\n        threats = []\n        log_text = str(log_entry).lower()\n        \n        # Look for unusual process behavior\n        suspicious_patterns = [\n            'buffer overflow', 'heap spray', 'rop chain', 'shellcode',\n            'memory corruption', 'arbitrary code execution'\n        ]\n        \n        if any(pattern in log_text for pattern in suspicious_patterns):\n            threats.append({\n                'id': self._generate_threat_id(),\n                'type': 'Zero-Day Exploit',\n                'name': 'Memory Corruption Attack',\n                'severity': 'Critical',\n                'confidence': 0.75,\n                'timestamp': datetime.now(),\n                'source': log_entry.get('source', 'Unknown'),\n                'target': log_entry.get('target', 'Unknown'),\n                'description': 'Potential zero-day exploit detected. Memory corruption patterns indicate advanced attack.',\n                'indicators': self._extract_indicators(log_entry),\n                'recommended_action': 'Immediate system isolation and forensic analysis'\n            })\n        \n        return threats\n    \n    def _generate_threat_id(self) -> str:\n        \"\"\"Generate unique threat ID\"\"\"\n        timestamp = str(datetime.now().timestamp())\n        return hashlib.md5(timestamp.encode()).hexdigest()[:8].upper()\n    \n    def get_active_threats(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of currently active threats\"\"\"\n        return sorted(self.active_threats, key=lambda x: x['timestamp'], reverse=True)\n    \n    def get_threat_distribution(self) -> Dict[str, int]:\n        \"\"\"Get distribution of threat types\"\"\"\n        distribution = {}\n        for threat in self.active_threats:\n            threat_type = threat['type']\n            distribution[threat_type] = distribution.get(threat_type, 0) + 1\n        \n        # Add some baseline data if no threats\n        if not distribution:\n            distribution = {\n                'Network Intrusion': 5,\n                'Malware': 3,\n                'Phishing': 2,\n                'Data Breach': 1\n            }\n        \n        return distribution\n    \n    def get_system_health(self) -> Dict[str, Any]:\n        \"\"\"Get overall system health metrics\"\"\"\n        return self.system_health\n    \n    def update_system_health(self, threats_count: int):\n        \"\"\"Update system health based on current threat landscape\"\"\"\n        if threats_count > 10:\n            self.system_health['score'] = max(5.0, self.system_health['score'] - 0.5)\n        elif threats_count < 3:\n            self.system_health['score'] = min(10.0, self.system_health['score'] + 0.1)\n        \n        # Simulate trend\n        self.system_health['trend'] = random.uniform(-0.5, 0.5)\n","size_bytes":14732},"monitoring/endpoint_monitor.py":{"content":"import os\nimport random\nimport hashlib\nimport threading\nimport time\nimport psutil\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional, Tuple\nimport json\nfrom collections import defaultdict\nimport uuid\n\nclass EndpointMonitor:\n    \"\"\"Advanced endpoint security monitoring and protection system\"\"\"\n    \n    def __init__(self):\n        self.monitored_endpoints = []\n        self.scan_results = {}\n        self.behavioral_baselines = {}\n        self.threat_signatures = self._load_threat_signatures()\n        self.quarantine_directory = \"quarantine/\"\n        self.monitoring_active = False\n        self.file_integrity_database = {}\n        self.process_whitelist = self._load_process_whitelist()\n        self.malware_families = self._load_malware_families()\n        self._initialize_endpoints()\n        \n    def _load_threat_signatures(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load endpoint threat signatures\"\"\"\n        return {\n            'ransomware': {\n                'file_extensions': ['.encrypted', '.locked', '.crypto', '.vault', '.crypt', '.wncry'],\n                'processes': ['wannacry.exe', 'tasksche.exe', 'disk.exe', 'locky.exe'],\n                'registry_keys': [\n                    'HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\WanaCrypt0r',\n                    'HKEY_CURRENT_USER\\\\Software\\\\Bitcoin'\n                ],\n                'behaviors': [\n                    'rapid_file_encryption', 'shadow_copy_deletion', 'ransom_note_creation'\n                ],\n                'network_indicators': ['*.onion', 'tor2web.org', 'bitcoin payment']\n            },\n            'trojan': {\n                'processes': ['trojan.exe', 'backdoor.exe', 'rat.exe'],\n                'network_behaviors': ['keylogger_traffic', 'screenshot_upload', 'remote_access'],\n                'file_behaviors': ['credential_theft', 'system_information_collection'],\n                'persistence': ['startup_registry', 'scheduled_task', 'service_installation']\n            },\n            'rootkit': {\n                'behaviors': ['process_hiding', 'file_hiding', 'registry_hiding'],\n                'kernel_modifications': ['hook_installation', 'driver_injection'],\n                'evasion_techniques': ['anti_debugging', 'vm_detection', 'sandbox_evasion']\n            },\n            'spyware': {\n                'behaviors': ['keylogging', 'screen_capture', 'microphone_access', 'camera_access'],\n                'data_collection': ['browser_data', 'email_data', 'document_access'],\n                'communication': ['http_post', 'email_exfiltration', 'ftp_upload']\n            },\n            'adware': {\n                'behaviors': ['browser_hijacking', 'popup_generation', 'search_redirection'],\n                'modifications': ['homepage_change', 'search_engine_change', 'proxy_settings']\n            },\n            'botnet': {\n                'network_behaviors': ['c2_communication', 'peer_communication', 'ddos_participation'],\n                'processes': ['bot.exe', 'agent.exe', 'client.exe'],\n                'behaviors': ['command_execution', 'file_download', 'update_mechanism']\n            }\n        }\n    \n    def _load_process_whitelist(self) -> List[str]:\n        \"\"\"Load whitelist of legitimate processes\"\"\"\n        return [\n            'explorer.exe', 'winlogon.exe', 'csrss.exe', 'lsass.exe', 'services.exe',\n            'svchost.exe', 'taskmgr.exe', 'dwm.exe', 'chrome.exe', 'firefox.exe',\n            'outlook.exe', 'word.exe', 'excel.exe', 'powerpnt.exe', 'notepad.exe',\n            'calc.exe', 'mspaint.exe', 'cmd.exe', 'powershell.exe', 'conhost.exe',\n            'system', 'registry', 'memory compression', 'secure system'\n        ]\n    \n    def _load_malware_families(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load known malware families\"\"\"\n        return {\n            'WannaCry': {\n                'type': 'Ransomware',\n                'variants': ['WannaCry 1.0', 'WannaCry 2.0'],\n                'signatures': ['@WanaDecryptor@', 'wannacry'],\n                'behavior': 'File encryption, SMB exploitation'\n            },\n            'Locky': {\n                'type': 'Ransomware',\n                'variants': ['Locky', 'Lukitus', 'Diablo6'],\n                'signatures': ['.locky', '.lukitus', '.diablo6'],\n                'behavior': 'Email-based infection, file encryption'\n            },\n            'Zeus': {\n                'type': 'Banking Trojan',\n                'variants': ['Zeus', 'ZeuS', 'Zbot'],\n                'signatures': ['zeus', 'zbot'],\n                'behavior': 'Credential theft, web injection'\n            },\n            'Emotet': {\n                'type': 'Trojan Downloader',\n                'variants': ['Emotet', 'Epoch 1', 'Epoch 2'],\n                'signatures': ['emotet'],\n                'behavior': 'Email spreading, payload delivery'\n            },\n            'Stuxnet': {\n                'type': 'Worm',\n                'variants': ['Stuxnet'],\n                'signatures': ['stuxnet', '.stub'],\n                'behavior': 'Industrial system targeting, PLC manipulation'\n            }\n        }\n    \n    def _initialize_endpoints(self):\n        \"\"\"Initialize monitored endpoints with sample data\"\"\"\n        endpoint_types = ['workstation', 'server', 'laptop', 'tablet']\n        os_types = ['Windows 10', 'Windows 11', 'Windows Server 2019', 'Windows Server 2022', \n                   'Ubuntu 20.04', 'Ubuntu 22.04', 'macOS Monterey', 'macOS Ventura']\n        \n        for i in range(25):\n            endpoint = {\n                'id': str(uuid.uuid4()),\n                'name': f'{random.choice(endpoint_types)}-{i+1:02d}',\n                'type': random.choice(endpoint_types),\n                'os': random.choice(os_types),\n                'ip_address': f'192.168.1.{random.randint(10, 250)}',\n                'mac_address': self._generate_mac_address(),\n                'status': random.choices(['healthy', 'warning', 'critical', 'offline'], \n                                       weights=[0.7, 0.2, 0.05, 0.05])[0],\n                'last_scan': datetime.now() - timedelta(hours=random.randint(0, 24)),\n                'threat_count': random.randint(0, 5),\n                'antivirus_status': random.choice(['enabled', 'disabled', 'outdated']),\n                'firewall_status': random.choice(['enabled', 'disabled']),\n                'last_boot': datetime.now() - timedelta(days=random.randint(0, 30)),\n                'cpu_usage': random.uniform(5.0, 95.0),\n                'memory_usage': random.uniform(30.0, 85.0),\n                'disk_usage': random.uniform(40.0, 90.0),\n                'network_activity': random.uniform(1.0, 100.0),  # Mbps\n                'running_processes': random.randint(50, 200),\n                'installed_software': random.randint(50, 300),\n                'vulnerability_score': random.uniform(1.0, 10.0),\n                'compliance_score': random.uniform(0.6, 1.0),\n                'last_update': datetime.now() - timedelta(days=random.randint(0, 30)),\n                'user': f'user{random.randint(1, 100)}',\n                'domain': random.choice(['CORP', 'LOCAL', 'WORKGROUP'])\n            }\n            \n            self.monitored_endpoints.append(endpoint)\n            \n            # Initialize behavioral baseline\n            self.behavioral_baselines[endpoint['id']] = {\n                'normal_cpu_usage': random.uniform(10.0, 30.0),\n                'normal_memory_usage': random.uniform(40.0, 60.0),\n                'normal_network_activity': random.uniform(5.0, 25.0),\n                'normal_process_count': random.randint(80, 120),\n                'normal_file_operations': random.randint(100, 500),\n                'typical_login_hours': [8, 9, 10, 11, 12, 13, 14, 15, 16, 17],\n                'common_applications': random.sample(self.process_whitelist, 10)\n            }\n    \n    def get_endpoint_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get endpoint protection statistics\"\"\"\n        total_endpoints = len(self.monitored_endpoints)\n        protected_endpoints = len([e for e in self.monitored_endpoints \n                                 if e['antivirus_status'] == 'enabled'])\n        \n        threats_detected = sum(e['threat_count'] for e in self.monitored_endpoints)\n        quarantined_files = random.randint(50, 500)\n        \n        # Calculate compliance score\n        compliance_scores = [e['compliance_score'] for e in self.monitored_endpoints]\n        avg_compliance = sum(compliance_scores) / len(compliance_scores) if compliance_scores else 0\n        \n        return {\n            'total_endpoints': total_endpoints,\n            'protected': protected_endpoints,\n            'unprotected': total_endpoints - protected_endpoints,\n            'threats_detected': threats_detected,\n            'quarantined': quarantined_files,\n            'compliance_score': avg_compliance,\n            'online': len([e for e in self.monitored_endpoints if e['status'] != 'offline']),\n            'offline': len([e for e in self.monitored_endpoints if e['status'] == 'offline']),\n            'critical_alerts': len([e for e in self.monitored_endpoints if e['status'] == 'critical']),\n            'pending_updates': len([e for e in self.monitored_endpoints \n                                  if (datetime.now() - e['last_update']).days > 7])\n        }\n    \n    def get_all_endpoints(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all monitored endpoints\"\"\"\n        return self.monitored_endpoints\n    \n    def run_scan(self, endpoint_name: str, scan_type: str) -> Dict[str, Any]:\n        \"\"\"Run security scan on specific endpoint\"\"\"\n        endpoint = next((e for e in self.monitored_endpoints if e['name'] == endpoint_name), None)\n        \n        if not endpoint:\n            return {'error': f'Endpoint {endpoint_name} not found'}\n        \n        scan_start_time = datetime.now()\n        scan_id = str(uuid.uuid4())[:8]\n        \n        # Simulate scan based on type and intensity\n        scan_results = {\n            'scan_id': scan_id,\n            'endpoint_name': endpoint_name,\n            'endpoint_id': endpoint['id'],\n            'scan_type': scan_type,\n            'start_time': scan_start_time,\n            'threats_found': [],\n            'files_scanned': 0,\n            'processes_analyzed': 0,\n            'registry_entries_checked': 0,\n            'network_connections_analyzed': 0,\n            'vulnerabilities_found': [],\n            'performance_impact': 'Low',\n            'scan_duration': 0\n        }\n        \n        if scan_type == \"Quick Scan\":\n            scan_results.update(self._perform_quick_scan(endpoint))\n        elif scan_type == \"Full System Scan\":\n            scan_results.update(self._perform_full_scan(endpoint))\n        elif scan_type == \"Custom Scan\":\n            scan_results.update(self._perform_custom_scan(endpoint))\n        elif scan_type == \"Memory Scan\":\n            scan_results.update(self._perform_memory_scan(endpoint))\n        \n        # Calculate scan duration\n        scan_end_time = datetime.now()\n        scan_results['end_time'] = scan_end_time\n        scan_results['scan_duration'] = (scan_end_time - scan_start_time).total_seconds()\n        \n        # Update endpoint scan information\n        endpoint['last_scan'] = scan_end_time\n        endpoint['threat_count'] = len(scan_results['threats_found'])\n        \n        # Store scan results\n        self.scan_results[scan_id] = scan_results\n        \n        return scan_results\n    \n    def _perform_quick_scan(self, endpoint: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Perform quick scan of critical system areas\"\"\"\n        time.sleep(2)  # Simulate scan time\n        \n        results = {\n            'files_scanned': random.randint(1000, 5000),\n            'processes_analyzed': random.randint(20, 50),\n            'registry_entries_checked': random.randint(100, 500),\n            'performance_impact': 'Low'\n        }\n        \n        # Generate potential threats\n        threat_probability = 0.1  # 10% chance of finding threats in quick scan\n        if random.random() < threat_probability:\n            results['threats_found'] = self._generate_sample_threats(random.randint(1, 3))\n        \n        return results\n    \n    def _perform_full_scan(self, endpoint: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Perform comprehensive full system scan\"\"\"\n        time.sleep(5)  # Simulate longer scan time\n        \n        results = {\n            'files_scanned': random.randint(50000, 200000),\n            'processes_analyzed': random.randint(50, 150),\n            'registry_entries_checked': random.randint(5000, 20000),\n            'network_connections_analyzed': random.randint(20, 100),\n            'performance_impact': 'High'\n        }\n        \n        # Higher chance of finding threats in full scan\n        threat_probability = 0.25\n        if random.random() < threat_probability:\n            results['threats_found'] = self._generate_sample_threats(random.randint(1, 8))\n        \n        # Check for vulnerabilities\n        vuln_probability = 0.3\n        if random.random() < vuln_probability:\n            results['vulnerabilities_found'] = self._generate_sample_vulnerabilities()\n        \n        return results\n    \n    def _perform_custom_scan(self, endpoint: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Perform custom targeted scan\"\"\"\n        time.sleep(3)  # Simulate scan time\n        \n        results = {\n            'files_scanned': random.randint(10000, 50000),\n            'processes_analyzed': random.randint(30, 80),\n            'registry_entries_checked': random.randint(1000, 10000),\n            'performance_impact': 'Medium'\n        }\n        \n        threat_probability = 0.15\n        if random.random() < threat_probability:\n            results['threats_found'] = self._generate_sample_threats(random.randint(1, 5))\n        \n        return results\n    \n    def _perform_memory_scan(self, endpoint: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Perform memory-focused scan for active threats\"\"\"\n        time.sleep(1)  # Fast memory scan\n        \n        results = {\n            'files_scanned': 0,  # Memory scan doesn't scan files\n            'processes_analyzed': random.randint(80, 150),\n            'memory_regions_scanned': random.randint(1000, 5000),\n            'performance_impact': 'Low'\n        }\n        \n        # Memory scans are good at finding active malware\n        threat_probability = 0.2\n        if random.random() < threat_probability:\n            threats = self._generate_sample_threats(random.randint(1, 4))\n            # Mark as memory-resident\n            for threat in threats:\n                threat['location'] = 'Memory'\n                threat['action_taken'] = 'Process terminated'\n            results['threats_found'] = threats\n        \n        return results\n    \n    def _generate_sample_threats(self, count: int) -> List[Dict[str, Any]]:\n        \"\"\"Generate sample threats for demonstration\"\"\"\n        threats = []\n        threat_types = ['Trojan', 'Virus', 'Spyware', 'Adware', 'Rootkit', 'Ransomware']\n        actions = ['Quarantined', 'Deleted', 'Cleaned', 'Access denied']\n        \n        for _ in range(count):\n            threat_type = random.choice(threat_types)\n            \n            threat = {\n                'name': f'{threat_type}.{random.choice([\"Win32\", \"Gen\", \"Agent\"])}.{random.randint(1000, 9999)}',\n                'type': threat_type,\n                'severity': random.choice(['Low', 'Medium', 'High', 'Critical']),\n                'file_path': self._generate_file_path(),\n                'file_size': random.randint(1024, 10485760),  # 1KB to 10MB\n                'md5_hash': hashlib.md5(f'threat_{random.randint(1000, 9999)}'.encode()).hexdigest(),\n                'sha256_hash': hashlib.sha256(f'threat_{random.randint(1000, 9999)}'.encode()).hexdigest(),\n                'detection_time': datetime.now(),\n                'action_taken': random.choice(actions),\n                'confidence': random.uniform(0.8, 0.99),\n                'infected_since': datetime.now() - timedelta(days=random.randint(1, 30)),\n                'source': random.choice(['Email attachment', 'Web download', 'USB device', 'Network share', 'Unknown'])\n            }\n            \n            threats.append(threat)\n        \n        return threats\n    \n    def _generate_sample_vulnerabilities(self) -> List[Dict[str, Any]]:\n        \"\"\"Generate sample vulnerabilities\"\"\"\n        vulnerabilities = []\n        vuln_types = ['Missing patch', 'Weak password', 'Open port', 'Outdated software', 'Configuration issue']\n        \n        for _ in range(random.randint(1, 5)):\n            vuln = {\n                'cve_id': f'CVE-2024-{random.randint(1000, 9999)}',\n                'title': f'{random.choice(vuln_types)} in {random.choice([\"Windows\", \"Chrome\", \"Office\", \"Java\", \"Adobe Reader\"])}',\n                'severity': random.choice(['Low', 'Medium', 'High', 'Critical']),\n                'cvss_score': random.uniform(1.0, 10.0),\n                'description': 'Security vulnerability that could allow remote code execution',\n                'solution': 'Apply security update or patch',\n                'published_date': datetime.now() - timedelta(days=random.randint(1, 365)),\n                'exploitability': random.choice(['Low', 'Medium', 'High']),\n                'patch_available': random.choice([True, False])\n            }\n            \n            vulnerabilities.append(vuln)\n        \n        return vulnerabilities\n    \n    def get_behavioral_analysis(self) -> Dict[str, Any]:\n        \"\"\"Get behavioral analysis results\"\"\"\n        suspicious_processes = []\n        network_anomalies = []\n        \n        # Generate suspicious processes\n        for _ in range(random.randint(0, 5)):\n            process = {\n                'name': f'suspicious_process_{random.randint(100, 999)}.exe',\n                'pid': random.randint(1000, 9999),\n                'cpu_usage': random.uniform(50.0, 95.0),\n                'memory_usage': random.uniform(100.0, 1000.0),  # MB\n                'risk_score': random.uniform(0.7, 0.95),\n                'behaviors': random.sample([\n                    'High network activity', 'Unusual file access', 'Registry modification',\n                    'Process injection', 'Keylogger activity', 'Screen capture'\n                ], random.randint(1, 3)),\n                'parent_process': random.choice(['explorer.exe', 'svchost.exe', 'winlogon.exe']),\n                'command_line': f'suspicious_process_{random.randint(100, 999)}.exe -h -s -q',\n                'start_time': datetime.now() - timedelta(minutes=random.randint(5, 120))\n            }\n            suspicious_processes.append(process)\n        \n        # Generate network anomalies\n        for _ in range(random.randint(0, 3)):\n            anomaly = {\n                'process': f'anomalous_app_{random.randint(10, 99)}.exe',\n                'destination': f'{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}',\n                'port': random.choice([443, 80, 8080, 9999, 4444]),\n                'protocol': random.choice(['TCP', 'UDP']),\n                'data_transferred': random.uniform(1.0, 100.0),  # MB\n                'risk_score': random.uniform(0.6, 0.9),\n                'country': random.choice(['CN', 'RU', 'KP', 'IR', 'Unknown']),\n                'duration': random.randint(60, 3600),  # seconds\n                'connection_type': random.choice(['Persistent', 'Periodic', 'Burst'])\n            }\n            network_anomalies.append(anomaly)\n        \n        return {\n            'suspicious_processes': suspicious_processes,\n            'network_anomalies': network_anomalies,\n            'file_system_changes': random.randint(50, 500),\n            'registry_modifications': random.randint(10, 100),\n            'unusual_login_attempts': random.randint(0, 20),\n            'analysis_time': datetime.now(),\n            'baseline_deviations': {\n                'cpu_usage': random.uniform(-20.0, 50.0),\n                'memory_usage': random.uniform(-10.0, 30.0),\n                'network_activity': random.uniform(-5.0, 100.0),\n                'process_count': random.randint(-10, 50)\n            }\n        }\n    \n    def analyze_file(self, uploaded_file) -> Dict[str, Any]:\n        \"\"\"Analyze uploaded file for malware\"\"\"\n        file_content = uploaded_file.getvalue()\n        file_size = len(file_content)\n        \n        # Calculate file hashes\n        md5_hash = hashlib.md5(file_content).hexdigest()\n        sha256_hash = hashlib.sha256(file_content).hexdigest()\n        \n        # Simulate malware analysis\n        analysis_results = {\n            'file_name': uploaded_file.name,\n            'file_size': file_size,\n            'md5': md5_hash,\n            'sha256': sha256_hash,\n            'file_type': self._detect_file_type(uploaded_file.name),\n            'analysis_time': datetime.now(),\n            'scan_engines': {},\n            'threat_score': 0.0,\n            'is_malicious': False,\n            'threat_type': None,\n            'malware_family': None,\n            'engine_results': {}\n        }\n        \n        # Simulate multiple AV engine results\n        engines = ['VirusTotal', 'Windows Defender', 'McAfee', 'Norton', 'Kaspersky', \n                  'Avast', 'AVG', 'ESET', 'Bitdefender', 'Trend Micro']\n        \n        detection_count = 0\n        for engine in engines:\n            # Simulate detection (small chance of detection for demo purposes)\n            detected = random.random() < 0.1  # 10% chance of detection\n            \n            if detected:\n                detection_count += 1\n                threat_name = f'{random.choice([\"Trojan\", \"Virus\", \"Spyware\"])}.{random.choice([\"Win32\", \"Gen\"])}.{random.randint(1000, 9999)}'\n            else:\n                threat_name = None\n            \n            analysis_results['engine_results'][engine] = {\n                'detected': detected,\n                'threat_name': threat_name,\n                'last_updated': datetime.now() - timedelta(days=random.randint(0, 7))\n            }\n        \n        # Calculate threat score based on detections\n        if detection_count > 0:\n            analysis_results['is_malicious'] = True\n            analysis_results['threat_score'] = min(1.0, detection_count / len(engines) * 2)\n            analysis_results['threat_type'] = random.choice(['Trojan', 'Virus', 'Spyware', 'Adware'])\n            \n            # Try to identify malware family\n            for family_name, family_info in self.malware_families.items():\n                if any(sig in uploaded_file.name.lower() for sig in family_info['signatures']):\n                    analysis_results['malware_family'] = family_name\n                    break\n            \n            if not analysis_results['malware_family']:\n                analysis_results['malware_family'] = 'Unknown'\n        \n        return analysis_results\n    \n    def run_continuous_monitoring(self):\n        \"\"\"Run continuous endpoint monitoring\"\"\"\n        if self.monitoring_active:\n            return  # Already running\n        \n        self.monitoring_active = True\n        \n        def monitoring_loop():\n            while self.monitoring_active:\n                try:\n                    # Update endpoint status\n                    for endpoint in self.monitored_endpoints:\n                        self._update_endpoint_status(endpoint)\n                    \n                    # Run behavioral analysis\n                    self._run_behavioral_analysis()\n                    \n                    # Check for new threats\n                    self._check_for_new_threats()\n                    \n                    # Sleep for monitoring interval\n                    time.sleep(60)  # Check every minute\n                    \n                except Exception as e:\n                    print(f\"Endpoint monitoring error: {e}\")\n                    time.sleep(300)  # Wait longer on error\n        \n        # Start monitoring in separate thread\n        monitoring_thread = threading.Thread(target=monitoring_loop, daemon=True)\n        monitoring_thread.start()\n    \n    def stop_monitoring(self):\n        \"\"\"Stop continuous monitoring\"\"\"\n        self.monitoring_active = False\n    \n    def _update_endpoint_status(self, endpoint: Dict[str, Any]):\n        \"\"\"Update individual endpoint status\"\"\"\n        # Simulate status changes\n        if random.random() < 0.05:  # 5% chance of status change\n            current_status = endpoint['status']\n            \n            if current_status == 'healthy':\n                endpoint['status'] = random.choices(['warning', 'critical'], weights=[0.8, 0.2])[0]\n            elif current_status == 'warning':\n                endpoint['status'] = random.choices(['healthy', 'critical'], weights=[0.7, 0.3])[0]\n            elif current_status == 'critical':\n                endpoint['status'] = random.choices(['warning', 'healthy'], weights=[0.6, 0.4])[0]\n        \n        # Update system metrics\n        endpoint['cpu_usage'] = max(0, min(100, endpoint['cpu_usage'] + random.uniform(-10, 10)))\n        endpoint['memory_usage'] = max(0, min(100, endpoint['memory_usage'] + random.uniform(-5, 5)))\n        endpoint['network_activity'] = max(0, endpoint['network_activity'] + random.uniform(-20, 20))\n    \n    def _run_behavioral_analysis(self):\n        \"\"\"Run behavioral analysis on all endpoints\"\"\"\n        for endpoint in self.monitored_endpoints:\n            baseline = self.behavioral_baselines.get(endpoint['id'])\n            if not baseline:\n                continue\n            \n            # Check for behavioral anomalies\n            cpu_deviation = abs(endpoint['cpu_usage'] - baseline['normal_cpu_usage'])\n            memory_deviation = abs(endpoint['memory_usage'] - baseline['normal_memory_usage'])\n            \n            # Flag significant deviations\n            if cpu_deviation > 30 or memory_deviation > 25:\n                endpoint['status'] = 'warning'\n                endpoint['threat_count'] += 1\n    \n    def _check_for_new_threats(self):\n        \"\"\"Check for new threats across endpoints\"\"\"\n        for endpoint in self.monitored_endpoints:\n            # Small chance of new threat detection\n            if random.random() < 0.02:  # 2% chance\n                endpoint['threat_count'] += 1\n                if endpoint['threat_count'] > 3:\n                    endpoint['status'] = 'critical'\n    \n    def _generate_file_path(self) -> str:\n        \"\"\"Generate realistic file path\"\"\"\n        paths = [\n            'C:\\\\Windows\\\\System32\\\\malware.exe',\n            'C:\\\\Users\\\\Public\\\\Downloads\\\\suspicious.exe',\n            'C:\\\\Temp\\\\threat.dll',\n            'C:\\\\Program Files\\\\BadSoftware\\\\agent.exe',\n            'C:\\\\Windows\\\\Temp\\\\dropper.exe',\n            '%APPDATA%\\\\malicious.exe',\n            '%TEMP%\\\\payload.exe'\n        ]\n        return random.choice(paths)\n    \n    def _detect_file_type(self, filename: str) -> str:\n        \"\"\"Detect file type from filename\"\"\"\n        extension = filename.split('.')[-1].lower()\n        \n        file_types = {\n            'exe': 'Executable',\n            'dll': 'Dynamic Link Library',\n            'bat': 'Batch File',\n            'cmd': 'Command Script',\n            'scr': 'Screen Saver',\n            'com': 'Command File',\n            'pif': 'Program Information File',\n            'vbs': 'VBScript',\n            'js': 'JavaScript',\n            'jar': 'Java Archive',\n            'zip': 'Archive',\n            'rar': 'Archive',\n            'pdf': 'PDF Document',\n            'doc': 'Word Document',\n            'docx': 'Word Document',\n            'xls': 'Excel Document',\n            'xlsx': 'Excel Document'\n        }\n        \n        return file_types.get(extension, 'Unknown')\n    \n    def _generate_mac_address(self) -> str:\n        \"\"\"Generate random MAC address\"\"\"\n        return ':'.join([f'{random.randint(0, 255):02x}' for _ in range(6)])\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get current endpoint protection status\"\"\"\n        stats = self.get_endpoint_statistics()\n        return {\n            'protected': stats['protected'],\n            'quarantined': stats['quarantined'],\n            'total_endpoints': stats['total_endpoints'],\n            'threats_detected': stats['threats_detected']\n        }\n","size_bytes":28290},"monitoring/iot_monitor.py":{"content":"import random\nimport time\nimport threading\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional\nimport json\nimport hashlib\nimport uuid\nfrom collections import defaultdict\n\nclass IoTMonitor:\n    \"\"\"IoT device security monitoring and management system\"\"\"\n    \n    def __init__(self):\n        self.iot_devices = []\n        self.device_profiles = {}\n        self.vulnerability_database = self._load_vulnerability_database()\n        self.device_baselines = {}\n        self.security_policies = self._load_security_policies()\n        self.monitoring_active = False\n        self.threat_patterns = self._load_iot_threat_patterns()\n        self.device_manufacturers = self._load_device_manufacturers()\n        self._initialize_iot_devices()\n        \n    def _load_vulnerability_database(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load IoT vulnerability database\"\"\"\n        return {\n            'default_credentials': {\n                'severity': 'Critical',\n                'cvss_score': 9.8,\n                'description': 'Device uses default username/password',\n                'remediation': 'Change default credentials immediately',\n                'affected_devices': ['cameras', 'routers', 'printers', 'smart_locks']\n            },\n            'unencrypted_communication': {\n                'severity': 'High',\n                'cvss_score': 7.5,\n                'description': 'Device communicates without encryption',\n                'remediation': 'Enable encryption or use VPN',\n                'affected_devices': ['sensors', 'controllers', 'older_cameras']\n            },\n            'firmware_outdated': {\n                'severity': 'High',\n                'cvss_score': 8.1,\n                'description': 'Device firmware is outdated and vulnerable',\n                'remediation': 'Update firmware to latest version',\n                'affected_devices': ['all']\n            },\n            'weak_authentication': {\n                'severity': 'Medium',\n                'cvss_score': 6.5,\n                'description': 'Device uses weak authentication mechanisms',\n                'remediation': 'Implement strong authentication',\n                'affected_devices': ['smart_home', 'wearables']\n            },\n            'open_ports': {\n                'severity': 'Medium',\n                'cvss_score': 5.3,\n                'description': 'Unnecessary ports are open on device',\n                'remediation': 'Close unused ports and services',\n                'affected_devices': ['routers', 'cameras', 'servers']\n            },\n            'buffer_overflow': {\n                'severity': 'Critical',\n                'cvss_score': 9.0,\n                'description': 'Device vulnerable to buffer overflow attacks',\n                'remediation': 'Apply security patch or replace device',\n                'affected_devices': ['cameras', 'routers', 'smart_tvs']\n            },\n            'insecure_update_mechanism': {\n                'severity': 'High',\n                'cvss_score': 7.8,\n                'description': 'Device update mechanism is insecure',\n                'remediation': 'Implement secure update mechanism',\n                'affected_devices': ['smart_home', 'industrial']\n            }\n        }\n    \n    def _load_security_policies(self) -> Dict[str, Any]:\n        \"\"\"Load IoT security policies\"\"\"\n        return {\n            'password_policy': {\n                'min_length': 12,\n                'require_complexity': True,\n                'change_interval_days': 90,\n                'no_default_passwords': True\n            },\n            'network_policy': {\n                'require_encryption': True,\n                'allowed_protocols': ['HTTPS', 'SSH', 'SFTP'],\n                'blocked_protocols': ['HTTP', 'Telnet', 'FTP'],\n                'network_segmentation': True\n            },\n            'firmware_policy': {\n                'auto_update': False,  # Manual approval required\n                'max_days_outdated': 30,\n                'require_signed_updates': True,\n                'test_before_deploy': True\n            },\n            'monitoring_policy': {\n                'continuous_monitoring': True,\n                'anomaly_detection': True,\n                'traffic_analysis': True,\n                'behavioral_profiling': True\n            },\n            'access_policy': {\n                'principle_of_least_privilege': True,\n                'regular_access_review': True,\n                'multi_factor_authentication': True,\n                'session_timeout_minutes': 30\n            }\n        }\n    \n    def _load_iot_threat_patterns(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load IoT-specific threat patterns\"\"\"\n        return {\n            'botnet_recruitment': {\n                'indicators': ['unusual_outbound_traffic', 'c2_communication', 'port_scanning'],\n                'description': 'Device recruited into botnet',\n                'severity': 'Critical',\n                'mitigation': ['isolate_device', 'firmware_update', 'factory_reset']\n            },\n            'credential_brute_force': {\n                'indicators': ['multiple_failed_logins', 'dictionary_attacks', 'timing_attacks'],\n                'description': 'Brute force attack against device credentials',\n                'severity': 'High',\n                'mitigation': ['enable_lockout', 'strong_passwords', 'monitoring']\n            },\n            'firmware_tampering': {\n                'indicators': ['checksum_mismatch', 'unauthorized_changes', 'boot_anomalies'],\n                'description': 'Device firmware has been tampered with',\n                'severity': 'Critical',\n                'mitigation': ['firmware_verification', 'secure_boot', 'device_replacement']\n            },\n            'data_exfiltration': {\n                'indicators': ['large_data_transfers', 'unusual_destinations', 'encrypted_traffic'],\n                'description': 'Sensitive data being exfiltrated from device',\n                'severity': 'High',\n                'mitigation': ['network_monitoring', 'data_classification', 'access_controls']\n            },\n            'denial_of_service': {\n                'indicators': ['resource_exhaustion', 'flooding_attacks', 'crash_patterns'],\n                'description': 'Device under denial of service attack',\n                'severity': 'Medium',\n                'mitigation': ['rate_limiting', 'resource_monitoring', 'failover']\n            },\n            'physical_tampering': {\n                'indicators': ['hardware_changes', 'debug_port_access', 'case_opening'],\n                'description': 'Physical tampering detected on device',\n                'severity': 'High',\n                'mitigation': ['tamper_detection', 'secure_housing', 'alarm_systems']\n            },\n            'man_in_the_middle': {\n                'indicators': ['certificate_anomalies', 'traffic_interception', 'ssl_downgrade'],\n                'description': 'MITM attack against device communications',\n                'severity': 'High',\n                'mitigation': ['certificate_pinning', 'encryption', 'vpn_tunnel']\n            }\n        }\n    \n    def _load_device_manufacturers(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load device manufacturer information\"\"\"\n        return {\n            'Hikvision': {\n                'security_score': 6.5,\n                'common_vulnerabilities': ['default_credentials', 'firmware_outdated'],\n                'products': ['IP Cameras', 'NVRs', 'Access Control'],\n                'update_frequency': 'Quarterly'\n            },\n            'Dahua': {\n                'security_score': 6.8,\n                'common_vulnerabilities': ['default_credentials', 'unencrypted_communication'],\n                'products': ['IP Cameras', 'Video Intercom', 'Thermal Cameras'],\n                'update_frequency': 'Bi-annually'\n            },\n            'Cisco': {\n                'security_score': 8.5,\n                'common_vulnerabilities': ['firmware_outdated'],\n                'products': ['Network Equipment', 'IP Phones', 'Security Appliances'],\n                'update_frequency': 'Monthly'\n            },\n            'Nest': {\n                'security_score': 7.8,\n                'common_vulnerabilities': ['weak_authentication'],\n                'products': ['Smart Thermostats', 'Cameras', 'Doorbells'],\n                'update_frequency': 'Monthly'\n            },\n            'Philips': {\n                'security_score': 7.2,\n                'common_vulnerabilities': ['unencrypted_communication', 'open_ports'],\n                'products': ['Smart Lighting', 'Health Devices', 'Smart TVs'],\n                'update_frequency': 'Quarterly'\n            },\n            'Generic': {\n                'security_score': 4.5,\n                'common_vulnerabilities': ['default_credentials', 'firmware_outdated', 'weak_authentication'],\n                'products': ['Various IoT Devices'],\n                'update_frequency': 'Rarely'\n            }\n        }\n    \n    def _initialize_iot_devices(self):\n        \"\"\"Initialize IoT device inventory\"\"\"\n        device_types = [\n            'IP Camera', 'Smart Thermostat', 'Smart Lock', 'Industrial Sensor',\n            'Smart Light', 'Network Printer', 'Smart TV', 'Wireless Router',\n            'Smart Speaker', 'Security System', 'Environmental Monitor', 'Smart Plug'\n        ]\n        \n        manufacturers = list(self.device_manufacturers.keys())\n        \n        for i in range(35):\n            device_type = random.choice(device_types)\n            manufacturer = random.choice(manufacturers)\n            \n            device = {\n                'id': str(uuid.uuid4()),\n                'name': f'{device_type.replace(\" \", \"_\").lower()}_{i+1:02d}',\n                'type': device_type,\n                'manufacturer': manufacturer,\n                'model': f'{manufacturer}-{random.randint(100, 999)}',\n                'ip': f'192.168.1.{random.randint(100, 254)}',\n                'mac_address': self._generate_mac_address(),\n                'firmware_version': f'{random.randint(1, 5)}.{random.randint(0, 9)}.{random.randint(0, 9)}',\n                'last_seen': datetime.now() - timedelta(minutes=random.randint(0, 60)),\n                'security_status': random.choices(['secure', 'warning', 'vulnerable', 'unknown'], \n                                                weights=[0.4, 0.3, 0.2, 0.1])[0],\n                'security_score': random.uniform(1.0, 10.0),\n                'vulnerabilities': [],\n                'open_ports': random.sample([22, 23, 80, 443, 8080, 1900, 5353], random.randint(1, 4)),\n                'protocols': random.sample(['HTTP', 'HTTPS', 'SSH', 'Telnet', 'MQTT', 'CoAP'], random.randint(1, 3)),\n                'data_sensitivity': random.choice(['Low', 'Medium', 'High', 'Critical']),\n                'network_segment': random.choice(['IoT_VLAN', 'Guest_Network', 'Main_Network', 'DMZ']),\n                'last_update': datetime.now() - timedelta(days=random.randint(0, 365)),\n                'authentication_method': random.choice(['Password', 'Certificate', 'None', 'Multi-factor']),\n                'encryption_status': random.choice(['Encrypted', 'Unencrypted', 'Partial']),\n                'configuration_status': random.choice(['Default', 'Hardened', 'Custom']),\n                'compliance_status': random.choice(['Compliant', 'Non-compliant', 'Unknown']),\n                'criticality': random.choice(['Low', 'Medium', 'High', 'Critical']),\n                'location': random.choice(['Office', 'Warehouse', 'Reception', 'Server Room', 'Parking Lot']),\n                'operational_status': random.choice(['Online', 'Offline', 'Maintenance', 'Error'])\n            }\n            \n            # Assign vulnerabilities based on manufacturer and device type\n            device['vulnerabilities'] = self._assign_device_vulnerabilities(device)\n            \n            # Calculate final security score\n            device['security_score'] = self._calculate_device_security_score(device)\n            \n            # Set security status based on score\n            if device['security_score'] >= 8.0:\n                device['security_status'] = 'secure'\n            elif device['security_score'] >= 6.0:\n                device['security_status'] = 'warning'\n            else:\n                device['security_status'] = 'vulnerable'\n            \n            self.iot_devices.append(device)\n            \n            # Create device baseline\n            self.device_baselines[device['id']] = {\n                'normal_traffic_volume': random.uniform(1.0, 100.0),  # MB/day\n                'typical_connections': random.randint(1, 20),\n                'standard_ports': device['open_ports'].copy(),\n                'baseline_cpu_usage': random.uniform(5.0, 30.0),\n                'baseline_memory_usage': random.uniform(20.0, 60.0),\n                'normal_update_frequency': random.randint(30, 180),  # days\n                'expected_protocols': device['protocols'].copy()\n            }\n    \n    def _assign_device_vulnerabilities(self, device: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Assign vulnerabilities to device based on type and manufacturer\"\"\"\n        vulnerabilities = []\n        manufacturer_info = self.device_manufacturers.get(device['manufacturer'], {})\n        common_vulns = manufacturer_info.get('common_vulnerabilities', [])\n        \n        # Assign common vulnerabilities for manufacturer\n        for vuln_key in common_vulns:\n            if vuln_key in self.vulnerability_database:\n                vuln_info = self.vulnerability_database[vuln_key]\n                \n                if (vuln_info['affected_devices'] == ['all'] or \n                    any(dev_type in device['type'].lower() for dev_type in vuln_info['affected_devices'])):\n                    \n                    vulnerability = {\n                        'cve': f'CVE-2024-{random.randint(1000, 9999)}',\n                        'name': vuln_key.replace('_', ' ').title(),\n                        'description': vuln_info['description'],\n                        'severity': vuln_info['severity'],\n                        'cvss_score': vuln_info['cvss_score'],\n                        'remediation': vuln_info['remediation'],\n                        'discovered_date': datetime.now() - timedelta(days=random.randint(0, 90)),\n                        'patch_available': random.choice([True, False]),\n                        'exploitability': random.choice(['Low', 'Medium', 'High'])\n                    }\n                    vulnerabilities.append(vulnerability)\n        \n        # Random chance of additional vulnerabilities\n        for vuln_key, vuln_info in self.vulnerability_database.items():\n            if vuln_key not in common_vulns and random.random() < 0.1:  # 10% chance\n                if (vuln_info['affected_devices'] == ['all'] or \n                    any(dev_type in device['type'].lower() for dev_type in vuln_info['affected_devices'])):\n                    \n                    vulnerability = {\n                        'cve': f'CVE-2024-{random.randint(1000, 9999)}',\n                        'name': vuln_key.replace('_', ' ').title(),\n                        'description': vuln_info['description'],\n                        'severity': vuln_info['severity'],\n                        'cvss_score': vuln_info['cvss_score'],\n                        'remediation': vuln_info['remediation'],\n                        'discovered_date': datetime.now() - timedelta(days=random.randint(0, 90)),\n                        'patch_available': random.choice([True, False]),\n                        'exploitability': random.choice(['Low', 'Medium', 'High'])\n                    }\n                    vulnerabilities.append(vulnerability)\n        \n        return vulnerabilities\n    \n    def _calculate_device_security_score(self, device: Dict[str, Any]) -> float:\n        \"\"\"Calculate security score for device\"\"\"\n        base_score = self.device_manufacturers.get(device['manufacturer'], {}).get('security_score', 5.0)\n        \n        # Adjust for vulnerabilities\n        vuln_penalty = 0\n        for vuln in device['vulnerabilities']:\n            if vuln['severity'] == 'Critical':\n                vuln_penalty += 2.0\n            elif vuln['severity'] == 'High':\n                vuln_penalty += 1.5\n            elif vuln['severity'] == 'Medium':\n                vuln_penalty += 1.0\n            else:\n                vuln_penalty += 0.5\n        \n        # Adjust for configuration\n        config_bonus = 0\n        if device['configuration_status'] == 'Hardened':\n            config_bonus += 1.0\n        elif device['configuration_status'] == 'Custom':\n            config_bonus += 0.5\n        elif device['configuration_status'] == 'Default':\n            config_bonus -= 1.0\n        \n        # Adjust for encryption\n        if device['encryption_status'] == 'Encrypted':\n            config_bonus += 1.0\n        elif device['encryption_status'] == 'Unencrypted':\n            config_bonus -= 1.5\n        \n        # Adjust for authentication\n        auth_bonus = 0\n        if device['authentication_method'] == 'Multi-factor':\n            auth_bonus += 1.5\n        elif device['authentication_method'] == 'Certificate':\n            auth_bonus += 1.0\n        elif device['authentication_method'] == 'None':\n            auth_bonus -= 2.0\n        \n        # Calculate final score\n        final_score = base_score - vuln_penalty + config_bonus + auth_bonus\n        return max(0.0, min(10.0, final_score))\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get IoT monitoring statistics\"\"\"\n        total_devices = len(self.iot_devices)\n        \n        # Count by security status\n        secure_count = len([d for d in self.iot_devices if d['security_status'] == 'secure'])\n        warning_count = len([d for d in self.iot_devices if d['security_status'] == 'warning'])\n        vulnerable_count = len([d for d in self.iot_devices if d['security_status'] == 'vulnerable'])\n        \n        # Calculate average security score\n        if total_devices > 0:\n            avg_security_score = sum(d['security_score'] for d in self.iot_devices) / total_devices\n        else:\n            avg_security_score = 0.0\n        \n        # Count online/offline devices\n        online_count = len([d for d in self.iot_devices if d['operational_status'] == 'Online'])\n        offline_count = len([d for d in self.iot_devices if d['operational_status'] == 'Offline'])\n        \n        return {\n            'total_devices': total_devices,\n            'secure': secure_count,\n            'warning': warning_count,\n            'vulnerable': vulnerable_count,\n            'unknown': total_devices - secure_count - warning_count - vulnerable_count,\n            'security_score': round(avg_security_score, 1),\n            'online': online_count,\n            'offline': offline_count,\n            'maintenance': len([d for d in self.iot_devices if d['operational_status'] == 'Maintenance']),\n            'error': len([d for d in self.iot_devices if d['operational_status'] == 'Error']),\n            'critical_vulns': sum(len([v for v in d['vulnerabilities'] if v['severity'] == 'Critical']) \n                                for d in self.iot_devices),\n            'high_vulns': sum(len([v for v in d['vulnerabilities'] if v['severity'] == 'High']) \n                            for d in self.iot_devices),\n            'devices_need_update': len([d for d in self.iot_devices \n                                      if (datetime.now() - d['last_update']).days > 30])\n        }\n    \n    def get_devices(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all IoT devices\"\"\"\n        return self.iot_devices\n    \n    def scan_for_threats(self) -> Dict[str, Any]:\n        \"\"\"Scan IoT devices for security threats\"\"\"\n        threats = []\n        scan_start_time = datetime.now()\n        \n        for device in self.iot_devices:\n            # Check each threat pattern\n            for pattern_name, pattern_info in self.threat_patterns.items():\n                # Simulate threat detection\n                detection_probability = self._calculate_iot_threat_probability(device, pattern_name)\n                \n                if random.random() < detection_probability:\n                    threat = {\n                        'device_id': device['id'],\n                        'device_name': device['name'],\n                        'device_type': device['type'],\n                        'device_ip': device['ip'],\n                        'threat_pattern': pattern_name,\n                        'type': pattern_info['description'],\n                        'severity': pattern_info['severity'],\n                        'confidence': random.uniform(0.7, 0.95),\n                        'detection_time': datetime.now(),\n                        'indicators': pattern_info['indicators'],\n                        'mitigation_steps': pattern_info['mitigation'],\n                        'risk_score': self._calculate_threat_risk_score(device, pattern_info),\n                        'recommended_actions': self._get_threat_recommendations(device, pattern_info)\n                    }\n                    threats.append(threat)\n        \n        return {\n            'scan_time': scan_start_time,\n            'devices_scanned': len(self.iot_devices),\n            'threats': threats,\n            'threat_count': len(threats),\n            'critical_threats': len([t for t in threats if t['severity'] == 'Critical']),\n            'high_threats': len([t for t in threats if t['severity'] == 'High']),\n            'medium_threats': len([t for t in threats if t['severity'] == 'Medium']),\n            'scan_duration': (datetime.now() - scan_start_time).total_seconds()\n        }\n    \n    def get_compliance_data(self) -> Dict[str, int]:\n        \"\"\"Get device compliance distribution\"\"\"\n        compliance_counts = defaultdict(int)\n        \n        for device in self.iot_devices:\n            compliance_counts[device['compliance_status']] += 1\n        \n        return dict(compliance_counts)\n    \n    def get_device_by_id(self, device_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get specific device by ID\"\"\"\n        return next((d for d in self.iot_devices if d['id'] == device_id), None)\n    \n    def update_device_firmware(self, device_id: str) -> Dict[str, Any]:\n        \"\"\"Update device firmware\"\"\"\n        device = self.get_device_by_id(device_id)\n        \n        if not device:\n            return {'success': False, 'error': 'Device not found'}\n        \n        try:\n            # Simulate firmware update\n            old_version = device['firmware_version']\n            version_parts = old_version.split('.')\n            version_parts[-1] = str(int(version_parts[-1]) + 1)\n            new_version = '.'.join(version_parts)\n            \n            device['firmware_version'] = new_version\n            device['last_update'] = datetime.now()\n            \n            # Remove some vulnerabilities after update\n            if device['vulnerabilities']:\n                vulnerabilities_to_remove = random.randint(0, len(device['vulnerabilities']) // 2)\n                device['vulnerabilities'] = device['vulnerabilities'][vulnerabilities_to_remove:]\n            \n            # Recalculate security score\n            device['security_score'] = self._calculate_device_security_score(device)\n            \n            return {\n                'success': True,\n                'old_version': old_version,\n                'new_version': new_version,\n                'update_time': datetime.now(),\n                'vulnerabilities_fixed': vulnerabilities_to_remove\n            }\n            \n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    def quarantine_device(self, device_id: str, reason: str) -> Dict[str, Any]:\n        \"\"\"Quarantine suspicious IoT device\"\"\"\n        device = self.get_device_by_id(device_id)\n        \n        if not device:\n            return {'success': False, 'error': 'Device not found'}\n        \n        try:\n            device['operational_status'] = 'Quarantined'\n            device['quarantine_reason'] = reason\n            device['quarantine_time'] = datetime.now()\n            device['network_segment'] = 'QUARANTINE_VLAN'\n            \n            return {\n                'success': True,\n                'device_name': device['name'],\n                'quarantine_reason': reason,\n                'quarantine_time': datetime.now()\n            }\n            \n        except Exception as e:\n            return {'success': False, 'error': str(e)}\n    \n    def run_continuous_monitoring(self):\n        \"\"\"Run continuous IoT monitoring\"\"\"\n        if self.monitoring_active:\n            return\n        \n        self.monitoring_active = True\n        \n        def monitoring_loop():\n            while self.monitoring_active:\n                try:\n                    # Update device status\n                    for device in self.iot_devices:\n                        self._update_device_status(device)\n                    \n                    # Check for new threats\n                    self._check_for_anomalies()\n                    \n                    # Update compliance status\n                    self._update_compliance_status()\n                    \n                    time.sleep(120)  # Check every 2 minutes\n                    \n                except Exception as e:\n                    print(f\"IoT monitoring error: {e}\")\n                    time.sleep(300)\n        \n        monitoring_thread = threading.Thread(target=monitoring_loop, daemon=True)\n        monitoring_thread.start()\n    \n    def stop_monitoring(self):\n        \"\"\"Stop continuous monitoring\"\"\"\n        self.monitoring_active = False\n    \n    def _calculate_iot_threat_probability(self, device: Dict[str, Any], threat_pattern: str) -> float:\n        \"\"\"Calculate probability of specific threat for device\"\"\"\n        base_probabilities = {\n            'botnet_recruitment': 0.05,\n            'credential_brute_force': 0.08,\n            'firmware_tampering': 0.02,\n            'data_exfiltration': 0.03,\n            'denial_of_service': 0.06,\n            'physical_tampering': 0.01,\n            'man_in_the_middle': 0.04\n        }\n        \n        base_prob = base_probabilities.get(threat_pattern, 0.02)\n        \n        # Adjust based on device security score\n        security_factor = (10.0 - device['security_score']) / 10.0\n        \n        # Adjust based on device type (some are more targeted)\n        type_multipliers = {\n            'IP Camera': 1.5,\n            'Smart Lock': 1.3,\n            'Wireless Router': 1.4,\n            'Industrial Sensor': 1.2,\n            'Smart Thermostat': 0.8\n        }\n        \n        type_multiplier = type_multipliers.get(device['type'], 1.0)\n        \n        final_probability = min(0.3, base_prob * security_factor * type_multiplier)\n        \n        return final_probability\n    \n    def _calculate_threat_risk_score(self, device: Dict[str, Any], pattern_info: Dict[str, Any]) -> float:\n        \"\"\"Calculate risk score for detected threat\"\"\"\n        severity_scores = {\n            'Critical': 10.0,\n            'High': 7.5,\n            'Medium': 5.0,\n            'Low': 2.5\n        }\n        \n        base_score = severity_scores.get(pattern_info['severity'], 5.0)\n        \n        # Adjust for device criticality\n        criticality_multipliers = {\n            'Critical': 1.5,\n            'High': 1.3,\n            'Medium': 1.0,\n            'Low': 0.8\n        }\n        \n        criticality_multiplier = criticality_multipliers.get(device['criticality'], 1.0)\n        \n        # Adjust for data sensitivity\n        sensitivity_multipliers = {\n            'Critical': 1.4,\n            'High': 1.2,\n            'Medium': 1.0,\n            'Low': 0.9\n        }\n        \n        sensitivity_multiplier = sensitivity_multipliers.get(device['data_sensitivity'], 1.0)\n        \n        final_score = min(10.0, base_score * criticality_multiplier * sensitivity_multiplier)\n        \n        return round(final_score, 1)\n    \n    def _get_threat_recommendations(self, device: Dict[str, Any], pattern_info: Dict[str, Any]) -> List[str]:\n        \"\"\"Get recommendations for addressing threat\"\"\"\n        recommendations = pattern_info['mitigation'].copy()\n        \n        # Add device-specific recommendations\n        if device['configuration_status'] == 'Default':\n            recommendations.append('Change device default configuration')\n        \n        if device['authentication_method'] == 'None':\n            recommendations.append('Enable authentication on device')\n        \n        if device['encryption_status'] == 'Unencrypted':\n            recommendations.append('Enable encryption for device communications')\n        \n        if (datetime.now() - device['last_update']).days > 90:\n            recommendations.append('Update device firmware')\n        \n        return recommendations\n    \n    def _update_device_status(self, device: Dict[str, Any]):\n        \"\"\"Update individual device status\"\"\"\n        # Simulate status changes\n        if random.random() < 0.03:  # 3% chance of status change\n            current_status = device['operational_status']\n            \n            if current_status == 'Online':\n                device['operational_status'] = random.choices(\n                    ['Offline', 'Maintenance', 'Error'], \n                    weights=[0.5, 0.3, 0.2]\n                )[0]\n            elif current_status == 'Offline':\n                device['operational_status'] = random.choices(\n                    ['Online', 'Maintenance'], \n                    weights=[0.8, 0.2]\n                )[0]\n            elif current_status in ['Maintenance', 'Error']:\n                device['operational_status'] = random.choices(\n                    ['Online', 'Offline'], \n                    weights=[0.7, 0.3]\n                )[0]\n        \n        # Update last seen time for online devices\n        if device['operational_status'] == 'Online':\n            device['last_seen'] = datetime.now()\n    \n    def _check_for_anomalies(self):\n        \"\"\"Check for behavioral anomalies\"\"\"\n        for device in self.iot_devices:\n            baseline = self.device_baselines.get(device['id'])\n            if not baseline:\n                continue\n            \n            # Check for traffic anomalies\n            if random.random() < 0.02:  # 2% chance of anomaly\n                device['security_status'] = 'warning'\n                print(f\"Anomaly detected on device {device['name']}\")\n    \n    def _update_compliance_status(self):\n        \"\"\"Update device compliance status\"\"\"\n        for device in self.iot_devices:\n            # Check compliance factors\n            compliance_score = 1.0\n            \n            if device['configuration_status'] == 'Default':\n                compliance_score -= 0.3\n            \n            if device['authentication_method'] == 'None':\n                compliance_score -= 0.4\n            \n            if device['encryption_status'] == 'Unencrypted':\n                compliance_score -= 0.3\n            \n            if (datetime.now() - device['last_update']).days > 90:\n                compliance_score -= 0.2\n            \n            if compliance_score >= 0.8:\n                device['compliance_status'] = 'Compliant'\n            elif compliance_score >= 0.6:\n                device['compliance_status'] = 'Partially Compliant'\n            else:\n                device['compliance_status'] = 'Non-compliant'\n    \n    def _generate_mac_address(self) -> str:\n        \"\"\"Generate random MAC address\"\"\"\n        return ':'.join([f'{random.randint(0, 255):02x}' for _ in range(6)])\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get current IoT monitoring status\"\"\"\n        total_devices = len(self.iot_devices)\n        vulnerable_devices = len([d for d in self.iot_devices \n                                if d.get('security_status') in ['vulnerable', 'critical']])\n        \n        return {\n            'devices': total_devices,\n            'vulnerable_devices': vulnerable_devices,\n            'monitoring_active': self.monitoring_active,\n            'compliant_devices': len([d for d in self.iot_devices \n                                    if d.get('compliance_status') == 'Compliant'])\n        }\n","size_bytes":32322},"monitoring/mobile_monitor.py":{"content":"import random\nimport time\nimport threading\nimport hashlib\nimport uuid\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional, Tuple\nimport json\nfrom collections import defaultdict\nimport os\n\nclass MobileMonitor:\n    \"\"\"Mobile device security monitoring and management system\"\"\"\n    \n    def __init__(self):\n        self.mobile_devices = []\n        self.device_policies = self._load_security_policies()\n        self.threat_signatures = self._load_mobile_threat_signatures()\n        self.app_risk_database = self._load_app_risk_database()\n        self.compliance_rules = self._load_compliance_rules()\n        self.monitoring_active = False\n        self.device_baselines = {}\n        self.threat_feed = []\n        self.mdm_policies = self._load_mdm_policies()\n        self._initialize_mobile_devices()\n        \n    def _load_security_policies(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load mobile security policies\"\"\"\n        return {\n            'device_encryption': {\n                'required': True,\n                'algorithm': 'AES-256',\n                'enforcement': 'mandatory'\n            },\n            'passcode_policy': {\n                'min_length': 8,\n                'complexity_required': True,\n                'max_failed_attempts': 5,\n                'auto_lock_time': 300  # 5 minutes\n            },\n            'app_installation': {\n                'require_app_store_only': True,\n                'block_unknown_sources': True,\n                'app_reputation_check': True\n            },\n            'network_security': {\n                'block_untrusted_wifi': True,\n                'require_vpn': True,\n                'certificate_pinning': True\n            },\n            'data_protection': {\n                'prevent_screenshots': True,\n                'disable_clipboard_sharing': True,\n                'remote_wipe_enabled': True\n            },\n            'jailbreak_detection': {\n                'enabled': True,\n                'action': 'block_access',\n                'reporting': True\n            }\n        }\n    \n    def _load_mobile_threat_signatures(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load mobile-specific threat signatures\"\"\"\n        return {\n            'malicious_app': {\n                'indicators': ['suspicious_permissions', 'code_obfuscation', 'known_malware_signature'],\n                'severity': 'Critical',\n                'description': 'Malicious application detected on device',\n                'mitigation': ['remove_app', 'scan_device', 'update_policies']\n            },\n            'data_exfiltration': {\n                'indicators': ['large_data_uploads', 'unauthorized_api_calls', 'suspicious_network_traffic'],\n                'severity': 'Critical',\n                'description': 'Unauthorized data exfiltration detected',\n                'mitigation': ['block_network', 'investigate_app', 'notify_security_team']\n            },\n            'phishing_attempt': {\n                'indicators': ['fake_login_pages', 'credential_harvesting', 'suspicious_urls'],\n                'severity': 'High',\n                'description': 'Phishing attempt targeting mobile user',\n                'mitigation': ['block_url', 'user_education', 'update_filters']\n            },\n            'device_compromise': {\n                'indicators': ['jailbreak_detected', 'root_access', 'system_modification'],\n                'severity': 'Critical',\n                'description': 'Device security compromise detected',\n                'mitigation': ['isolate_device', 'remote_wipe', 'security_assessment']\n            },\n            'rogue_wifi': {\n                'indicators': ['evil_twin_ap', 'ssl_downgrade', 'dns_manipulation'],\n                'severity': 'High',\n                'description': 'Connection to rogue WiFi access point',\n                'mitigation': ['disconnect_wifi', 'vpn_enforcement', 'network_scanning']\n            },\n            'malicious_profile': {\n                'indicators': ['unauthorized_mdm', 'certificate_manipulation', 'policy_bypass'],\n                'severity': 'High',\n                'description': 'Malicious configuration profile installed',\n                'mitigation': ['remove_profile', 'verify_certificates', 'policy_audit']\n            },\n            'sms_phishing': {\n                'indicators': ['suspicious_links', 'credential_requests', 'urgency_tactics'],\n                'severity': 'Medium',\n                'description': 'SMS phishing attack detected',\n                'mitigation': ['block_sender', 'user_alert', 'security_training']\n            },\n            'app_side_loading': {\n                'indicators': ['unknown_source_install', 'unsigned_app', 'developer_mode'],\n                'severity': 'Medium',\n                'description': 'Unauthorized app installation from unknown source',\n                'mitigation': ['remove_app', 'disable_unknown_sources', 'policy_enforcement']\n            }\n        }\n    \n    def _load_app_risk_database(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load application risk assessment database\"\"\"\n        return {\n            'high_risk_categories': {\n                'file_sharing': {\n                    'risk_score': 8.0,\n                    'concerns': ['data_leakage', 'unauthorized_sharing', 'malware_vector'],\n                    'examples': ['BitTorrent', 'P2P apps']\n                },\n                'remote_access': {\n                    'risk_score': 9.0,\n                    'concerns': ['unauthorized_access', 'data_theft', 'backdoor'],\n                    'examples': ['TeamViewer', 'Remote desktop apps']\n                },\n                'social_media': {\n                    'risk_score': 6.0,\n                    'concerns': ['privacy_leak', 'social_engineering', 'phishing'],\n                    'examples': ['Facebook', 'Twitter', 'Instagram']\n                },\n                'messaging': {\n                    'risk_score': 5.0,\n                    'concerns': ['data_interception', 'malicious_links', 'spam'],\n                    'examples': ['WhatsApp', 'Telegram', 'Signal']\n                }\n            },\n            'permission_risks': {\n                'camera': {'risk_level': 'Medium', 'justification_required': True},\n                'microphone': {'risk_level': 'Medium', 'justification_required': True},\n                'location': {'risk_level': 'High', 'justification_required': True},\n                'contacts': {'risk_level': 'High', 'justification_required': True},\n                'sms': {'risk_level': 'High', 'justification_required': True},\n                'phone': {'risk_level': 'Medium', 'justification_required': False},\n                'storage': {'risk_level': 'Medium', 'justification_required': False},\n                'admin': {'risk_level': 'Critical', 'justification_required': True}\n            },\n            'trusted_publishers': {\n                'Apple': {'trust_score': 9.5, 'verification_required': False},\n                'Google': {'trust_score': 9.0, 'verification_required': False},\n                'Microsoft': {'trust_score': 9.0, 'verification_required': False},\n                'Adobe': {'trust_score': 8.5, 'verification_required': False},\n                'Unknown': {'trust_score': 2.0, 'verification_required': True}\n            }\n        }\n    \n    def _load_compliance_rules(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load compliance requirements\"\"\"\n        return {\n            'gdpr': {\n                'data_encryption': 'required',\n                'user_consent': 'explicit',\n                'data_retention': '24_months_max',\n                'breach_notification': '72_hours'\n            },\n            'hipaa': {\n                'device_encryption': 'required',\n                'access_logging': 'mandatory',\n                'data_segregation': 'required',\n                'audit_trail': 'comprehensive'\n            },\n            'pci_dss': {\n                'payment_app_security': 'validated',\n                'network_encryption': 'required',\n                'access_control': 'strict',\n                'regular_testing': 'quarterly'\n            },\n            'sox': {\n                'financial_data_protection': 'required',\n                'change_management': 'documented',\n                'access_reviews': 'regular',\n                'audit_preparation': 'continuous'\n            }\n        }\n    \n    def _load_mdm_policies(self) -> Dict[str, Any]:\n        \"\"\"Load Mobile Device Management policies\"\"\"\n        return {\n            'enrollment': {\n                'automatic': True,\n                'user_initiated': True,\n                'bulk_enrollment': True,\n                'zero_touch': True\n            },\n            'security': {\n                'enforce_encryption': True,\n                'require_passcode': True,\n                'detect_jailbreak': True,\n                'app_whitelisting': True,\n                'remote_wipe': True\n            },\n            'compliance': {\n                'policy_enforcement': 'strict',\n                'violation_actions': ['warn', 'restrict', 'wipe'],\n                'reporting_frequency': 'daily',\n                'audit_logging': True\n            },\n            'app_management': {\n                'app_distribution': 'managed',\n                'app_updates': 'automatic',\n                'app_removal': 'remote',\n                'app_configuration': 'centralized'\n            }\n        }\n    \n    def _initialize_mobile_devices(self):\n        \"\"\"Initialize mobile device inventory\"\"\"\n        platforms = ['iOS', 'Android', 'Windows Mobile']\n        device_types = ['iPhone', 'iPad', 'Android Phone', 'Android Tablet', 'Windows Phone']\n        os_versions = {\n            'iOS': ['16.0', '16.1', '16.2', '15.7', '15.6'],\n            'Android': ['13.0', '12.0', '11.0', '10.0', '9.0'],\n            'Windows Mobile': ['10.0', '8.1']\n        }\n        \n        users = [f'user{i:03d}' for i in range(1, 151)]\n        departments = ['Sales', 'Marketing', 'Engineering', 'HR', 'Finance', 'Operations', 'Legal']\n        \n        for i in range(45):\n            platform = random.choice(platforms)\n            device_type = random.choice([dt for dt in device_types if platform.lower() in dt.lower() or 'Phone' in dt or 'Tablet' in dt])\n            \n            device = {\n                'id': str(uuid.uuid4()),\n                'name': f'{device_type.replace(\" \", \"_\").lower()}_{i+1:02d}',\n                'platform': platform,\n                'device_type': device_type,\n                'os_version': random.choice(os_versions.get(platform, ['Unknown'])),\n                'model': f'{platform}-{random.randint(100, 999)}',\n                'serial_number': f'SN{random.randint(100000, 999999)}',\n                'imei': f'{random.randint(100000000000000, 999999999999999)}',\n                'user': random.choice(users),\n                'department': random.choice(departments),\n                'enrollment_date': datetime.now() - timedelta(days=random.randint(0, 365)),\n                'last_checkin': datetime.now() - timedelta(minutes=random.randint(0, 1440)),\n                'compliance_status': random.choices(['compliant', 'non_compliant', 'unknown'], \n                                                  weights=[0.7, 0.2, 0.1])[0],\n                'security_score': random.uniform(3.0, 10.0),\n                'is_jailbroken': random.choices([True, False], weights=[0.05, 0.95])[0],\n                'is_supervised': random.choices([True, False], weights=[0.8, 0.2])[0],\n                'passcode_enabled': random.choices([True, False], weights=[0.9, 0.1])[0],\n                'encryption_enabled': random.choices([True, False], weights=[0.85, 0.15])[0],\n                'location_services': random.choices([True, False], weights=[0.7, 0.3])[0],\n                'vpn_configured': random.choices([True, False], weights=[0.6, 0.4])[0],\n                'wifi_networks': random.randint(1, 10),\n                'installed_apps': [],\n                'threat_count': random.randint(0, 3),\n                'data_usage_mb': random.randint(100, 5000),\n                'battery_level': random.randint(10, 100),\n                'storage_used_gb': random.randint(5, 64),\n                'storage_total_gb': random.choice([32, 64, 128, 256, 512]),\n                'last_backup': datetime.now() - timedelta(days=random.randint(0, 30)),\n                'mdm_enrolled': random.choices([True, False], weights=[0.9, 0.1])[0],\n                'certificate_count': random.randint(2, 8),\n                'profile_count': random.randint(1, 5),\n                'location': random.choice(['Office', 'Remote', 'Travel', 'Home', 'Unknown']),\n                'network_type': random.choice(['WiFi', 'Cellular', 'VPN', 'Unknown'])\n            }\n            \n            # Generate installed apps\n            device['installed_apps'] = self._generate_installed_apps(device['platform'])\n            \n            # Adjust security score based on device configuration\n            device['security_score'] = self._calculate_device_security_score(device)\n            \n            # Set compliance status based on security score and policies\n            device['compliance_status'] = self._determine_compliance_status(device)\n            \n            self.mobile_devices.append(device)\n            \n            # Create device baseline\n            self.device_baselines[device['id']] = {\n                'normal_data_usage': device['data_usage_mb'],\n                'typical_app_count': len(device['installed_apps']),\n                'expected_location': device['location'],\n                'baseline_security_score': device['security_score'],\n                'normal_checkin_frequency': 24,  # hours\n                'expected_network_type': device['network_type']\n            }\n    \n    def _generate_installed_apps(self, platform: str) -> List[Dict[str, Any]]:\n        \"\"\"Generate realistic installed apps for device\"\"\"\n        apps = []\n        \n        # Common apps by platform\n        common_apps = {\n            'iOS': [\n                {'name': 'Safari', 'category': 'Browser', 'risk_level': 'low'},\n                {'name': 'Mail', 'category': 'Email', 'risk_level': 'low'},\n                {'name': 'Messages', 'category': 'Messaging', 'risk_level': 'low'},\n                {'name': 'Calendar', 'category': 'Productivity', 'risk_level': 'low'},\n                {'name': 'WhatsApp', 'category': 'Messaging', 'risk_level': 'medium'},\n                {'name': 'Slack', 'category': 'Business', 'risk_level': 'low'},\n                {'name': 'Zoom', 'category': 'Business', 'risk_level': 'medium'},\n                {'name': 'Dropbox', 'category': 'File Storage', 'risk_level': 'medium'},\n                {'name': 'Banking App', 'category': 'Finance', 'risk_level': 'high'},\n                {'name': 'VPN Client', 'category': 'Security', 'risk_level': 'low'}\n            ],\n            'Android': [\n                {'name': 'Chrome', 'category': 'Browser', 'risk_level': 'low'},\n                {'name': 'Gmail', 'category': 'Email', 'risk_level': 'low'},\n                {'name': 'Messages', 'category': 'Messaging', 'risk_level': 'low'},\n                {'name': 'Google Calendar', 'category': 'Productivity', 'risk_level': 'low'},\n                {'name': 'WhatsApp', 'category': 'Messaging', 'risk_level': 'medium'},\n                {'name': 'Slack', 'category': 'Business', 'risk_level': 'low'},\n                {'name': 'Microsoft Teams', 'category': 'Business', 'risk_level': 'low'},\n                {'name': 'Google Drive', 'category': 'File Storage', 'risk_level': 'medium'},\n                {'name': 'Banking App', 'category': 'Finance', 'risk_level': 'high'},\n                {'name': 'NordVPN', 'category': 'Security', 'risk_level': 'low'}\n            ]\n        }\n        \n        # Risky apps that might be installed\n        risky_apps = [\n            {'name': 'File Sharing App', 'category': 'File Sharing', 'risk_level': 'high'},\n            {'name': 'Remote Access Tool', 'category': 'Remote Access', 'risk_level': 'high'},\n            {'name': 'Unknown Publisher App', 'category': 'Utility', 'risk_level': 'high'},\n            {'name': 'Suspicious Game', 'category': 'Game', 'risk_level': 'medium'},\n            {'name': 'Ad-Supported App', 'category': 'Utility', 'risk_level': 'medium'}\n        ]\n        \n        # Select apps for this device\n        platform_apps = common_apps.get(platform, common_apps['iOS'])\n        \n        # Add common apps (most devices have these)\n        for app in platform_apps:\n            if random.random() < 0.8:  # 80% chance of having common apps\n                app_instance = app.copy()\n                app_instance.update({\n                    'version': f'{random.randint(1, 5)}.{random.randint(0, 9)}.{random.randint(0, 9)}',\n                    'install_date': datetime.now() - timedelta(days=random.randint(0, 365)),\n                    'last_used': datetime.now() - timedelta(hours=random.randint(0, 168)),\n                    'permissions': self._generate_app_permissions(),\n                    'data_usage_mb': random.randint(1, 500),\n                    'risk_reason': self._get_risk_reason(app['risk_level'])\n                })\n                apps.append(app_instance)\n        \n        # Occasionally add risky apps\n        for risky_app in risky_apps:\n            if random.random() < 0.1:  # 10% chance of risky apps\n                app_instance = risky_app.copy()\n                app_instance.update({\n                    'version': f'{random.randint(1, 3)}.{random.randint(0, 9)}',\n                    'install_date': datetime.now() - timedelta(days=random.randint(0, 30)),\n                    'last_used': datetime.now() - timedelta(hours=random.randint(0, 24)),\n                    'permissions': self._generate_app_permissions(high_risk=True),\n                    'data_usage_mb': random.randint(50, 1000),\n                    'risk_reason': self._get_risk_reason(risky_app['risk_level'])\n                })\n                apps.append(app_instance)\n        \n        return apps\n    \n    def _generate_app_permissions(self, high_risk: bool = False) -> List[str]:\n        \"\"\"Generate app permissions\"\"\"\n        all_permissions = [\n            'camera', 'microphone', 'location', 'contacts', 'sms', 'phone',\n            'storage', 'calendar', 'network', 'bluetooth', 'notifications'\n        ]\n        \n        if high_risk:\n            # High-risk apps tend to request more permissions\n            return random.sample(all_permissions, random.randint(5, len(all_permissions)))\n        else:\n            # Normal apps request fewer permissions\n            return random.sample(all_permissions, random.randint(1, 4))\n    \n    def _get_risk_reason(self, risk_level: str) -> str:\n        \"\"\"Get risk reason based on risk level\"\"\"\n        risk_reasons = {\n            'low': 'Trusted publisher, standard permissions',\n            'medium': 'Some elevated permissions required',\n            'high': 'Extensive permissions, potential security concerns'\n        }\n        return risk_reasons.get(risk_level, 'Unknown risk level')\n    \n    def _calculate_device_security_score(self, device: Dict[str, Any]) -> float:\n        \"\"\"Calculate security score for mobile device\"\"\"\n        score = 10.0  # Start with perfect score\n        \n        # Deduct for security issues\n        if device['is_jailbroken']:\n            score -= 4.0\n        \n        if not device['passcode_enabled']:\n            score -= 2.0\n        \n        if not device['encryption_enabled']:\n            score -= 2.0\n        \n        if not device['mdm_enrolled']:\n            score -= 1.5\n        \n        if not device['vpn_configured']:\n            score -= 1.0\n        \n        # Check for risky apps\n        risky_apps = [app for app in device['installed_apps'] if app['risk_level'] == 'high']\n        score -= len(risky_apps) * 0.5\n        \n        # OS version penalty (older versions are less secure)\n        os_version = device['os_version']\n        if os_version:\n            major_version = float(os_version.split('.')[0])\n            if device['platform'] == 'iOS' and major_version < 15:\n                score -= 1.0\n            elif device['platform'] == 'Android' and major_version < 12:\n                score -= 1.0\n        \n        return max(0.0, min(10.0, round(score, 1)))\n    \n    def _determine_compliance_status(self, device: Dict[str, Any]) -> str:\n        \"\"\"Determine compliance status based on policies\"\"\"\n        compliance_score = 1.0\n        \n        # Check against security policies\n        if not device['encryption_enabled']:\n            compliance_score -= 0.3\n        \n        if not device['passcode_enabled']:\n            compliance_score -= 0.2\n        \n        if device['is_jailbroken']:\n            compliance_score -= 0.4\n        \n        if not device['mdm_enrolled']:\n            compliance_score -= 0.2\n        \n        # Check app compliance\n        risky_apps = [app for app in device['installed_apps'] if app['risk_level'] == 'high']\n        compliance_score -= len(risky_apps) * 0.1\n        \n        if compliance_score >= 0.8:\n            return 'compliant'\n        elif compliance_score >= 0.6:\n            return 'partially_compliant'\n        else:\n            return 'non_compliant'\n    \n    def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get mobile device statistics\"\"\"\n        total_devices = len(self.mobile_devices)\n        \n        if total_devices == 0:\n            return {\n                'total_devices': 0,\n                'compliant': 0,\n                'non_compliant': 0,\n                'vulnerable': 0,\n                'security_score': 0.0\n            }\n        \n        # Count by compliance status\n        compliant_count = len([d for d in self.mobile_devices if d['compliance_status'] == 'compliant'])\n        non_compliant_count = len([d for d in self.mobile_devices if d['compliance_status'] in ['non_compliant', 'partially_compliant']])\n        \n        # Count vulnerable devices (jailbroken or low security score)\n        vulnerable_count = len([d for d in self.mobile_devices \n                              if d['is_jailbroken'] or d['security_score'] < 5.0])\n        \n        # Calculate average security score\n        avg_security_score = sum(d['security_score'] for d in self.mobile_devices) / total_devices\n        \n        # Platform distribution\n        platform_counts = defaultdict(int)\n        for device in self.mobile_devices:\n            platform_counts[device['platform']] += 1\n        \n        return {\n            'total_devices': total_devices,\n            'compliant': compliant_count,\n            'non_compliant': non_compliant_count,\n            'vulnerable': vulnerable_count,\n            'security_score': round(avg_security_score, 1),\n            'mdm_enrolled': len([d for d in self.mobile_devices if d['mdm_enrolled']]),\n            'jailbroken': len([d for d in self.mobile_devices if d['is_jailbroken']]),\n            'encryption_enabled': len([d for d in self.mobile_devices if d['encryption_enabled']]),\n            'vpn_configured': len([d for d in self.mobile_devices if d['vpn_configured']]),\n            'platform_distribution': dict(platform_counts),\n            'online': len([d for d in self.mobile_devices \n                         if (datetime.now() - d['last_checkin']).total_seconds() < 3600]),\n            'offline': len([d for d in self.mobile_devices \n                          if (datetime.now() - d['last_checkin']).total_seconds() >= 3600])\n        }\n    \n    def get_devices(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all mobile devices\"\"\"\n        return self.mobile_devices\n    \n    def get_threat_count(self, category: str) -> int:\n        \"\"\"Get threat count for specific category\"\"\"\n        # Simulate threat counts for different categories\n        threat_counts = {\n            'Malicious Apps': random.randint(0, 5),\n            'Phishing Attempts': random.randint(0, 10),\n            'Network Attacks': random.randint(0, 3),\n            'Data Leakage': random.randint(0, 2),\n            'Device Compromise': random.randint(0, 1)\n        }\n        \n        return threat_counts.get(category, 0)\n    \n    def update_security_policies(self) -> bool:\n        \"\"\"Update mobile security policies\"\"\"\n        try:\n            # Simulate policy update\n            self.device_policies['last_updated'] = datetime.now()\n            \n            # Apply policies to all devices\n            for device in self.mobile_devices:\n                self._apply_policies_to_device(device)\n            \n            return True\n        except Exception as e:\n            print(f\"Failed to update security policies: {e}\")\n            return False\n    \n    def get_compliance_data(self) -> Dict[str, int]:\n        \"\"\"Get device compliance distribution\"\"\"\n        compliance_counts = defaultdict(int)\n        \n        for device in self.mobile_devices:\n            compliance_counts[device['compliance_status']] += 1\n        \n        return dict(compliance_counts)\n    \n    def scan_device_for_threats(self, device_id: str) -> Dict[str, Any]:\n        \"\"\"Scan specific device for threats\"\"\"\n        device = next((d for d in self.mobile_devices if d['id'] == device_id), None)\n        \n        if not device:\n            return {'error': 'Device not found'}\n        \n        scan_results = {\n            'device_id': device_id,\n            'device_name': device['name'],\n            'scan_time': datetime.now(),\n            'threats_found': [],\n            'apps_scanned': len(device['installed_apps']),\n            'vulnerabilities': [],\n            'recommendations': []\n        }\n        \n        # Check for threats based on signatures\n        for signature_name, signature in self.threat_signatures.items():\n            if self._check_threat_signature(device, signature_name, signature):\n                threat = {\n                    'type': signature_name.replace('_', ' ').title(),\n                    'description': signature['description'],\n                    'severity': signature['severity'],\n                    'confidence': random.uniform(0.7, 0.95),\n                    'indicators': signature['indicators'],\n                    'mitigation': signature['mitigation']\n                }\n                scan_results['threats_found'].append(threat)\n        \n        # Check app risks\n        for app in device['installed_apps']:\n            if app['risk_level'] == 'high':\n                threat = {\n                    'type': 'High-Risk Application',\n                    'description': f'High-risk app detected: {app[\"name\"]}',\n                    'severity': 'Medium',\n                    'confidence': 0.8,\n                    'app_name': app['name'],\n                    'risk_reason': app['risk_reason']\n                }\n                scan_results['threats_found'].append(threat)\n        \n        # Generate recommendations\n        scan_results['recommendations'] = self._generate_security_recommendations(device)\n        \n        return scan_results\n    \n    def run_continuous_monitoring(self):\n        \"\"\"Run continuous mobile device monitoring\"\"\"\n        if self.monitoring_active:\n            return\n        \n        self.monitoring_active = True\n        \n        def monitoring_loop():\n            while self.monitoring_active:\n                try:\n                    # Update device status\n                    for device in self.mobile_devices:\n                        self._update_device_status(device)\n                    \n                    # Check for policy violations\n                    self._check_policy_violations()\n                    \n                    # Update threat intelligence\n                    self._update_threat_feed()\n                    \n                    time.sleep(180)  # Check every 3 minutes\n                    \n                except Exception as e:\n                    print(f\"Mobile monitoring error: {e}\")\n                    time.sleep(300)\n        \n        monitoring_thread = threading.Thread(target=monitoring_loop, daemon=True)\n        monitoring_thread.start()\n    \n    def stop_monitoring(self):\n        \"\"\"Stop continuous monitoring\"\"\"\n        self.monitoring_active = False\n    \n    def _check_threat_signature(self, device: Dict[str, Any], signature_name: str, signature: Dict[str, Any]) -> bool:\n        \"\"\"Check if device matches threat signature\"\"\"\n        # Simulate threat detection based on device characteristics\n        detection_probability = 0.05  # 5% base chance\n        \n        if signature_name == 'device_compromise' and device['is_jailbroken']:\n            return True\n        \n        if signature_name == 'malicious_app':\n            risky_apps = [app for app in device['installed_apps'] if app['risk_level'] == 'high']\n            return len(risky_apps) > 0\n        \n        if signature_name == 'data_exfiltration' and device['data_usage_mb'] > 3000:\n            return random.random() < 0.3\n        \n        return random.random() < detection_probability\n    \n    def _generate_security_recommendations(self, device: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate security recommendations for device\"\"\"\n        recommendations = []\n        \n        if device['is_jailbroken']:\n            recommendations.append('Device is jailbroken - consider replacement or additional monitoring')\n        \n        if not device['encryption_enabled']:\n            recommendations.append('Enable device encryption')\n        \n        if not device['passcode_enabled']:\n            recommendations.append('Enable device passcode/PIN')\n        \n        if not device['vpn_configured']:\n            recommendations.append('Configure VPN for secure network access')\n        \n        if not device['mdm_enrolled']:\n            recommendations.append('Enroll device in Mobile Device Management (MDM)')\n        \n        if device['security_score'] < 6.0:\n            recommendations.append('Device security score is low - review security settings')\n        \n        risky_apps = [app for app in device['installed_apps'] if app['risk_level'] == 'high']\n        if risky_apps:\n            recommendations.append(f'Remove or review {len(risky_apps)} high-risk applications')\n        \n        # Check OS version\n        if device['platform'] == 'iOS':\n            major_version = float(device['os_version'].split('.')[0])\n            if major_version < 15:\n                recommendations.append('Update iOS to latest version')\n        elif device['platform'] == 'Android':\n            major_version = float(device['os_version'].split('.')[0])\n            if major_version < 12:\n                recommendations.append('Update Android to latest version')\n        \n        return recommendations\n    \n    def _apply_policies_to_device(self, device: Dict[str, Any]):\n        \"\"\"Apply security policies to device\"\"\"\n        # Simulate policy enforcement\n        policies = self.device_policies\n        \n        # Encryption policy\n        if policies['device_encryption']['required'] and not device['encryption_enabled']:\n            device['compliance_status'] = 'non_compliant'\n        \n        # Passcode policy\n        if not device['passcode_enabled']:\n            device['compliance_status'] = 'non_compliant'\n        \n        # Jailbreak detection\n        if policies['jailbreak_detection']['enabled'] and device['is_jailbroken']:\n            device['compliance_status'] = 'non_compliant'\n    \n    def _update_device_status(self, device: Dict[str, Any]):\n        \"\"\"Update individual device status\"\"\"\n        # Simulate device check-ins\n        if random.random() < 0.1:  # 10% chance of check-in\n            device['last_checkin'] = datetime.now()\n        \n        # Simulate security score changes\n        if random.random() < 0.05:  # 5% chance of score change\n            device['security_score'] = max(0.0, min(10.0, \n                device['security_score'] + random.uniform(-0.5, 0.5)))\n        \n        # Update compliance status\n        device['compliance_status'] = self._determine_compliance_status(device)\n    \n    def _check_policy_violations(self):\n        \"\"\"Check for policy violations across all devices\"\"\"\n        for device in self.mobile_devices:\n            violations = []\n            \n            if device['is_jailbroken']:\n                violations.append('Device jailbreak detected')\n            \n            if not device['encryption_enabled']:\n                violations.append('Device encryption not enabled')\n            \n            if not device['passcode_enabled']:\n                violations.append('Device passcode not set')\n            \n            if violations:\n                device['policy_violations'] = violations\n                device['compliance_status'] = 'non_compliant'\n    \n    def _update_threat_feed(self):\n        \"\"\"Update mobile threat intelligence feed\"\"\"\n        # Simulate threat feed updates\n        new_threats = [\n            f'Mobile malware variant {random.randint(1000, 9999)} detected',\n            f'Phishing campaign targeting {random.choice([\"banking\", \"social media\", \"corporate\"])} users',\n            f'Zero-day vulnerability in {random.choice([\"iOS\", \"Android\"])} version {random.randint(10, 16)}'\n        ]\n        \n        if random.random() < 0.1:  # 10% chance of new threat\n            self.threat_feed.append({\n                'timestamp': datetime.now(),\n                'threat': random.choice(new_threats),\n                'severity': random.choice(['Low', 'Medium', 'High', 'Critical'])\n            })\n        \n        # Keep only recent threats (last 24 hours)\n        cutoff_time = datetime.now() - timedelta(hours=24)\n        self.threat_feed = [t for t in self.threat_feed if t['timestamp'] > cutoff_time]\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get current mobile device monitoring status\"\"\"\n        total_devices = len(self.mobile_devices)\n        compliant_devices = len([d for d in self.mobile_devices \n                               if d.get('compliance_status') == 'compliant'])\n        \n        return {\n            'devices': total_devices,\n            'compliant_devices': compliant_devices,\n            'monitoring_active': self.monitoring_active,\n            'policy_violations': len([d for d in self.mobile_devices \n                                    if d.get('policy_violations', [])])\n        }\n","size_bytes":34368},"monitoring/network_monitor.py":{"content":"import random\nimport time\nimport socket\nimport threading\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional, Tuple\nimport ipaddress\nimport json\nimport hashlib\nfrom collections import defaultdict\n\nclass NetworkMonitor:\n    \"\"\"Advanced network security monitoring and intrusion detection system\"\"\"\n    \n    def __init__(self):\n        self.monitored_networks = ['192.168.1.0/24', '10.0.0.0/8', '172.16.0.0/12']\n        self.active_connections = {}\n        self.blocked_ips = []\n        self.network_devices = []\n        self.traffic_stats = defaultdict(int)\n        self.intrusion_signatures = self._load_intrusion_signatures()\n        self.monitoring_active = False\n        self.threat_indicators = []\n        self.network_topology = self._initialize_network_topology()\n        self.ids_rules = self._load_ids_rules()\n        self.baseline_traffic = self._establish_traffic_baseline()\n        \n    def _load_intrusion_signatures(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Load network intrusion detection signatures\"\"\"\n        return {\n            'port_scan': {\n                'pattern': 'multiple_port_connections',\n                'threshold': 50,\n                'timeframe': 60,  # seconds\n                'severity': 'Medium',\n                'description': 'Port scanning activity detected'\n            },\n            'ddos_tcp_syn': {\n                'pattern': 'high_syn_rate',\n                'threshold': 1000,\n                'timeframe': 10,\n                'severity': 'Critical',\n                'description': 'TCP SYN flood attack detected'\n            },\n            'ddos_udp': {\n                'pattern': 'high_udp_rate',\n                'threshold': 5000,\n                'timeframe': 10,\n                'severity': 'Critical',\n                'description': 'UDP flood attack detected'\n            },\n            'brute_force': {\n                'pattern': 'failed_authentication',\n                'threshold': 20,\n                'timeframe': 300,\n                'severity': 'High',\n                'description': 'Brute force authentication attack'\n            },\n            'lateral_movement': {\n                'pattern': 'internal_scanning',\n                'threshold': 10,\n                'timeframe': 120,\n                'severity': 'High',\n                'description': 'Potential lateral movement detected'\n            },\n            'data_exfiltration': {\n                'pattern': 'large_outbound_transfer',\n                'threshold': 100,  # MB\n                'timeframe': 60,\n                'severity': 'Critical',\n                'description': 'Large data transfer detected'\n            },\n            'dns_tunneling': {\n                'pattern': 'abnormal_dns_traffic',\n                'threshold': 100,\n                'timeframe': 60,\n                'severity': 'High',\n                'description': 'DNS tunneling activity detected'\n            },\n            'c2_communication': {\n                'pattern': 'periodic_beaconing',\n                'threshold': 5,\n                'timeframe': 3600,\n                'severity': 'Critical',\n                'description': 'Command and control communication detected'\n            }\n        }\n    \n    def _initialize_network_topology(self) -> Dict[str, Any]:\n        \"\"\"Initialize network topology data\"\"\"\n        devices = []\n        connections = []\n        \n        # Generate network devices\n        device_types = ['firewall', 'switch', 'router', 'server', 'workstation', 'printer', 'camera']\n        statuses = ['healthy', 'suspicious', 'compromised']\n        \n        for i in range(20):\n            device = {\n                'id': f'device_{i+1}',\n                'name': f'{random.choice(device_types)}-{i+1:02d}',\n                'type': random.choice(device_types),\n                'ip': f'192.168.1.{random.randint(10, 250)}',\n                'mac': self._generate_mac_address(),\n                'status': random.choices(statuses, weights=[0.8, 0.15, 0.05])[0],\n                'x': random.randint(50, 950),\n                'y': random.randint(50, 450),\n                'last_seen': datetime.now() - timedelta(minutes=random.randint(0, 60)),\n                'open_ports': random.sample([22, 23, 80, 135, 139, 443, 445, 3389], random.randint(2, 5)),\n                'os': random.choice(['Windows 10', 'Windows Server 2019', 'Ubuntu 20.04', 'CentOS 7', 'macOS']),\n                'vulnerability_score': random.uniform(1.0, 10.0)\n            }\n            devices.append(device)\n        \n        # Generate connections between devices\n        for i in range(30):\n            device1 = random.choice(devices)\n            device2 = random.choice(devices)\n            if device1 != device2:\n                connection = {\n                    'id': f'conn_{i+1}',\n                    'source': device1['id'],\n                    'target': device2['id'],\n                    'x1': device1['x'],\n                    'y1': device1['y'],\n                    'x2': device2['x'],\n                    'y2': device2['y'],\n                    'protocol': random.choice(['TCP', 'UDP', 'ICMP']),\n                    'port': random.choice([80, 443, 22, 3389, 445]),\n                    'status': random.choice(['active', 'idle', 'blocked']),\n                    'bandwidth_usage': random.uniform(0.1, 100.0)  # Mbps\n                }\n                connections.append(connection)\n        \n        return {\n            'devices': devices,\n            'connections': connections\n        }\n    \n    def _load_ids_rules(self) -> Dict[str, Any]:\n        \"\"\"Load Intrusion Detection System rules\"\"\"\n        return {\n            'active': True,\n            'last_update': '2024-08-23',\n            'rules_count': 15247,\n            'signature_version': '2024.08.23.001',\n            'categories': {\n                'malware': 3456,\n                'exploit': 2789,\n                'policy_violation': 1234,\n                'trojan': 2345,\n                'worm': 567,\n                'backdoor': 890,\n                'spyware': 1234,\n                'adware': 456,\n                'rootkit': 234,\n                'other': 3042\n            }\n        }\n    \n    def _establish_traffic_baseline(self) -> Dict[str, float]:\n        \"\"\"Establish network traffic baseline\"\"\"\n        return {\n            'average_packets_per_second': 1250.5,\n            'average_bytes_per_second': 2048000.0,\n            'peak_packets_per_second': 5000.0,\n            'peak_bytes_per_second': 10485760.0,\n            'connection_rate': 50.0,\n            'protocol_distribution': {\n                'TCP': 0.70,\n                'UDP': 0.25,\n                'ICMP': 0.05\n            },\n            'port_distribution': {\n                '80': 0.30,\n                '443': 0.35,\n                '22': 0.05,\n                '21': 0.02,\n                '25': 0.03,\n                'others': 0.25\n            }\n        }\n    \n    def get_network_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get current network statistics\"\"\"\n        current_time = datetime.now()\n        \n        # Calculate dynamic statistics\n        base_connections = 450\n        connection_variance = random.randint(-50, 100)\n        current_connections = max(0, base_connections + connection_variance)\n        \n        # Simulate blocked threats based on time and activity\n        base_blocked = 127\n        blocked_variance = random.randint(-20, 50)\n        blocked_threats = max(0, base_blocked + blocked_variance)\n        \n        # Calculate health score\n        health_factors = []\n        health_factors.append(min(10.0, (1000 - current_connections) / 100))  # Connection load\n        health_factors.append(min(10.0, (200 - blocked_threats) / 20))  # Threat activity\n        health_factors.append(random.uniform(7.0, 9.5))  # Random component\n        \n        health_score = sum(health_factors) / len(health_factors)\n        \n        return {\n            'networks': len(self.monitored_networks),\n            'connections': current_connections,\n            'blocked_threats': blocked_threats,\n            'health_score': round(health_score, 1),\n            'total_devices': len(self.network_topology['devices']),\n            'active_devices': len([d for d in self.network_topology['devices'] if d['status'] == 'healthy']),\n            'suspicious_devices': len([d for d in self.network_topology['devices'] if d['status'] == 'suspicious']),\n            'compromised_devices': len([d for d in self.network_topology['devices'] if d['status'] == 'compromised']),\n            'bandwidth_utilization': random.uniform(15.0, 85.0),\n            'packet_loss_rate': random.uniform(0.01, 0.5),\n            'average_latency_ms': random.uniform(1.0, 50.0)\n        }\n    \n    def analyze_traffic(self) -> Dict[str, Any]:\n        \"\"\"Analyze current network traffic for threats\"\"\"\n        current_time = datetime.now()\n        analysis_results = {\n            'threats': [],\n            'analysis_time': current_time,\n            'packets_analyzed': random.randint(10000, 100000),\n            'anomalies_detected': 0,\n            'baseline_deviation': {}\n        }\n        \n        # Simulate threat detection based on signatures\n        for signature_name, signature in self.intrusion_signatures.items():\n            detection_probability = self._calculate_detection_probability(signature_name)\n            \n            if random.random() < detection_probability:\n                threat = self._generate_threat_from_signature(signature_name, signature)\n                analysis_results['threats'].append(threat)\n                analysis_results['anomalies_detected'] += 1\n        \n        # Calculate baseline deviations\n        current_baseline = self._get_current_traffic_metrics()\n        for metric, current_value in current_baseline.items():\n            baseline_value = self.baseline_traffic.get(metric, 0)\n            if baseline_value > 0:\n                deviation = ((current_value - baseline_value) / baseline_value) * 100\n                analysis_results['baseline_deviation'][metric] = round(deviation, 2)\n        \n        return analysis_results\n    \n    def get_ids_status(self) -> Dict[str, Any]:\n        \"\"\"Get Intrusion Detection System status\"\"\"\n        return {\n            'active': self.ids_rules['active'],\n            'last_update': self.ids_rules['last_update'],\n            'rules_count': self.ids_rules['rules_count'],\n            'signature_version': self.ids_rules['signature_version'],\n            'engine_version': '6.4.2',\n            'performance': {\n                'packets_processed_per_second': random.randint(50000, 200000),\n                'cpu_utilization': random.uniform(15.0, 45.0),\n                'memory_usage': random.uniform(512.0, 2048.0),\n                'disk_usage_gb': random.uniform(50.0, 500.0)\n            },\n            'categories': self.ids_rules['categories']\n        }\n    \n    def update_signatures(self) -> bool:\n        \"\"\"Update IDS signatures\"\"\"\n        try:\n            # Simulate signature update process\n            time.sleep(1)  # Simulate download time\n            \n            self.ids_rules['last_update'] = datetime.now().strftime('%Y-%m-%d')\n            self.ids_rules['rules_count'] += random.randint(10, 100)\n            self.ids_rules['signature_version'] = f\"2024.{datetime.now().strftime('%m.%d')}.001\"\n            \n            return True\n        except Exception as e:\n            print(f\"Failed to update signatures: {e}\")\n            return False\n    \n    def get_network_topology(self) -> Dict[str, Any]:\n        \"\"\"Get network topology for visualization\"\"\"\n        return self.network_topology\n    \n    def get_blocked_ips(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of blocked IP addresses\"\"\"\n        blocked_ips_data = []\n        \n        # Generate some blocked IPs with context\n        for i in range(random.randint(5, 20)):\n            ip = f\"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}\"\n            \n            blocked_ip = {\n                'ip_address': ip,\n                'country': random.choice(['CN', 'RU', 'KP', 'IR', 'BR', 'IN', 'US', 'DE']),\n                'threat_type': random.choice(['Port Scan', 'Brute Force', 'DDoS', 'Malware C2', 'Spam']),\n                'blocked_time': datetime.now() - timedelta(hours=random.randint(0, 24)),\n                'block_count': random.randint(1, 1000),\n                'reason': random.choice([\n                    'Multiple port scan attempts',\n                    'Brute force SSH attacks',\n                    'DDoS participation',\n                    'Malware command and control',\n                    'Spam relay activity',\n                    'SQL injection attempts',\n                    'Known botnet member'\n                ]),\n                'severity': random.choice(['Low', 'Medium', 'High', 'Critical']),\n                'auto_blocked': random.choice([True, False]),\n                'expires': datetime.now() + timedelta(hours=random.randint(1, 168))  # 1 hour to 1 week\n            }\n            \n            blocked_ips_data.append(blocked_ip)\n        \n        # Sort by blocked time (most recent first)\n        blocked_ips_data.sort(key=lambda x: x['blocked_time'], reverse=True)\n        \n        return blocked_ips_data\n    \n    def block_ip(self, ip_address: str, reason: str) -> bool:\n        \"\"\"Block an IP address\"\"\"\n        try:\n            # Validate IP address\n            ipaddress.ip_address(ip_address)\n            \n            # Add to blocked IPs\n            block_entry = {\n                'ip_address': ip_address,\n                'reason': reason,\n                'blocked_time': datetime.now(),\n                'blocked_by': 'Manual',\n                'severity': 'High',\n                'auto_blocked': False\n            }\n            \n            self.blocked_ips.append(block_entry)\n            \n            # In a real implementation, this would interface with firewall/router\n            print(f\"Blocked IP {ip_address}: {reason}\")\n            \n            return True\n            \n        except ValueError:\n            print(f\"Invalid IP address: {ip_address}\")\n            return False\n        except Exception as e:\n            print(f\"Failed to block IP {ip_address}: {e}\")\n            return False\n    \n    def unblock_ip(self, ip_address: str) -> bool:\n        \"\"\"Unblock an IP address\"\"\"\n        try:\n            # Remove from blocked IPs list\n            self.blocked_ips = [ip for ip in self.blocked_ips if ip['ip_address'] != ip_address]\n            \n            # In a real implementation, this would interface with firewall/router\n            print(f\"Unblocked IP {ip_address}\")\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Failed to unblock IP {ip_address}: {e}\")\n            return False\n    \n    def run_continuous_monitoring(self):\n        \"\"\"Run continuous network monitoring\"\"\"\n        if self.monitoring_active:\n            return  # Already running\n        \n        self.monitoring_active = True\n        \n        def monitoring_loop():\n            while self.monitoring_active:\n                try:\n                    # Perform network analysis\n                    analysis_results = self.analyze_traffic()\n                    \n                    # Process any detected threats\n                    for threat in analysis_results['threats']:\n                        self._process_network_threat(threat)\n                    \n                    # Update network statistics\n                    self._update_traffic_stats()\n                    \n                    # Check for device status changes\n                    self._update_device_status()\n                    \n                    # Sleep for monitoring interval\n                    time.sleep(30)  # Check every 30 seconds\n                    \n                except Exception as e:\n                    print(f\"Network monitoring error: {e}\")\n                    time.sleep(60)  # Wait longer on error\n        \n        # Start monitoring in separate thread\n        monitoring_thread = threading.Thread(target=monitoring_loop, daemon=True)\n        monitoring_thread.start()\n    \n    def stop_monitoring(self):\n        \"\"\"Stop continuous network monitoring\"\"\"\n        self.monitoring_active = False\n    \n    def get_traffic_analytics(self) -> Dict[str, Any]:\n        \"\"\"Get detailed traffic analytics\"\"\"\n        return {\n            'total_packets_24h': random.randint(1000000, 10000000),\n            'total_bytes_24h': random.randint(1000000000, 100000000000),  # 1GB to 100GB\n            'top_protocols': {\n                'HTTP': random.randint(100000, 1000000),\n                'HTTPS': random.randint(200000, 2000000),\n                'SSH': random.randint(1000, 10000),\n                'FTP': random.randint(500, 5000),\n                'SMTP': random.randint(5000, 50000),\n                'DNS': random.randint(10000, 100000)\n            },\n            'top_destinations': [\n                {'ip': '8.8.8.8', 'packets': random.randint(10000, 100000), 'description': 'Google DNS'},\n                {'ip': '1.1.1.1', 'packets': random.randint(5000, 50000), 'description': 'Cloudflare DNS'},\n                {'ip': '208.67.222.222', 'packets': random.randint(3000, 30000), 'description': 'OpenDNS'},\n            ],\n            'bandwidth_usage_history': self._generate_bandwidth_history(),\n            'connection_types': {\n                'Inbound': random.randint(1000, 10000),\n                'Outbound': random.randint(5000, 50000),\n                'Internal': random.randint(2000, 20000)\n            },\n            'geographic_distribution': {\n                'US': random.randint(100000, 500000),\n                'EU': random.randint(50000, 200000),\n                'AS': random.randint(30000, 150000),\n                'Other': random.randint(20000, 100000)\n            }\n        }\n    \n    def _calculate_detection_probability(self, signature_name: str) -> float:\n        \"\"\"Calculate probability of detecting a specific threat type\"\"\"\n        base_probabilities = {\n            'port_scan': 0.15,\n            'ddos_tcp_syn': 0.05,\n            'ddos_udp': 0.03,\n            'brute_force': 0.08,\n            'lateral_movement': 0.02,\n            'data_exfiltration': 0.01,\n            'dns_tunneling': 0.01,\n            'c2_communication': 0.005\n        }\n        \n        return base_probabilities.get(signature_name, 0.01)\n    \n    def _generate_threat_from_signature(self, signature_name: str, signature: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Generate a threat detection from signature\"\"\"\n        source_ips = [f\"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}\" for _ in range(random.randint(1, 5))]\n        target_ips = [f\"192.168.1.{random.randint(10, 250)}\" for _ in range(random.randint(1, 3))]\n        \n        threat = {\n            'type': signature_name.replace('_', ' ').title(),\n            'description': signature['description'],\n            'severity': signature['severity'],\n            'confidence': random.uniform(0.7, 0.95),\n            'source_ips': source_ips,\n            'target_ips': target_ips,\n            'timestamp': datetime.now(),\n            'signature_id': f\"SIG-{hashlib.md5(signature_name.encode()).hexdigest()[:8].upper()}\",\n            'packet_count': random.randint(signature['threshold'], signature['threshold'] * 5),\n            'duration': random.randint(signature['timeframe'], signature['timeframe'] * 3),\n            'protocols': random.sample(['TCP', 'UDP', 'ICMP'], random.randint(1, 2)),\n            'ports': random.sample([21, 22, 23, 25, 53, 80, 135, 139, 443, 445, 3389], random.randint(1, 5))\n        }\n        \n        # Add specific details based on threat type\n        if signature_name == 'port_scan':\n            threat['scan_type'] = random.choice(['TCP SYN', 'TCP Connect', 'UDP', 'Stealth'])\n            threat['ports_scanned'] = random.randint(100, 65535)\n            \n        elif signature_name == 'brute_force':\n            threat['service'] = random.choice(['SSH', 'RDP', 'FTP', 'Telnet'])\n            threat['attempts'] = random.randint(20, 1000)\n            threat['success_rate'] = random.uniform(0.0, 0.05)\n            \n        elif 'ddos' in signature_name:\n            threat['attack_vector'] = signature_name.replace('ddos_', '').upper()\n            threat['bandwidth_consumed'] = random.randint(10, 1000)  # Mbps\n            threat['amplification_factor'] = random.uniform(1.0, 50.0)\n            \n        elif signature_name == 'data_exfiltration':\n            threat['data_volume_mb'] = random.randint(100, 10000)\n            threat['destination_country'] = random.choice(['CN', 'RU', 'KP', 'IR'])\n            threat['encryption_detected'] = random.choice([True, False])\n        \n        return threat\n    \n    def _get_current_traffic_metrics(self) -> Dict[str, float]:\n        \"\"\"Get current traffic metrics for baseline comparison\"\"\"\n        return {\n            'packets_per_second': random.uniform(800, 2000),\n            'bytes_per_second': random.uniform(1500000, 3000000),\n            'connection_rate': random.uniform(30, 80),\n            'tcp_ratio': random.uniform(0.65, 0.75),\n            'udp_ratio': random.uniform(0.20, 0.30),\n            'icmp_ratio': random.uniform(0.03, 0.08)\n        }\n    \n    def _process_network_threat(self, threat: Dict[str, Any]):\n        \"\"\"Process detected network threat\"\"\"\n        # Add to threat indicators\n        self.threat_indicators.append(threat)\n        \n        # Auto-block high severity threats\n        if threat['severity'] in ['Critical', 'High'] and threat['confidence'] > 0.8:\n            for source_ip in threat['source_ips']:\n                self.block_ip(source_ip, f\"Auto-blocked: {threat['description']}\")\n        \n        # Log the threat\n        print(f\"Network threat detected: {threat['type']} from {threat['source_ips']}\")\n    \n    def _update_traffic_stats(self):\n        \"\"\"Update traffic statistics\"\"\"\n        current_time = datetime.now()\n        \n        # Update packet counters\n        self.traffic_stats['total_packets'] += random.randint(1000, 10000)\n        self.traffic_stats['total_bytes'] += random.randint(1000000, 10000000)\n        \n        # Update connection counters\n        self.traffic_stats['total_connections'] += random.randint(10, 100)\n        \n        # Update protocol distribution\n        self.traffic_stats['tcp_packets'] += random.randint(700, 7000)\n        self.traffic_stats['udp_packets'] += random.randint(200, 2500)\n        self.traffic_stats['icmp_packets'] += random.randint(50, 500)\n    \n    def _update_device_status(self):\n        \"\"\"Update network device status\"\"\"\n        for device in self.network_topology['devices']:\n            # Small chance of status change\n            if random.random() < 0.05:  # 5% chance\n                if device['status'] == 'healthy':\n                    device['status'] = random.choice(['suspicious'] * 8 + ['compromised'] * 1)\n                elif device['status'] == 'suspicious':\n                    device['status'] = random.choice(['healthy'] * 7 + ['compromised'] * 1)\n                elif device['status'] == 'compromised':\n                    device['status'] = random.choice(['healthy'] * 3 + ['suspicious'] * 5)\n            \n            # Update last seen time\n            if random.random() < 0.8:  # 80% chance device is active\n                device['last_seen'] = datetime.now()\n    \n    def _generate_bandwidth_history(self) -> List[Dict[str, Any]]:\n        \"\"\"Generate bandwidth usage history for charts\"\"\"\n        history = []\n        current_time = datetime.now()\n        \n        for i in range(24):  # Last 24 hours\n            timestamp = current_time - timedelta(hours=23-i)\n            bandwidth = random.uniform(10.0, 90.0)  # Percentage\n            \n            history.append({\n                'timestamp': timestamp.strftime('%H:%M'),\n                'inbound_mbps': bandwidth * random.uniform(0.3, 0.7),\n                'outbound_mbps': bandwidth * random.uniform(0.3, 0.7),\n                'total_mbps': bandwidth\n            })\n        \n        return history\n    \n    def _generate_mac_address(self) -> str:\n        \"\"\"Generate random MAC address\"\"\"\n        return ':'.join([f'{random.randint(0, 255):02x}' for _ in range(6)])\n    \n    def get_status(self) -> Dict[str, Any]:\n        \"\"\"Get current network monitoring status\"\"\"\n        total_devices = len(self.network_devices)\n        blocked_ips = len(self.blocked_ips)\n        active_threats = len([t for t in self.threat_indicators \n                            if t.get('status') == 'active'])\n        \n        return {\n            'devices': total_devices,\n            'blocked_ips': blocked_ips,\n            'active_threats': active_threats,\n            'monitoring_active': self.monitoring_active,\n            'total_connections': len(self.active_connections)\n        }\n","size_bytes":24986},"simulation/attack_simulator.py":{"content":"import random\nimport time\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\nfrom enum import Enum\nimport json\n\nclass AttackCategory(Enum):\n    RANSOMWARE = \"Ransomware Simulation\"\n    NETWORK_INTRUSION = \"Network Intrusion\"\n    ENDPOINT_ATTACKS = \"Endpoint Attacks\"\n    SOCIAL_ENGINEERING = \"Social Engineering\"\n    APT = \"Advanced Persistent Threats\"\n\nclass AttackSimulator:\n    \"\"\"Advanced attack simulation framework for testing security defenses\"\"\"\n    \n    def __init__(self):\n        self.simulation_history = []\n        self.active_simulations = {}\n        self.detection_callbacks = []\n        self.attack_templates = self._initialize_attack_templates()\n        \n    def _initialize_attack_templates(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Initialize attack simulation templates\"\"\"\n        return {\n            AttackCategory.RANSOMWARE.value: {\n                \"File Encryption Simulation\": {\n                    \"description\": \"Simulate ransomware file encryption behavior\",\n                    \"techniques\": [\"file_modification\", \"registry_changes\", \"network_communication\"],\n                    \"indicators\": [\"suspicious_file_extensions\", \"high_file_operations\", \"crypto_api_calls\"],\n                    \"duration_range\": (60, 300),  # 1-5 minutes\n                    \"intensity_scaling\": True\n                },\n                \"Registry Modification\": {\n                    \"description\": \"Simulate ransomware registry modifications\",\n                    \"techniques\": [\"registry_persistence\", \"security_settings_change\", \"bootup_modifications\"],\n                    \"indicators\": [\"registry_keys_modified\", \"security_policy_changes\"],\n                    \"duration_range\": (30, 120),\n                    \"intensity_scaling\": True\n                },\n                \"Network Share Encryption\": {\n                    \"description\": \"Simulate network share encryption attacks\",\n                    \"techniques\": [\"network_enumeration\", \"share_access\", \"remote_encryption\"],\n                    \"indicators\": [\"network_scanning\", \"smb_traffic\", \"file_operations\"],\n                    \"duration_range\": (120, 600),\n                    \"intensity_scaling\": True\n                }\n            },\n            AttackCategory.NETWORK_INTRUSION.value: {\n                \"Port Scanning\": {\n                    \"description\": \"Simulate network port scanning activity\",\n                    \"techniques\": [\"tcp_scan\", \"udp_scan\", \"stealth_scan\"],\n                    \"indicators\": [\"connection_attempts\", \"icmp_traffic\", \"failed_connections\"],\n                    \"duration_range\": (60, 300),\n                    \"intensity_scaling\": True\n                },\n                \"DDoS Simulation\": {\n                    \"description\": \"Simulate distributed denial of service attack\",\n                    \"techniques\": [\"connection_flooding\", \"bandwidth_consumption\", \"resource_exhaustion\"],\n                    \"indicators\": [\"high_connection_count\", \"bandwidth_spikes\", \"response_time_degradation\"],\n                    \"duration_range\": (120, 600),\n                    \"intensity_scaling\": True\n                },\n                \"Man-in-the-Middle\": {\n                    \"description\": \"Simulate MITM attack scenarios\",\n                    \"techniques\": [\"arp_spoofing\", \"dns_poisoning\", \"ssl_interception\"],\n                    \"indicators\": [\"arp_anomalies\", \"certificate_warnings\", \"traffic_redirection\"],\n                    \"duration_range\": (300, 900),\n                    \"intensity_scaling\": False\n                }\n            },\n            AttackCategory.ENDPOINT_ATTACKS.value: {\n                \"Malware Simulation\": {\n                    \"description\": \"Simulate malware execution patterns\",\n                    \"techniques\": [\"process_injection\", \"api_hooking\", \"file_system_changes\"],\n                    \"indicators\": [\"suspicious_processes\", \"memory_anomalies\", \"file_modifications\"],\n                    \"duration_range\": (180, 600),\n                    \"intensity_scaling\": True\n                },\n                \"Process Injection\": {\n                    \"description\": \"Simulate process injection techniques\",\n                    \"techniques\": [\"dll_injection\", \"process_hollowing\", \"thread_execution_hijacking\"],\n                    \"indicators\": [\"unusual_process_behavior\", \"memory_modifications\", \"api_calls\"],\n                    \"duration_range\": (60, 240),\n                    \"intensity_scaling\": False\n                },\n                \"Privilege Escalation\": {\n                    \"description\": \"Simulate privilege escalation attempts\",\n                    \"techniques\": [\"token_manipulation\", \"exploit_vulnerabilities\", \"bypass_uac\"],\n                    \"indicators\": [\"privilege_changes\", \"system_calls\", \"security_log_events\"],\n                    \"duration_range\": (30, 120),\n                    \"intensity_scaling\": False\n                }\n            },\n            AttackCategory.SOCIAL_ENGINEERING.value: {\n                \"Phishing Simulation\": {\n                    \"description\": \"Simulate phishing attack campaigns\",\n                    \"techniques\": [\"email_spoofing\", \"credential_harvesting\", \"malicious_attachments\"],\n                    \"indicators\": [\"suspicious_emails\", \"credential_submissions\", \"file_downloads\"],\n                    \"duration_range\": (1800, 3600),  # 30-60 minutes\n                    \"intensity_scaling\": False\n                },\n                \"USB Drop Attack\": {\n                    \"description\": \"Simulate USB-based attack vectors\",\n                    \"techniques\": [\"autorun_exploitation\", \"payload_execution\", \"lateral_movement\"],\n                    \"indicators\": [\"usb_device_connections\", \"autorun_execution\", \"file_transfers\"],\n                    \"duration_range\": (300, 900),\n                    \"intensity_scaling\": False\n                },\n                \"Physical Breach\": {\n                    \"description\": \"Simulate physical security breaches\",\n                    \"techniques\": [\"unauthorized_access\", \"device_tampering\", \"information_gathering\"],\n                    \"indicators\": [\"access_card_usage\", \"camera_blind_spots\", \"device_connections\"],\n                    \"duration_range\": (600, 1800),\n                    \"intensity_scaling\": False\n                }\n            },\n            AttackCategory.APT.value: {\n                \"Lateral Movement\": {\n                    \"description\": \"Simulate advanced persistent threat lateral movement\",\n                    \"techniques\": [\"credential_theft\", \"remote_execution\", \"persistence_mechanisms\"],\n                    \"indicators\": [\"cross_system_logins\", \"unusual_network_traffic\", \"persistence_artifacts\"],\n                    \"duration_range\": (1800, 7200),  # 30 minutes to 2 hours\n                    \"intensity_scaling\": False\n                },\n                \"Data Exfiltration\": {\n                    \"description\": \"Simulate covert data exfiltration\",\n                    \"techniques\": [\"data_compression\", \"encryption\", \"covert_channels\"],\n                    \"indicators\": [\"large_data_transfers\", \"encrypted_traffic\", \"unusual_protocols\"],\n                    \"duration_range\": (3600, 10800),  # 1-3 hours\n                    \"intensity_scaling\": True\n                },\n                \"Command & Control\": {\n                    \"description\": \"Simulate C2 communication channels\",\n                    \"techniques\": [\"encrypted_communication\", \"domain_fronting\", \"steganography\"],\n                    \"indicators\": [\"periodic_network_beacons\", \"encrypted_payloads\", \"dns_queries\"],\n                    \"duration_range\": (7200, 28800),  # 2-8 hours\n                    \"intensity_scaling\": False\n                }\n            }\n        }\n    \n    def run_simulation(self, \n                      category: str,\n                      attack_type: str, \n                      target: str,\n                      intensity: int,\n                      duration: str,\n                      safe_mode: bool = True) -> Dict[str, Any]:\n        \"\"\"Run attack simulation and return results\"\"\"\n        \n        simulation_id = self._generate_simulation_id()\n        start_time = datetime.now()\n        \n        # Get attack template\n        if category not in self.attack_templates or attack_type not in self.attack_templates[category]:\n            raise ValueError(f\"Unknown attack type: {category}/{attack_type}\")\n        \n        template = self.attack_templates[category][attack_type]\n        \n        # Parse duration\n        duration_seconds = self._parse_duration(duration)\n        \n        # Create simulation context\n        simulation_context = {\n            'id': simulation_id,\n            'category': category,\n            'attack_type': attack_type,\n            'target': target,\n            'intensity': intensity,\n            'duration_seconds': duration_seconds,\n            'safe_mode': safe_mode,\n            'start_time': start_time,\n            'template': template\n        }\n        \n        # Register active simulation\n        self.active_simulations[simulation_id] = simulation_context\n        \n        try:\n            # Execute simulation\n            results = self._execute_simulation(simulation_context)\n            \n            # Record simulation results\n            simulation_record = {\n                'simulation_id': simulation_id,\n                'timestamp': start_time,\n                'category': category,\n                'attack_type': attack_type,\n                'target': target,\n                'intensity': intensity,\n                'duration': duration,\n                'safe_mode': safe_mode,\n                'attacks_launched': results['attacks_launched'],\n                'attacks_detected': results['attacks_detected'],\n                'attacks_blocked': results['attacks_blocked'],\n                'detection_rate': results['detection_rate'],\n                'avg_detection_time': results['avg_detection_time'],\n                'fastest_response': results['fastest_response'],\n                'slowest_response': results['slowest_response'],\n                'missed_attacks': results['missed_attacks'],\n                'response_actions': results['response_actions'],\n                'false_positives': results.get('false_positives', 0),\n                'true_positives': results.get('true_positives', 0),\n                'avg_response_time': results['avg_detection_time']  # For compatibility\n            }\n            \n            self.simulation_history.append(simulation_record)\n            \n            return results\n            \n        finally:\n            # Clean up active simulation\n            if simulation_id in self.active_simulations:\n                del self.active_simulations[simulation_id]\n    \n    def _execute_simulation(self, context: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Execute the actual simulation\"\"\"\n        template = context['template']\n        intensity = context['intensity']\n        duration_seconds = context['duration_seconds']\n        safe_mode = context['safe_mode']\n        \n        # Calculate number of attack vectors based on intensity\n        base_attacks = len(template['techniques'])\n        attack_multiplier = max(1, intensity // 2)\n        total_attacks = base_attacks * attack_multiplier\n        \n        # Simulate attack execution\n        attacks_launched = 0\n        attacks_detected = 0\n        attacks_blocked = 0\n        detection_times = []\n        response_actions = []\n        missed_attacks = []\n        \n        attack_interval = duration_seconds / total_attacks if total_attacks > 0 else 1\n        \n        for i in range(total_attacks):\n            technique = template['techniques'][i % len(template['techniques'])]\n            \n            # Launch attack\n            attacks_launched += 1\n            attack_result = self._simulate_attack_technique(\n                context['attack_type'], \n                technique, \n                intensity, \n                safe_mode\n            )\n            \n            # Simulate detection\n            detection_result = self._simulate_detection(attack_result, template)\n            \n            if detection_result['detected']:\n                attacks_detected += 1\n                detection_times.append(detection_result['detection_time'])\n                \n                # Simulate response\n                response_result = self._simulate_response(attack_result, detection_result)\n                \n                if response_result['blocked']:\n                    attacks_blocked += 1\n                \n                if response_result['actions']:\n                    response_actions.extend(response_result['actions'])\n            else:\n                missed_attacks.append(technique)\n            \n            # Sleep between attacks (shortened for simulation)\n            if not safe_mode and i < total_attacks - 1:\n                time.sleep(min(attack_interval, 0.1))  # Cap at 0.1 seconds for demo\n        \n        # Calculate metrics\n        detection_rate = (attacks_detected / attacks_launched * 100) if attacks_launched > 0 else 0\n        avg_detection_time = sum(detection_times) / len(detection_times) if detection_times else 0\n        fastest_response = min(detection_times) if detection_times else 0\n        slowest_response = max(detection_times) if detection_times else 0\n        \n        # Remove duplicates from response actions\n        response_actions = list(set(response_actions))\n        \n        return {\n            'attacks_launched': attacks_launched,\n            'attacks_detected': attacks_detected,\n            'attacks_blocked': attacks_blocked,\n            'detection_rate': round(detection_rate, 1),\n            'avg_detection_time': f\"{avg_detection_time:.1f}s\",\n            'fastest_response': f\"{fastest_response:.1f}s\",\n            'slowest_response': f\"{slowest_response:.1f}s\",\n            'missed_attacks': missed_attacks,\n            'response_actions': response_actions,\n            'true_positives': attacks_detected,\n            'false_positives': max(0, attacks_detected - attacks_blocked)\n        }\n    \n    def _simulate_attack_technique(self, attack_type: str, technique: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate individual attack technique\"\"\"\n        \n        # Base attack characteristics\n        attack_result = {\n            'attack_type': attack_type,\n            'technique': technique,\n            'intensity': intensity,\n            'safe_mode': safe_mode,\n            'timestamp': datetime.now(),\n            'success_probability': self._calculate_success_probability(technique, intensity),\n            'stealth_level': self._calculate_stealth_level(technique),\n            'impact_level': self._calculate_impact_level(attack_type, technique),\n            'artifacts': self._generate_attack_artifacts(technique)\n        }\n        \n        # Technique-specific simulation\n        if technique == \"file_modification\":\n            attack_result.update(self._simulate_file_operations(intensity, safe_mode))\n        elif technique == \"network_communication\":\n            attack_result.update(self._simulate_network_activity(intensity, safe_mode))\n        elif technique == \"process_injection\":\n            attack_result.update(self._simulate_process_operations(intensity, safe_mode))\n        elif technique == \"registry_changes\":\n            attack_result.update(self._simulate_registry_operations(intensity, safe_mode))\n        elif technique == \"credential_theft\":\n            attack_result.update(self._simulate_credential_operations(intensity, safe_mode))\n        \n        return attack_result\n    \n    def _simulate_detection(self, attack_result: Dict[str, Any], template: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Simulate security system detection of attack\"\"\"\n        \n        # Base detection probability based on attack characteristics\n        base_detection_prob = 0.7  # 70% base detection rate\n        \n        # Adjust based on stealth level\n        stealth_penalty = attack_result['stealth_level'] * 0.2\n        detection_prob = max(0.1, base_detection_prob - stealth_penalty)\n        \n        # Adjust based on attack intensity (higher intensity = easier to detect)\n        intensity_bonus = (attack_result['intensity'] - 5) * 0.05\n        detection_prob = min(0.95, detection_prob + intensity_bonus)\n        \n        # Random detection decision\n        detected = random.random() < detection_prob\n        \n        # Calculate detection time (in seconds)\n        if detected:\n            base_time = random.uniform(1.0, 30.0)  # 1-30 seconds base\n            \n            # Faster detection for high-intensity attacks\n            intensity_factor = max(0.1, 1.0 - (attack_result['intensity'] - 1) * 0.1)\n            detection_time = base_time * intensity_factor\n            \n            # Add some randomness\n            detection_time += random.uniform(-5.0, 5.0)\n            detection_time = max(0.1, detection_time)\n        else:\n            detection_time = 0\n        \n        return {\n            'detected': detected,\n            'detection_time': detection_time,\n            'detection_probability': detection_prob,\n            'detection_method': self._get_detection_method(attack_result['technique']),\n            'confidence': random.uniform(0.6, 0.95) if detected else 0.0\n        }\n    \n    def _simulate_response(self, attack_result: Dict[str, Any], detection_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Simulate security system response to detected attack\"\"\"\n        \n        if not detection_result['detected']:\n            return {'blocked': False, 'actions': []}\n        \n        # Determine response actions based on attack type and severity\n        attack_type = attack_result['attack_type']\n        technique = attack_result['technique']\n        impact_level = attack_result['impact_level']\n        \n        possible_actions = []\n        \n        # File-based attacks\n        if technique in ['file_modification', 'file_encryption']:\n            possible_actions.extend(['Quarantine file', 'Block file operations', 'Restore from backup'])\n        \n        # Network-based attacks\n        elif technique in ['network_communication', 'connection_flooding']:\n            possible_actions.extend(['Block IP address', 'Rate limit connections', 'Activate DDoS protection'])\n        \n        # Process-based attacks\n        elif technique in ['process_injection', 'suspicious_processes']:\n            possible_actions.extend(['Terminate process', 'Isolate system', 'Memory dump'])\n        \n        # Registry-based attacks\n        elif technique in ['registry_changes', 'persistence_mechanisms']:\n            possible_actions.extend(['Revert registry changes', 'Block registry access', 'System restore'])\n        \n        # Credential-based attacks\n        elif technique in ['credential_theft', 'credential_harvesting']:\n            possible_actions.extend(['Force password reset', 'Disable account', 'Enable MFA'])\n        \n        # Generic actions\n        possible_actions.extend(['Generate alert', 'Log incident', 'Notify security team'])\n        \n        # Determine which actions are taken\n        actions_taken = []\n        block_probability = 0.8 if impact_level == 'High' else 0.6 if impact_level == 'Medium' else 0.4\n        \n        # Always generate alert for detected attacks\n        actions_taken.append('Generate alert')\n        \n        # Response based on impact level\n        if impact_level == 'High':\n            # High impact attacks get aggressive response\n            num_actions = random.randint(2, 4)\n            actions_taken.extend(random.sample(possible_actions[:-3], min(num_actions, len(possible_actions[:-3]))))\n        elif impact_level == 'Medium':\n            # Medium impact attacks get moderate response\n            num_actions = random.randint(1, 3)\n            actions_taken.extend(random.sample(possible_actions[:-3], min(num_actions, len(possible_actions[:-3]))))\n        else:\n            # Low impact attacks get minimal response\n            if random.random() < 0.5:\n                actions_taken.append(random.choice(possible_actions[:-3]))\n        \n        # Determine if attack was successfully blocked\n        blocked = random.random() < block_probability\n        \n        return {\n            'blocked': blocked,\n            'actions': list(set(actions_taken)),  # Remove duplicates\n            'response_time': detection_result['detection_time'] + random.uniform(1.0, 10.0),\n            'effectiveness': random.uniform(0.7, 0.95) if blocked else random.uniform(0.3, 0.7)\n        }\n    \n    def get_simulation_history(self) -> List[Dict[str, Any]]:\n        \"\"\"Get history of all simulations\"\"\"\n        return sorted(self.simulation_history, key=lambda x: x['timestamp'], reverse=True)\n    \n    def get_active_simulations(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Get currently active simulations\"\"\"\n        return self.active_simulations.copy()\n    \n    def stop_simulation(self, simulation_id: str) -> bool:\n        \"\"\"Stop an active simulation\"\"\"\n        if simulation_id in self.active_simulations:\n            del self.active_simulations[simulation_id]\n            return True\n        return False\n    \n    def _generate_simulation_id(self) -> str:\n        \"\"\"Generate unique simulation ID\"\"\"\n        timestamp = str(datetime.now().timestamp())\n        return f\"SIM-{hashlib.md5(timestamp.encode()).hexdigest()[:8].upper()}\"\n    \n    def _parse_duration(self, duration: str) -> int:\n        \"\"\"Parse duration string to seconds\"\"\"\n        duration_map = {\n            \"1 minute\": 60,\n            \"5 minutes\": 300,\n            \"15 minutes\": 900,\n            \"30 minutes\": 1800\n        }\n        return duration_map.get(duration, 300)  # Default to 5 minutes\n    \n    def _calculate_success_probability(self, technique: str, intensity: int) -> float:\n        \"\"\"Calculate probability of attack technique success\"\"\"\n        base_probabilities = {\n            'file_modification': 0.8,\n            'network_communication': 0.7,\n            'process_injection': 0.6,\n            'registry_changes': 0.9,\n            'credential_theft': 0.5,\n            'privilege_escalation': 0.4,\n            'lateral_movement': 0.6\n        }\n        \n        base_prob = base_probabilities.get(technique, 0.5)\n        intensity_bonus = (intensity - 5) * 0.05  # Intensity 1-10, centered at 5\n        \n        return max(0.1, min(0.95, base_prob + intensity_bonus))\n    \n    def _calculate_stealth_level(self, technique: str) -> float:\n        \"\"\"Calculate stealth level of attack technique (0.0 = obvious, 1.0 = very stealthy)\"\"\"\n        stealth_levels = {\n            'file_modification': 0.3,\n            'network_communication': 0.6,\n            'process_injection': 0.8,\n            'registry_changes': 0.4,\n            'credential_theft': 0.7,\n            'privilege_escalation': 0.5,\n            'lateral_movement': 0.9\n        }\n        \n        return stealth_levels.get(technique, 0.5)\n    \n    def _calculate_impact_level(self, attack_type: str, technique: str) -> str:\n        \"\"\"Calculate impact level of attack\"\"\"\n        high_impact_attacks = ['Data Exfiltration', 'File Encryption Simulation', 'System Compromise']\n        high_impact_techniques = ['file_modification', 'credential_theft', 'privilege_escalation']\n        \n        if attack_type in high_impact_attacks or technique in high_impact_techniques:\n            return 'High'\n        elif 'Simulation' in attack_type or technique in ['network_communication', 'registry_changes']:\n            return 'Medium'\n        else:\n            return 'Low'\n    \n    def _generate_attack_artifacts(self, technique: str) -> List[str]:\n        \"\"\"Generate artifacts that would be left by attack technique\"\"\"\n        artifact_map = {\n            'file_modification': ['Modified file timestamps', 'Unusual file extensions', 'Large file operations'],\n            'network_communication': ['Suspicious network connections', 'Encrypted traffic', 'DNS queries'],\n            'process_injection': ['Memory modifications', 'Unusual process behavior', 'API call patterns'],\n            'registry_changes': ['Registry key modifications', 'Startup program changes', 'Security setting changes'],\n            'credential_theft': ['Authentication attempts', 'Credential access patterns', 'Account enumeration']\n        }\n        \n        return artifact_map.get(technique, ['Generic attack artifacts'])\n    \n    def _get_detection_method(self, technique: str) -> str:\n        \"\"\"Get the detection method used for technique\"\"\"\n        detection_methods = {\n            'file_modification': 'File System Monitoring',\n            'network_communication': 'Network Traffic Analysis',\n            'process_injection': 'Behavioral Analysis',\n            'registry_changes': 'Registry Monitoring',\n            'credential_theft': 'Authentication Log Analysis',\n            'privilege_escalation': 'Privilege Monitoring',\n            'lateral_movement': 'Network Behavior Analysis'\n        }\n        \n        return detection_methods.get(technique, 'Signature-based Detection')\n    \n    # Technique-specific simulation methods\n    def _simulate_file_operations(self, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate file system operations\"\"\"\n        num_files = intensity * 10\n        \n        return {\n            'files_affected': num_files,\n            'operations_per_second': intensity * 5,\n            'file_types': ['documents', 'images', 'databases'] if intensity > 5 else ['temp_files'],\n            'total_size_mb': num_files * random.randint(1, 10)\n        }\n    \n    def _simulate_network_activity(self, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate network activity\"\"\"\n        connections = intensity * 20\n        \n        return {\n            'connections_made': connections,\n            'bandwidth_used_mb': intensity * 5,\n            'destination_ports': [80, 443, 8080] if intensity > 3 else [80],\n            'protocols': ['HTTP', 'HTTPS', 'TCP']\n        }\n    \n    def _simulate_process_operations(self, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate process-related operations\"\"\"\n        return {\n            'processes_spawned': intensity,\n            'memory_allocated_mb': intensity * 50,\n            'cpu_usage_percent': min(100, intensity * 10),\n            'api_calls_made': intensity * 100\n        }\n    \n    def _simulate_registry_operations(self, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate registry operations\"\"\"\n        return {\n            'registry_keys_modified': intensity * 5,\n            'registry_values_changed': intensity * 10,\n            'startup_entries_added': min(intensity, 3),\n            'security_policies_changed': min(intensity // 2, 5)\n        }\n    \n    def _simulate_credential_operations(self, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate credential-related operations\"\"\"\n        return {\n            'accounts_targeted': min(intensity * 2, 50),\n            'login_attempts': intensity * 20,\n            'credential_sources_accessed': ['SAM', 'LSASS', 'Registry'] if intensity > 7 else ['Registry'],\n            'hash_extraction_attempts': min(intensity, 10)\n        }\n","size_bytes":27339},"simulation/network_attacks.py":{"content":"import random\nimport socket\nimport time\nimport threading\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Tuple\nimport struct\nimport json\n\nclass NetworkAttackSimulator:\n    \"\"\"Network-based attack simulation for testing network security defenses\"\"\"\n    \n    def __init__(self):\n        self.active_attacks = {}\n        self.attack_results = []\n        self.target_networks = ['192.168.1.0/24', '10.0.0.0/8', '172.16.0.0/12']\n        \n    def simulate_ddos_attack(self, target_ip: str, duration: int, intensity: int, safe_mode: bool = True) -> Dict[str, Any]:\n        \"\"\"Simulate Distributed Denial of Service attack\"\"\"\n        \n        attack_id = f\"ddos_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        start_time = datetime.now()\n        \n        attack_config = {\n            'attack_id': attack_id,\n            'attack_type': 'DDoS',\n            'target_ip': target_ip,\n            'duration': duration,\n            'intensity': intensity,\n            'safe_mode': safe_mode,\n            'start_time': start_time\n        }\n        \n        results = {\n            'attack_id': attack_id,\n            'attack_type': 'DDoS',\n            'target': target_ip,\n            'start_time': start_time,\n            'packets_sent': 0,\n            'connections_made': 0,\n            'bandwidth_consumed_mbps': 0,\n            'attack_vectors': [],\n            'detection_triggers': [],\n            'mitigation_triggered': False,\n            'success_rate': 0.0\n        }\n        \n        try:\n            # Simulate different DDoS attack vectors\n            vectors = self._get_ddos_vectors(intensity)\n            results['attack_vectors'] = vectors\n            \n            for vector in vectors:\n                vector_results = self._simulate_ddos_vector(vector, target_ip, duration, safe_mode)\n                results['packets_sent'] += vector_results['packets_sent']\n                results['connections_made'] += vector_results['connections_made']\n                results['bandwidth_consumed_mbps'] += vector_results['bandwidth_mbps']\n                results['detection_triggers'].extend(vector_results['detection_triggers'])\n            \n            # Calculate success metrics\n            results['success_rate'] = self._calculate_ddos_success_rate(results, intensity)\n            results['mitigation_triggered'] = results['success_rate'] < 0.3  # Mitigation if low success\n            \n            results['end_time'] = datetime.now()\n            results['actual_duration'] = (results['end_time'] - start_time).total_seconds()\n            results['simulation_success'] = True\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n            results['end_time'] = datetime.now()\n        \n        self.attack_results.append(results)\n        return results\n    \n    def simulate_port_scan(self, target_network: str, scan_type: str, intensity: int, safe_mode: bool = True) -> Dict[str, Any]:\n        \"\"\"Simulate network port scanning attack\"\"\"\n        \n        attack_id = f\"portscan_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        start_time = datetime.now()\n        \n        results = {\n            'attack_id': attack_id,\n            'attack_type': 'Port Scan',\n            'scan_type': scan_type,\n            'target_network': target_network,\n            'intensity': intensity,\n            'safe_mode': safe_mode,\n            'start_time': start_time,\n            'hosts_scanned': 0,\n            'ports_scanned': 0,\n            'open_ports_found': [],\n            'services_identified': [],\n            'detection_triggers': [],\n            'stealth_level': 0.0\n        }\n        \n        try:\n            # Simulate different scan types\n            if scan_type == \"TCP SYN Scan\":\n                scan_results = self._simulate_syn_scan(target_network, intensity, safe_mode)\n            elif scan_type == \"UDP Scan\":\n                scan_results = self._simulate_udp_scan(target_network, intensity, safe_mode)\n            elif scan_type == \"Stealth Scan\":\n                scan_results = self._simulate_stealth_scan(target_network, intensity, safe_mode)\n            elif scan_type == \"Comprehensive Scan\":\n                scan_results = self._simulate_comprehensive_scan(target_network, intensity, safe_mode)\n            else:\n                scan_results = self._simulate_basic_scan(target_network, intensity, safe_mode)\n            \n            results.update(scan_results)\n            results['simulation_success'] = True\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n        \n        results['end_time'] = datetime.now()\n        results['scan_duration'] = (results['end_time'] - start_time).total_seconds()\n        \n        self.attack_results.append(results)\n        return results\n    \n    def simulate_mitm_attack(self, target_network: str, attack_method: str, duration: int, safe_mode: bool = True) -> Dict[str, Any]:\n        \"\"\"Simulate Man-in-the-Middle attack\"\"\"\n        \n        attack_id = f\"mitm_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        start_time = datetime.now()\n        \n        results = {\n            'attack_id': attack_id,\n            'attack_type': 'Man-in-the-Middle',\n            'attack_method': attack_method,\n            'target_network': target_network,\n            'duration': duration,\n            'safe_mode': safe_mode,\n            'start_time': start_time,\n            'victims_targeted': 0,\n            'traffic_intercepted_mb': 0,\n            'credentials_captured': 0,\n            'certificates_spoofed': 0,\n            'detection_triggers': [],\n            'attack_success': False\n        }\n        \n        try:\n            if attack_method == \"ARP Spoofing\":\n                mitm_results = self._simulate_arp_spoofing(target_network, duration, safe_mode)\n            elif attack_method == \"DNS Spoofing\":\n                mitm_results = self._simulate_dns_spoofing(target_network, duration, safe_mode)\n            elif attack_method == \"SSL Stripping\":\n                mitm_results = self._simulate_ssl_stripping(target_network, duration, safe_mode)\n            elif attack_method == \"DHCP Spoofing\":\n                mitm_results = self._simulate_dhcp_spoofing(target_network, duration, safe_mode)\n            else:\n                mitm_results = self._simulate_generic_mitm(target_network, duration, safe_mode)\n            \n            results.update(mitm_results)\n            results['simulation_success'] = True\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n        \n        results['end_time'] = datetime.now()\n        results['actual_duration'] = (results['end_time'] - start_time).total_seconds()\n        \n        self.attack_results.append(results)\n        return results\n    \n    def simulate_network_intrusion(self, target_ip: str, attack_vector: str, intensity: int, safe_mode: bool = True) -> Dict[str, Any]:\n        \"\"\"Simulate network intrusion attempt\"\"\"\n        \n        attack_id = f\"intrusion_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n        start_time = datetime.now()\n        \n        results = {\n            'attack_id': attack_id,\n            'attack_type': 'Network Intrusion',\n            'attack_vector': attack_vector,\n            'target_ip': target_ip,\n            'intensity': intensity,\n            'safe_mode': safe_mode,\n            'start_time': start_time,\n            'exploitation_attempts': 0,\n            'successful_exploits': 0,\n            'services_compromised': [],\n            'privilege_escalations': 0,\n            'persistence_mechanisms': [],\n            'detection_triggers': []\n        }\n        \n        try:\n            if attack_vector == \"SMB Exploitation\":\n                intrusion_results = self._simulate_smb_intrusion(target_ip, intensity, safe_mode)\n            elif attack_vector == \"Web Application Attack\":\n                intrusion_results = self._simulate_web_app_intrusion(target_ip, intensity, safe_mode)\n            elif attack_vector == \"SSH Brute Force\":\n                intrusion_results = self._simulate_ssh_brute_force(target_ip, intensity, safe_mode)\n            elif attack_vector == \"RDP Attack\":\n                intrusion_results = self._simulate_rdp_attack(target_ip, intensity, safe_mode)\n            else:\n                intrusion_results = self._simulate_generic_intrusion(target_ip, intensity, safe_mode)\n            \n            results.update(intrusion_results)\n            results['simulation_success'] = True\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n        \n        results['end_time'] = datetime.now()\n        results['attack_duration'] = (results['end_time'] - start_time).total_seconds()\n        \n        self.attack_results.append(results)\n        return results\n    \n    def _get_ddos_vectors(self, intensity: int) -> List[str]:\n        \"\"\"Get DDoS attack vectors based on intensity\"\"\"\n        all_vectors = [\n            \"TCP SYN Flood\",\n            \"UDP Flood\", \n            \"HTTP/HTTPS Flood\",\n            \"DNS Amplification\",\n            \"NTP Amplification\",\n            \"ICMP Flood\",\n            \"Slowloris\",\n            \"Connection Exhaustion\"\n        ]\n        \n        # Select vectors based on intensity\n        num_vectors = min(intensity // 2 + 1, len(all_vectors))\n        return random.sample(all_vectors, num_vectors)\n    \n    def _simulate_ddos_vector(self, vector: str, target_ip: str, duration: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate specific DDoS attack vector\"\"\"\n        \n        results = {\n            'vector': vector,\n            'packets_sent': 0,\n            'connections_made': 0,\n            'bandwidth_mbps': 0,\n            'detection_triggers': []\n        }\n        \n        if vector == \"TCP SYN Flood\":\n            results['packets_sent'] = random.randint(10000, 100000)\n            results['connections_made'] = results['packets_sent'] // 2\n            results['bandwidth_mbps'] = random.randint(50, 500)\n            results['detection_triggers'].append({\n                'type': 'TCP SYN Flood Detection',\n                'description': f'High volume of TCP SYN packets to {target_ip}',\n                'indicators': ['Half-open connections', 'SYN packet rate spike', 'Connection state exhaustion'],\n                'severity': 'Critical',\n                'timestamp': datetime.now()\n            })\n            \n        elif vector == \"UDP Flood\":\n            results['packets_sent'] = random.randint(20000, 150000)\n            results['bandwidth_mbps'] = random.randint(100, 800)\n            results['detection_triggers'].append({\n                'type': 'UDP Flood Detection',\n                'description': f'High volume UDP traffic to {target_ip}',\n                'indicators': ['UDP packet rate spike', 'Bandwidth consumption', 'Random port targeting'],\n                'severity': 'High',\n                'timestamp': datetime.now()\n            })\n            \n        elif vector == \"HTTP/HTTPS Flood\":\n            results['connections_made'] = random.randint(5000, 50000)\n            results['packets_sent'] = results['connections_made'] * 3\n            results['bandwidth_mbps'] = random.randint(30, 300)\n            results['detection_triggers'].append({\n                'type': 'HTTP Flood Detection',\n                'description': f'Application layer flood attack on {target_ip}',\n                'indicators': ['HTTP request rate spike', 'Resource exhaustion', 'Application slowdown'],\n                'severity': 'High',\n                'timestamp': datetime.now()\n            })\n            \n        elif vector == \"DNS Amplification\":\n            results['packets_sent'] = random.randint(5000, 30000)\n            results['bandwidth_mbps'] = random.randint(200, 1000)  # Higher bandwidth due to amplification\n            results['detection_triggers'].append({\n                'type': 'DNS Amplification Attack',\n                'description': f'DNS amplification attack targeting {target_ip}',\n                'indicators': ['Large DNS responses', 'Spoofed source IPs', 'Bandwidth amplification'],\n                'severity': 'Critical',\n                'timestamp': datetime.now()\n            })\n            \n        elif vector == \"Slowloris\":\n            results['connections_made'] = random.randint(1000, 10000)\n            results['packets_sent'] = results['connections_made'] * 10\n            results['bandwidth_mbps'] = random.randint(1, 10)  # Low bandwidth attack\n            results['detection_triggers'].append({\n                'type': 'Slowloris Attack Detection',\n                'description': f'Slow HTTP attack maintaining connections to {target_ip}',\n                'indicators': ['Long-duration HTTP connections', 'Incomplete HTTP requests', 'Connection pool exhaustion'],\n                'severity': 'Medium',\n                'timestamp': datetime.now()\n            })\n        \n        return results\n    \n    def _calculate_ddos_success_rate(self, results: Dict[str, Any], intensity: int) -> float:\n        \"\"\"Calculate DDoS attack success rate\"\"\"\n        base_success = 0.7\n        \n        # Higher intensity increases success rate\n        intensity_bonus = (intensity - 5) * 0.05\n        \n        # More attack vectors increase success rate\n        vector_bonus = len(results['attack_vectors']) * 0.1\n        \n        # High bandwidth attacks are more likely to succeed\n        bandwidth_bonus = min(results['bandwidth_consumed_mbps'] / 1000, 0.2)\n        \n        success_rate = min(0.95, base_success + intensity_bonus + vector_bonus + bandwidth_bonus)\n        return round(success_rate, 3)\n    \n    def _simulate_syn_scan(self, target_network: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate TCP SYN port scan\"\"\"\n        hosts_to_scan = min(intensity * 5, 50)\n        ports_per_host = min(intensity * 100, 1000)\n        \n        results = {\n            'hosts_scanned': hosts_to_scan,\n            'ports_scanned': hosts_to_scan * ports_per_host,\n            'open_ports_found': [],\n            'services_identified': [],\n            'stealth_level': 0.6,  # Moderate stealth\n            'detection_triggers': []\n        }\n        \n        # Simulate found open ports\n        common_ports = [22, 23, 53, 80, 135, 139, 443, 445, 993, 995, 1723, 3389, 5060]\n        for _ in range(random.randint(5, 20)):\n            port = random.choice(common_ports)\n            host_ip = self._generate_target_ip(target_network)\n            results['open_ports_found'].append({'ip': host_ip, 'port': port})\n            \n            # Identify service\n            service = self._identify_service(port)\n            if service:\n                results['services_identified'].append({'ip': host_ip, 'port': port, 'service': service})\n        \n        # Generate detection triggers\n        results['detection_triggers'].append({\n            'type': 'Port Scan Detection',\n            'description': f'TCP SYN scan detected against {target_network}',\n            'indicators': ['High SYN packet rate', 'Sequential port probing', 'Multiple target IPs'],\n            'severity': 'Medium',\n            'timestamp': datetime.now(),\n            'scan_rate': f'{results[\"ports_scanned\"]} ports/minute'\n        })\n        \n        return results\n    \n    def _simulate_udp_scan(self, target_network: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate UDP port scan\"\"\"\n        hosts_to_scan = min(intensity * 3, 30)\n        ports_per_host = min(intensity * 50, 500)\n        \n        results = {\n            'hosts_scanned': hosts_to_scan,\n            'ports_scanned': hosts_to_scan * ports_per_host,\n            'open_ports_found': [],\n            'services_identified': [],\n            'stealth_level': 0.8,  # Higher stealth for UDP\n            'detection_triggers': []\n        }\n        \n        # Simulate found open UDP ports\n        udp_ports = [53, 69, 123, 161, 162, 514, 1434, 1900]\n        for _ in range(random.randint(2, 8)):\n            port = random.choice(udp_ports)\n            host_ip = self._generate_target_ip(target_network)\n            results['open_ports_found'].append({'ip': host_ip, 'port': port, 'protocol': 'UDP'})\n            \n            service = self._identify_service(port, 'UDP')\n            if service:\n                results['services_identified'].append({'ip': host_ip, 'port': port, 'service': service, 'protocol': 'UDP'})\n        \n        results['detection_triggers'].append({\n            'type': 'UDP Port Scan Detection',\n            'description': f'UDP port scan detected against {target_network}',\n            'indicators': ['UDP probe packets', 'ICMP unreachable responses', 'Port enumeration'],\n            'severity': 'Low',\n            'timestamp': datetime.now()\n        })\n        \n        return results\n    \n    def _simulate_stealth_scan(self, target_network: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate stealth port scan\"\"\"\n        hosts_to_scan = min(intensity * 2, 20)\n        ports_per_host = min(intensity * 30, 300)\n        \n        results = {\n            'hosts_scanned': hosts_to_scan,\n            'ports_scanned': hosts_to_scan * ports_per_host,\n            'open_ports_found': [],\n            'services_identified': [],\n            'stealth_level': 0.9,  # Very high stealth\n            'detection_triggers': []\n        }\n        \n        # Fewer detection triggers due to stealth\n        if random.random() < 0.3:  # 30% chance of detection\n            results['detection_triggers'].append({\n                'type': 'Stealth Scan Detection',\n                'description': f'Possible stealth scan detected against {target_network}',\n                'indicators': ['Unusual TCP flag combinations', 'Fragmented packets', 'Slow scan rate'],\n                'severity': 'Low',\n                'timestamp': datetime.now()\n            })\n        \n        return results\n    \n    def _simulate_comprehensive_scan(self, target_network: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate comprehensive network scan\"\"\"\n        hosts_to_scan = min(intensity * 10, 100)\n        ports_per_host = min(intensity * 200, 2000)\n        \n        results = {\n            'hosts_scanned': hosts_to_scan,\n            'ports_scanned': hosts_to_scan * ports_per_host,\n            'open_ports_found': [],\n            'services_identified': [],\n            'stealth_level': 0.2,  # Low stealth - very noisy\n            'detection_triggers': []\n        }\n        \n        # Comprehensive scan finds more services\n        all_ports = [21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995, 1433, 1521, 3389, 5432]\n        for _ in range(random.randint(15, 40)):\n            port = random.choice(all_ports)\n            host_ip = self._generate_target_ip(target_network)\n            results['open_ports_found'].append({'ip': host_ip, 'port': port})\n            \n            service = self._identify_service(port)\n            if service:\n                results['services_identified'].append({'ip': host_ip, 'port': port, 'service': service})\n        \n        # Multiple detection triggers for comprehensive scan\n        results['detection_triggers'].extend([\n            {\n                'type': 'Comprehensive Network Scan',\n                'description': f'Large-scale network scan detected against {target_network}',\n                'indicators': ['High connection rate', 'Multiple port probes', 'Service enumeration'],\n                'severity': 'High',\n                'timestamp': datetime.now()\n            },\n            {\n                'type': 'Network Reconnaissance',\n                'description': 'Systematic network reconnaissance activity',\n                'indicators': ['Host discovery', 'Service identification', 'OS fingerprinting'],\n                'severity': 'Medium',\n                'timestamp': datetime.now()\n            }\n        ])\n        \n        return results\n    \n    def _simulate_basic_scan(self, target_network: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate basic port scan\"\"\"\n        hosts_to_scan = min(intensity, 10)\n        ports_per_host = min(intensity * 20, 200)\n        \n        results = {\n            'hosts_scanned': hosts_to_scan,\n            'ports_scanned': hosts_to_scan * ports_per_host,\n            'open_ports_found': [],\n            'services_identified': [],\n            'stealth_level': 0.4,\n            'detection_triggers': []\n        }\n        \n        results['detection_triggers'].append({\n            'type': 'Basic Port Scan',\n            'description': f'Port scanning activity detected against {target_network}',\n            'indicators': ['Sequential port connections', 'Connection attempts'],\n            'severity': 'Low',\n            'timestamp': datetime.now()\n        })\n        \n        return results\n    \n    def _simulate_arp_spoofing(self, target_network: str, duration: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate ARP spoofing attack\"\"\"\n        victims_targeted = random.randint(2, 10)\n        traffic_intercepted = random.randint(50, 500)  # MB\n        credentials_captured = random.randint(0, 5)\n        \n        results = {\n            'victims_targeted': victims_targeted,\n            'traffic_intercepted_mb': traffic_intercepted,\n            'credentials_captured': credentials_captured,\n            'attack_success': credentials_captured > 0,\n            'detection_triggers': [\n                {\n                    'type': 'ARP Spoofing Attack',\n                    'description': f'ARP spoofing detected in network {target_network}',\n                    'indicators': ['Duplicate ARP responses', 'MAC address conflicts', 'Gateway impersonation'],\n                    'severity': 'Critical',\n                    'timestamp': datetime.now(),\n                    'affected_hosts': victims_targeted\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_dns_spoofing(self, target_network: str, duration: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate DNS spoofing attack\"\"\"\n        victims_targeted = random.randint(3, 15)\n        domains_spoofed = random.randint(5, 20)\n        \n        results = {\n            'victims_targeted': victims_targeted,\n            'domains_spoofed': domains_spoofed,\n            'traffic_intercepted_mb': random.randint(20, 200),\n            'attack_success': True,\n            'detection_triggers': [\n                {\n                    'type': 'DNS Spoofing Attack',\n                    'description': f'DNS spoofing detected in network {target_network}',\n                    'indicators': ['Malicious DNS responses', 'Domain resolution anomalies', 'DNS cache poisoning'],\n                    'severity': 'High',\n                    'timestamp': datetime.now(),\n                    'spoofed_domains': domains_spoofed\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_ssl_stripping(self, target_network: str, duration: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate SSL stripping attack\"\"\"\n        victims_targeted = random.randint(1, 8)\n        credentials_captured = random.randint(0, victims_targeted)\n        \n        results = {\n            'victims_targeted': victims_targeted,\n            'credentials_captured': credentials_captured,\n            'ssl_connections_stripped': random.randint(10, 50),\n            'attack_success': credentials_captured > 0,\n            'detection_triggers': [\n                {\n                    'type': 'SSL Stripping Attack',\n                    'description': f'SSL stripping detected in network {target_network}',\n                    'indicators': ['HTTPS downgrade attempts', 'Certificate warnings', 'HTTP traffic from HTTPS sites'],\n                    'severity': 'High',\n                    'timestamp': datetime.now()\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_dhcp_spoofing(self, target_network: str, duration: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate DHCP spoofing attack\"\"\"\n        victims_targeted = random.randint(5, 20)\n        \n        results = {\n            'victims_targeted': victims_targeted,\n            'dhcp_responses_sent': random.randint(100, 500),\n            'gateway_redirections': victims_targeted,\n            'attack_success': True,\n            'detection_triggers': [\n                {\n                    'type': 'DHCP Spoofing Attack',\n                    'description': f'DHCP spoofing detected in network {target_network}',\n                    'indicators': ['Rogue DHCP server', 'Gateway redirection', 'IP assignment anomalies'],\n                    'severity': 'High',\n                    'timestamp': datetime.now()\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_generic_mitm(self, target_network: str, duration: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate generic MITM attack\"\"\"\n        return {\n            'victims_targeted': random.randint(2, 10),\n            'traffic_intercepted_mb': random.randint(30, 300),\n            'attack_success': random.choice([True, False]),\n            'detection_triggers': [\n                {\n                    'type': 'Man-in-the-Middle Attack',\n                    'description': f'MITM attack detected in network {target_network}',\n                    'indicators': ['Traffic interception', 'Network anomalies'],\n                    'severity': 'Medium',\n                    'timestamp': datetime.now()\n                }\n            ]\n        }\n    \n    def _simulate_smb_intrusion(self, target_ip: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate SMB-based intrusion\"\"\"\n        exploitation_attempts = intensity * 3\n        successful_exploits = max(0, exploitation_attempts - random.randint(exploitation_attempts//2, exploitation_attempts))\n        \n        results = {\n            'exploitation_attempts': exploitation_attempts,\n            'successful_exploits': successful_exploits,\n            'services_compromised': ['SMB', 'NetBIOS'] if successful_exploits > 0 else [],\n            'privilege_escalations': min(successful_exploits, 2),\n            'persistence_mechanisms': ['Registry keys', 'Scheduled tasks'] if successful_exploits > 1 else [],\n            'detection_triggers': [\n                {\n                    'type': 'SMB Exploitation Attempt',\n                    'description': f'SMB exploitation detected against {target_ip}',\n                    'indicators': ['SMB vulnerability scanning', 'EternalBlue signatures', 'SMB buffer overflow'],\n                    'severity': 'Critical',\n                    'timestamp': datetime.now(),\n                    'attempts': exploitation_attempts\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_web_app_intrusion(self, target_ip: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate web application intrusion\"\"\"\n        exploitation_attempts = intensity * 5\n        successful_exploits = max(0, random.randint(0, exploitation_attempts//3))\n        \n        results = {\n            'exploitation_attempts': exploitation_attempts,\n            'successful_exploits': successful_exploits,\n            'services_compromised': ['HTTP', 'HTTPS'] if successful_exploits > 0 else [],\n            'attack_vectors': ['SQL Injection', 'XSS', 'CSRF', 'Directory Traversal'],\n            'data_accessed': successful_exploits > 0,\n            'detection_triggers': [\n                {\n                    'type': 'Web Application Attack',\n                    'description': f'Web application attack detected against {target_ip}',\n                    'indicators': ['SQL injection attempts', 'XSS payloads', 'Abnormal HTTP requests'],\n                    'severity': 'High',\n                    'timestamp': datetime.now()\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_ssh_brute_force(self, target_ip: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate SSH brute force attack\"\"\"\n        login_attempts = intensity * 100\n        successful_logins = max(0, random.randint(0, 2) if intensity > 7 else 0)\n        \n        results = {\n            'exploitation_attempts': login_attempts,\n            'successful_exploits': successful_logins,\n            'services_compromised': ['SSH'] if successful_logins > 0 else [],\n            'credentials_found': successful_logins,\n            'detection_triggers': [\n                {\n                    'type': 'SSH Brute Force Attack',\n                    'description': f'SSH brute force detected against {target_ip}',\n                    'indicators': ['Repeated SSH login failures', 'Dictionary attack patterns', 'Account lockouts'],\n                    'severity': 'High',\n                    'timestamp': datetime.now(),\n                    'attempts': login_attempts\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_rdp_attack(self, target_ip: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate RDP attack\"\"\"\n        exploitation_attempts = intensity * 20\n        successful_exploits = max(0, random.randint(0, 1) if intensity > 8 else 0)\n        \n        results = {\n            'exploitation_attempts': exploitation_attempts,\n            'successful_exploits': successful_exploits,\n            'services_compromised': ['RDP'] if successful_exploits > 0 else [],\n            'detection_triggers': [\n                {\n                    'type': 'RDP Attack',\n                    'description': f'RDP attack detected against {target_ip}',\n                    'indicators': ['RDP brute force', 'BlueKeep exploit attempts', 'RDP enumeration'],\n                    'severity': 'High',\n                    'timestamp': datetime.now()\n                }\n            ]\n        }\n        \n        return results\n    \n    def _simulate_generic_intrusion(self, target_ip: str, intensity: int, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate generic network intrusion\"\"\"\n        return {\n            'exploitation_attempts': intensity * 2,\n            'successful_exploits': max(0, random.randint(0, intensity//3)),\n            'detection_triggers': [\n                {\n                    'type': 'Network Intrusion Attempt',\n                    'description': f'Network intrusion detected against {target_ip}',\n                    'indicators': ['Exploitation attempts', 'Suspicious network traffic'],\n                    'severity': 'Medium',\n                    'timestamp': datetime.now()\n                }\n            ]\n        }\n    \n    def _generate_target_ip(self, network: str) -> str:\n        \"\"\"Generate random IP within target network\"\"\"\n        if network.startswith('192.168.1'):\n            return f\"192.168.1.{random.randint(1, 254)}\"\n        elif network.startswith('10.0.0'):\n            return f\"10.0.0.{random.randint(1, 254)}\"\n        elif network.startswith('172.16'):\n            return f\"172.16.0.{random.randint(1, 254)}\"\n        else:\n            return f\"192.168.1.{random.randint(1, 254)}\"\n    \n    def _identify_service(self, port: int, protocol: str = 'TCP') -> str:\n        \"\"\"Identify service running on port\"\"\"\n        service_map = {\n            21: 'FTP',\n            22: 'SSH',\n            23: 'Telnet',\n            25: 'SMTP',\n            53: 'DNS',\n            80: 'HTTP',\n            110: 'POP3',\n            135: 'RPC',\n            139: 'NetBIOS',\n            143: 'IMAP',\n            443: 'HTTPS',\n            445: 'SMB',\n            993: 'IMAPS',\n            995: 'POP3S',\n            1433: 'SQL Server',\n            1521: 'Oracle',\n            3389: 'RDP',\n            5432: 'PostgreSQL'\n        }\n        \n        if protocol == 'UDP':\n            udp_services = {\n                53: 'DNS',\n                69: 'TFTP',\n                123: 'NTP',\n                161: 'SNMP',\n                162: 'SNMP Trap',\n                514: 'Syslog'\n            }\n            return udp_services.get(port)\n        \n        return service_map.get(port)\n    \n    def get_attack_results(self) -> List[Dict[str, Any]]:\n        \"\"\"Get all attack simulation results\"\"\"\n        return self.attack_results\n    \n    def clear_results(self):\n        \"\"\"Clear attack results history\"\"\"\n        self.attack_results = []\n","size_bytes":32689},"simulation/ransomware_sim.py":{"content":"import os\nimport time\nimport random\nimport hashlib\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List\nimport json\n\nclass RansomwareSimulator:\n    \"\"\"Specialized ransomware attack simulator for security testing\"\"\"\n    \n    def __init__(self):\n        self.simulation_active = False\n        self.encrypted_files = []\n        self.ransom_note_locations = []\n        self.registry_modifications = []\n        self.network_communications = []\n        \n    def simulate_wannacry_behavior(self, safe_mode: bool = True, intensity: int = 5) -> Dict[str, Any]:\n        \"\"\"Simulate WannaCry ransomware behavior patterns\"\"\"\n        \n        simulation_start = datetime.now()\n        results = {\n            'simulation_type': 'WannaCry',\n            'start_time': simulation_start,\n            'safe_mode': safe_mode,\n            'intensity': intensity,\n            'phases_completed': [],\n            'files_processed': 0,\n            'registry_changes': 0,\n            'network_connections': 0,\n            'detection_triggers': []\n        }\n        \n        try:\n            # Phase 1: Initial Reconnaissance\n            recon_results = self._simulate_reconnaissance_phase(safe_mode, intensity)\n            results['phases_completed'].append('reconnaissance')\n            results['detection_triggers'].extend(recon_results['triggers'])\n            \n            # Phase 2: Privilege Escalation\n            privesc_results = self._simulate_privilege_escalation(safe_mode, intensity)\n            results['phases_completed'].append('privilege_escalation')\n            results['detection_triggers'].extend(privesc_results['triggers'])\n            \n            # Phase 3: File Discovery and Enumeration\n            discovery_results = self._simulate_file_discovery(safe_mode, intensity)\n            results['phases_completed'].append('file_discovery')\n            results['files_processed'] = discovery_results['files_found']\n            results['detection_triggers'].extend(discovery_results['triggers'])\n            \n            # Phase 4: Encryption Simulation\n            encryption_results = self._simulate_file_encryption(safe_mode, intensity)\n            results['phases_completed'].append('encryption')\n            results['files_processed'] += encryption_results['files_encrypted']\n            results['detection_triggers'].extend(encryption_results['triggers'])\n            \n            # Phase 5: Registry Modifications\n            registry_results = self._simulate_registry_modifications(safe_mode, intensity)\n            results['phases_completed'].append('registry_modification')\n            results['registry_changes'] = registry_results['changes_made']\n            results['detection_triggers'].extend(registry_results['triggers'])\n            \n            # Phase 6: Network Propagation\n            network_results = self._simulate_network_propagation(safe_mode, intensity)\n            results['phases_completed'].append('network_propagation')\n            results['network_connections'] = network_results['connections_made']\n            results['detection_triggers'].extend(network_results['triggers'])\n            \n            # Phase 7: Ransom Note Deployment\n            ransom_results = self._simulate_ransom_note_deployment(safe_mode, intensity)\n            results['phases_completed'].append('ransom_deployment')\n            results['detection_triggers'].extend(ransom_results['triggers'])\n            \n            results['simulation_success'] = True\n            results['completion_time'] = datetime.now()\n            results['total_duration'] = (results['completion_time'] - simulation_start).total_seconds()\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n            results['completion_time'] = datetime.now()\n        \n        return results\n    \n    def simulate_locky_behavior(self, safe_mode: bool = True, intensity: int = 5) -> Dict[str, Any]:\n        \"\"\"Simulate Locky ransomware behavior patterns\"\"\"\n        \n        simulation_start = datetime.now()\n        results = {\n            'simulation_type': 'Locky',\n            'start_time': simulation_start,\n            'safe_mode': safe_mode,\n            'intensity': intensity,\n            'phases_completed': [],\n            'files_processed': 0,\n            'detection_triggers': []\n        }\n        \n        try:\n            # Locky-specific behavior simulation\n            \n            # Phase 1: Email-based Initial Infection\n            email_results = self._simulate_email_infection_vector(safe_mode, intensity)\n            results['phases_completed'].append('email_infection')\n            results['detection_triggers'].extend(email_results['triggers'])\n            \n            # Phase 2: JavaScript/Macro Execution\n            script_results = self._simulate_script_execution(safe_mode, intensity)\n            results['phases_completed'].append('script_execution')\n            results['detection_triggers'].extend(script_results['triggers'])\n            \n            # Phase 3: Payload Download and Execution\n            payload_results = self._simulate_payload_download(safe_mode, intensity)\n            results['phases_completed'].append('payload_execution')\n            results['detection_triggers'].extend(payload_results['triggers'])\n            \n            # Phase 4: File Encryption with .locky Extension\n            encryption_results = self._simulate_locky_encryption(safe_mode, intensity)\n            results['phases_completed'].append('locky_encryption')\n            results['files_processed'] = encryption_results['files_encrypted']\n            results['detection_triggers'].extend(encryption_results['triggers'])\n            \n            # Phase 5: Desktop Wallpaper Change\n            wallpaper_results = self._simulate_wallpaper_change(safe_mode)\n            results['phases_completed'].append('wallpaper_change')\n            results['detection_triggers'].extend(wallpaper_results['triggers'])\n            \n            results['simulation_success'] = True\n            results['completion_time'] = datetime.now()\n            results['total_duration'] = (results['completion_time'] - simulation_start).total_seconds()\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n            results['completion_time'] = datetime.now()\n        \n        return results\n    \n    def simulate_petya_behavior(self, safe_mode: bool = True, intensity: int = 5) -> Dict[str, Any]:\n        \"\"\"Simulate Petya/NotPetya ransomware behavior patterns\"\"\"\n        \n        simulation_start = datetime.now()\n        results = {\n            'simulation_type': 'Petya/NotPetya',\n            'start_time': simulation_start,\n            'safe_mode': safe_mode,\n            'intensity': intensity,\n            'phases_completed': [],\n            'mbr_modifications': 0,\n            'lateral_movement_attempts': 0,\n            'detection_triggers': []\n        }\n        \n        try:\n            # Petya-specific behavior simulation\n            \n            # Phase 1: Credential Harvesting\n            cred_results = self._simulate_credential_harvesting(safe_mode, intensity)\n            results['phases_completed'].append('credential_harvesting')\n            results['detection_triggers'].extend(cred_results['triggers'])\n            \n            # Phase 2: SMB Exploit (EternalBlue)\n            smb_results = self._simulate_smb_exploit(safe_mode, intensity)\n            results['phases_completed'].append('smb_exploit')\n            results['lateral_movement_attempts'] = smb_results['exploitation_attempts']\n            results['detection_triggers'].extend(smb_results['triggers'])\n            \n            # Phase 3: Master Boot Record (MBR) Modification\n            mbr_results = self._simulate_mbr_modification(safe_mode, intensity)\n            results['phases_completed'].append('mbr_modification')\n            results['mbr_modifications'] = mbr_results['modifications_made']\n            results['detection_triggers'].extend(mbr_results['triggers'])\n            \n            # Phase 4: File System Encryption\n            encryption_results = self._simulate_filesystem_encryption(safe_mode, intensity)\n            results['phases_completed'].append('filesystem_encryption')\n            results['detection_triggers'].extend(encryption_results['triggers'])\n            \n            # Phase 5: System Reboot Trigger\n            reboot_results = self._simulate_reboot_trigger(safe_mode)\n            results['phases_completed'].append('reboot_trigger')\n            results['detection_triggers'].extend(reboot_results['triggers'])\n            \n            results['simulation_success'] = True\n            results['completion_time'] = datetime.now()\n            results['total_duration'] = (results['completion_time'] - simulation_start).total_seconds()\n            \n        except Exception as e:\n            results['simulation_success'] = False\n            results['error'] = str(e)\n            results['completion_time'] = datetime.now()\n        \n        return results\n    \n    def _simulate_reconnaissance_phase(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate reconnaissance phase of ransomware\"\"\"\n        triggers = []\n        \n        # System information gathering\n        if not safe_mode:\n            # In real mode, would actually gather system info\n            time.sleep(0.1)\n        \n        triggers.append({\n            'type': 'System Information Query',\n            'description': 'Ransomware querying system information',\n            'indicators': ['WMI queries', 'System enumeration', 'OS version check'],\n            'timestamp': datetime.now(),\n            'severity': 'Medium'\n        })\n        \n        # Network discovery\n        triggers.append({\n            'type': 'Network Discovery',\n            'description': 'Scanning for network shares and connected systems',\n            'indicators': ['NetBIOS enumeration', 'SMB share discovery', 'Network scanning'],\n            'timestamp': datetime.now(),\n            'severity': 'High'\n        })\n        \n        # Process enumeration\n        triggers.append({\n            'type': 'Process Enumeration',\n            'description': 'Enumerating running processes for security software',\n            'indicators': ['Process list queries', 'Service enumeration', 'Security software detection'],\n            'timestamp': datetime.now(),\n            'severity': 'Medium'\n        })\n        \n        return {\n            'phase': 'reconnaissance',\n            'duration': random.uniform(5, 15) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_privilege_escalation(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate privilege escalation attempts\"\"\"\n        triggers = []\n        \n        # UAC bypass attempt\n        triggers.append({\n            'type': 'UAC Bypass Attempt',\n            'description': 'Attempting to bypass User Account Control',\n            'indicators': ['Registry manipulation', 'Process elevation', 'Token manipulation'],\n            'timestamp': datetime.now(),\n            'severity': 'High'\n        })\n        \n        # Exploit vulnerability\n        if intensity > 5:\n            triggers.append({\n                'type': 'Local Privilege Escalation',\n                'description': 'Exploiting local vulnerability for privilege escalation',\n                'indicators': ['Kernel exploit', 'DLL hijacking', 'Service exploitation'],\n                'timestamp': datetime.now(),\n                'severity': 'Critical'\n            })\n        \n        return {\n            'phase': 'privilege_escalation',\n            'duration': random.uniform(10, 30) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_file_discovery(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate file system discovery and enumeration\"\"\"\n        triggers = []\n        \n        # File system traversal\n        file_types_targeted = ['.doc', '.docx', '.pdf', '.jpg', '.png', '.xlsx', '.ppt', '.zip', '.rar']\n        files_found = intensity * random.randint(100, 500)\n        \n        triggers.append({\n            'type': 'Recursive File Enumeration',\n            'description': f'Scanning file system for {len(file_types_targeted)} file types',\n            'indicators': ['High file system I/O', 'Directory traversal', 'File type filtering'],\n            'timestamp': datetime.now(),\n            'severity': 'High',\n            'file_count': files_found\n        })\n        \n        # Shadow copy enumeration\n        if intensity > 3:\n            triggers.append({\n                'type': 'Shadow Copy Enumeration',\n                'description': 'Enumerating Volume Shadow Copies for deletion',\n                'indicators': ['vssadmin queries', 'WMI shadow copy queries', 'Backup enumeration'],\n                'timestamp': datetime.now(),\n                'severity': 'Critical'\n            })\n        \n        return {\n            'phase': 'file_discovery',\n            'files_found': files_found,\n            'duration': random.uniform(30, 120) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_file_encryption(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate file encryption process\"\"\"\n        triggers = []\n        \n        # Mass file encryption\n        files_encrypted = intensity * random.randint(50, 200)\n        encryption_extensions = ['.wncry', '.encrypted', '.locked', '.crypto']\n        \n        triggers.append({\n            'type': 'Mass File Encryption',\n            'description': f'Encrypting {files_encrypted} files with ransomware',\n            'indicators': [\n                'High CPU usage from encryption',\n                'Rapid file modifications',\n                f'Files renamed with {random.choice(encryption_extensions)} extension',\n                'Cryptographic API calls'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical',\n            'files_affected': files_encrypted\n        })\n        \n        # Delete shadow copies\n        if intensity > 4:\n            triggers.append({\n                'type': 'Shadow Copy Deletion',\n                'description': 'Deleting Volume Shadow Copies to prevent recovery',\n                'indicators': ['vssadmin delete shadows', 'WMI shadow copy deletion', 'Backup destruction'],\n                'timestamp': datetime.now(),\n                'severity': 'Critical'\n            })\n        \n        # Original file deletion\n        triggers.append({\n            'type': 'Original File Deletion',\n            'description': 'Securely deleting original unencrypted files',\n            'indicators': ['File deletion patterns', 'Secure erase operations', 'Free space overwriting'],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'file_encryption',\n            'files_encrypted': files_encrypted,\n            'duration': random.uniform(60, 300) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_registry_modifications(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate registry modifications typical of ransomware\"\"\"\n        triggers = []\n        changes_made = 0\n        \n        # Startup persistence\n        changes_made += 1\n        triggers.append({\n            'type': 'Registry Startup Modification',\n            'description': 'Adding ransomware to startup registry keys',\n            'indicators': [\n                'HKEY_LOCAL_MACHINE\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run',\n                'HKEY_CURRENT_USER\\\\SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Run',\n                'Startup program registration'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'High'\n        })\n        \n        # Security settings modification\n        if intensity > 3:\n            changes_made += 2\n            triggers.append({\n                'type': 'Security Settings Modification',\n                'description': 'Disabling security features via registry',\n                'indicators': [\n                    'Windows Defender settings modification',\n                    'System Restore settings change',\n                    'UAC settings modification'\n                ],\n                'timestamp': datetime.now(),\n                'severity': 'Critical'\n            })\n        \n        # Wallpaper change\n        changes_made += 1\n        triggers.append({\n            'type': 'Desktop Wallpaper Change',\n            'description': 'Changing desktop wallpaper to ransom message',\n            'indicators': [\n                'HKEY_CURRENT_USER\\\\Control Panel\\\\Desktop\\\\Wallpaper',\n                'Desktop background modification',\n                'System appearance changes'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Medium'\n        })\n        \n        return {\n            'phase': 'registry_modification',\n            'changes_made': changes_made,\n            'duration': random.uniform(5, 20),\n            'triggers': triggers\n        }\n    \n    def _simulate_network_propagation(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate network propagation attempts\"\"\"\n        triggers = []\n        connections_made = intensity * random.randint(5, 20)\n        \n        # SMB share enumeration and infection\n        triggers.append({\n            'type': 'SMB Share Propagation',\n            'description': 'Attempting to spread via SMB shares',\n            'indicators': [\n                'SMB connection attempts',\n                'Network share enumeration',\n                'Remote file copying',\n                f'{connections_made} network connections'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        # Exploit-based propagation (EternalBlue simulation)\n        if intensity > 6:\n            triggers.append({\n                'type': 'EternalBlue Exploit Propagation',\n                'description': 'Using EternalBlue exploit for network propagation',\n                'indicators': [\n                    'SMB vulnerability exploitation',\n                    'MS17-010 exploit patterns',\n                    'Remote code execution attempts'\n                ],\n                'timestamp': datetime.now(),\n                'severity': 'Critical'\n            })\n        \n        return {\n            'phase': 'network_propagation',\n            'connections_made': connections_made,\n            'duration': random.uniform(30, 120) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_ransom_note_deployment(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate ransom note deployment\"\"\"\n        triggers = []\n        \n        # Create ransom notes\n        note_locations = [\n            'Desktop',\n            'Documents folder',\n            'Each encrypted folder',\n            'System root directory'\n        ]\n        \n        triggers.append({\n            'type': 'Ransom Note Creation',\n            'description': f'Creating ransom notes in {len(note_locations)} locations',\n            'indicators': [\n                'README_DECRYPT.txt creation',\n                'Multiple ransom note files',\n                'Ransom message display',\n                'Payment instruction files'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        # Display ransom message\n        if intensity > 2:\n            triggers.append({\n                'type': 'Ransom Message Display',\n                'description': 'Displaying full-screen ransom message',\n                'indicators': [\n                    'Full-screen application launch',\n                    'Window manipulation',\n                    'User interface takeover'\n                ],\n                'timestamp': datetime.now(),\n                'severity': 'High'\n            })\n        \n        return {\n            'phase': 'ransom_deployment',\n            'notes_created': len(note_locations),\n            'duration': random.uniform(5, 15),\n            'triggers': triggers\n        }\n    \n    def _simulate_email_infection_vector(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate email-based infection vector (Locky specific)\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'Malicious Email Attachment',\n            'description': 'Email attachment with malicious macro/JavaScript',\n            'indicators': [\n                'Microsoft Office macro execution',\n                'JavaScript execution from email',\n                'Suspicious email attachment behavior'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'High'\n        })\n        \n        return {\n            'phase': 'email_infection',\n            'duration': random.uniform(1, 5),\n            'triggers': triggers\n        }\n    \n    def _simulate_script_execution(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate malicious script execution\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'Malicious Script Execution',\n            'description': 'Executing obfuscated JavaScript/VBA macro',\n            'indicators': [\n                'PowerShell execution with encoded commands',\n                'VBA macro with obfuscated code',\n                'JavaScript execution from Office document'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'script_execution',\n            'duration': random.uniform(5, 15),\n            'triggers': triggers\n        }\n    \n    def _simulate_payload_download(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate payload download and execution\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'Malicious Payload Download',\n            'description': 'Downloading ransomware payload from C2 server',\n            'indicators': [\n                'HTTP/HTTPS connections to suspicious domains',\n                'Executable download to temp directory',\n                'Payload execution from temporary location'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'payload_download',\n            'duration': random.uniform(10, 30),\n            'triggers': triggers\n        }\n    \n    def _simulate_locky_encryption(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate Locky-specific encryption behavior\"\"\"\n        triggers = []\n        files_encrypted = intensity * random.randint(100, 400)\n        \n        triggers.append({\n            'type': 'Locky File Encryption',\n            'description': f'Encrypting {files_encrypted} files with .locky extension',\n            'indicators': [\n                'Mass file renaming to .locky extension',\n                'AES encryption of user files',\n                'File content modification patterns'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical',\n            'files_affected': files_encrypted\n        })\n        \n        return {\n            'phase': 'locky_encryption',\n            'files_encrypted': files_encrypted,\n            'duration': random.uniform(60, 240) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_wallpaper_change(self, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate desktop wallpaper change\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'Desktop Wallpaper Modification',\n            'description': 'Changing desktop wallpaper to ransom message',\n            'indicators': [\n                'SystemParametersInfo API call',\n                'Desktop wallpaper registry modification',\n                'Visual system changes'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Medium'\n        })\n        \n        return {\n            'phase': 'wallpaper_change',\n            'duration': random.uniform(1, 3),\n            'triggers': triggers\n        }\n    \n    def _simulate_credential_harvesting(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate credential harvesting (Petya specific)\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'Credential Harvesting',\n            'description': 'Extracting credentials for lateral movement',\n            'indicators': [\n                'LSASS memory access',\n                'SAM database access',\n                'Credential dumping tools execution'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'credential_harvesting',\n            'duration': random.uniform(15, 45),\n            'triggers': triggers\n        }\n    \n    def _simulate_smb_exploit(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate SMB exploit (EternalBlue)\"\"\"\n        triggers = []\n        exploitation_attempts = intensity * random.randint(3, 15)\n        \n        triggers.append({\n            'type': 'EternalBlue SMB Exploit',\n            'description': f'Attempting EternalBlue exploitation on {exploitation_attempts} targets',\n            'indicators': [\n                'SMB vulnerability scanning',\n                'MS17-010 exploit payload delivery',\n                'Remote code execution via SMB'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'smb_exploit',\n            'exploitation_attempts': exploitation_attempts,\n            'duration': random.uniform(30, 90) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_mbr_modification(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate Master Boot Record modification\"\"\"\n        triggers = []\n        modifications_made = 1\n        \n        triggers.append({\n            'type': 'Master Boot Record Modification',\n            'description': 'Overwriting MBR with ransomware bootloader',\n            'indicators': [\n                'Raw disk access',\n                'MBR sector modification',\n                'Boot process hijacking'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'mbr_modification',\n            'modifications_made': modifications_made,\n            'duration': random.uniform(5, 15),\n            'triggers': triggers\n        }\n    \n    def _simulate_filesystem_encryption(self, safe_mode: bool, intensity: int) -> Dict[str, Any]:\n        \"\"\"Simulate file system level encryption\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'File System Encryption',\n            'description': 'Encrypting entire file system structures',\n            'indicators': [\n                'MFT (Master File Table) encryption',\n                'File system metadata modification',\n                'Disk-level encryption operations'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'Critical'\n        })\n        \n        return {\n            'phase': 'filesystem_encryption',\n            'duration': random.uniform(120, 600) * intensity,\n            'triggers': triggers\n        }\n    \n    def _simulate_reboot_trigger(self, safe_mode: bool) -> Dict[str, Any]:\n        \"\"\"Simulate system reboot trigger\"\"\"\n        triggers = []\n        \n        triggers.append({\n            'type': 'Forced System Reboot',\n            'description': 'Triggering system reboot to activate boot-level encryption',\n            'indicators': [\n                'System shutdown/reboot command',\n                'Forced system restart',\n                'Boot process modification'\n            ],\n            'timestamp': datetime.now(),\n            'severity': 'High'\n        })\n        \n        return {\n            'phase': 'reboot_trigger',\n            'duration': random.uniform(1, 5),\n            'triggers': triggers\n        }\n","size_bytes":28530},"utils/data_processor.py":{"content":"import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional, Tuple\nimport json\nimport hashlib\nfrom collections import defaultdict, Counter\nimport statistics\nimport random\n\nclass DataProcessor:\n    \"\"\"Advanced data processing utilities for security analytics\"\"\"\n    \n    def __init__(self):\n        self.historical_data = defaultdict(list)\n        self.metrics_cache = {}\n        self.cache_expiry = {}\n        self.baseline_data = {}\n        self.anomaly_thresholds = self._initialize_anomaly_thresholds()\n        self.correlation_rules = self._initialize_correlation_rules()\n        \n    def _initialize_anomaly_thresholds(self) -> Dict[str, Dict[str, float]]:\n        \"\"\"Initialize anomaly detection thresholds\"\"\"\n        return {\n            'network_traffic': {\n                'packets_per_second': {'min': 100, 'max': 10000, 'std_dev_multiplier': 3.0},\n                'bytes_per_second': {'min': 1000, 'max': 100000000, 'std_dev_multiplier': 3.0},\n                'connection_rate': {'min': 1, 'max': 1000, 'std_dev_multiplier': 2.5}\n            },\n            'endpoint_behavior': {\n                'cpu_usage': {'min': 0, 'max': 100, 'std_dev_multiplier': 2.0},\n                'memory_usage': {'min': 0, 'max': 100, 'std_dev_multiplier': 2.0},\n                'process_count': {'min': 10, 'max': 500, 'std_dev_multiplier': 2.5},\n                'file_operations': {'min': 0, 'max': 10000, 'std_dev_multiplier': 3.0}\n            },\n            'user_behavior': {\n                'login_frequency': {'min': 0, 'max': 10, 'std_dev_multiplier': 2.0},\n                'data_access_rate': {'min': 0, 'max': 1000, 'std_dev_multiplier': 2.5},\n                'failed_attempts': {'min': 0, 'max': 5, 'std_dev_multiplier': 1.5}\n            }\n        }\n    \n    def _initialize_correlation_rules(self) -> List[Dict[str, Any]]:\n        \"\"\"Initialize correlation rules for cross-system analysis\"\"\"\n        return [\n            {\n                'name': 'Coordinated Attack Pattern',\n                'description': 'Multiple systems showing similar attack indicators',\n                'conditions': {\n                    'time_window': 1800,  # 30 minutes\n                    'min_systems': 3,\n                    'similarity_threshold': 0.8\n                },\n                'severity': 'Critical'\n            },\n            {\n                'name': 'Lateral Movement Detection',\n                'description': 'Sequential compromise across network segments',\n                'conditions': {\n                    'time_window': 3600,  # 1 hour\n                    'min_hops': 2,\n                    'progression_pattern': 'sequential'\n                },\n                'severity': 'High'\n            },\n            {\n                'name': 'Data Exfiltration Chain',\n                'description': 'File access followed by network transfer',\n                'conditions': {\n                    'time_window': 900,  # 15 minutes\n                    'sequence': ['file_access', 'network_transfer'],\n                    'data_threshold': 100  # MB\n                },\n                'severity': 'Critical'\n            }\n        ]\n    \n    def get_security_metrics(self) -> Dict[str, Any]:\n        \"\"\"Get comprehensive security metrics and KPIs\"\"\"\n        cache_key = 'security_metrics'\n        \n        # Check cache\n        if self._is_cache_valid(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        # Calculate metrics\n        current_time = datetime.now()\n        \n        # Mean Time to Detection (MTTD)\n        mttd = self._calculate_mttd()\n        mttd_trend = self._calculate_trend('mttd', mttd)\n        \n        # Mean Time to Response (MTTR)\n        mttr = self._calculate_mttr()\n        mttr_trend = self._calculate_trend('mttr', mttr)\n        \n        # Security Score\n        security_score = self._calculate_security_score()\n        score_trend = self._calculate_trend('security_score', security_score)\n        \n        # Threat Volume\n        threat_volume = self._calculate_threat_volume()\n        volume_trend = self._calculate_trend('threat_volume', threat_volume)\n        \n        # False Positive Rate\n        fp_rate = self._calculate_false_positive_rate()\n        fp_trend = self._calculate_trend('false_positive_rate', fp_rate)\n        \n        metrics = {\n            'mttd': mttd,\n            'mttd_trend': mttd_trend,\n            'mttr': mttr,\n            'mttr_trend': mttr_trend,\n            'security_score': security_score,\n            'score_trend': score_trend,\n            'threat_volume': threat_volume,\n            'volume_trend': volume_trend,\n            'false_positive_rate': fp_rate,\n            'fp_trend': fp_trend,\n            'last_updated': current_time\n        }\n        \n        # Cache results\n        self.metrics_cache[cache_key] = metrics\n        self.cache_expiry[cache_key] = current_time + timedelta(minutes=5)\n        \n        return metrics\n    \n    def get_threat_heatmap(self) -> Dict[str, Any]:\n        \"\"\"Generate threat activity heatmap data\"\"\"\n        cache_key = 'threat_heatmap'\n        \n        if self._is_cache_valid(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        # Generate 7 days x 24 hours heatmap\n        days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n        hours = [f'{i:02d}:00' for i in range(24)]\n        \n        # Simulate threat activity patterns\n        # Higher activity during business hours and weekdays\n        data = []\n        for day_idx, day in enumerate(days):\n            day_data = []\n            for hour_idx, hour in enumerate(hours):\n                # Base activity level\n                base_activity = 10\n                \n                # Business hours boost (9 AM - 5 PM)\n                if 9 <= hour_idx <= 17:\n                    base_activity += 20\n                \n                # Weekday boost\n                if day_idx < 5:  # Monday to Friday\n                    base_activity += 15\n                \n                # Add random variation\n                activity = max(0, base_activity + random.randint(-10, 25))\n                day_data.append(activity)\n            \n            data.append(day_data)\n        \n        heatmap_data = {\n            'data': data,\n            'days': days,\n            'hours': hours,\n            'max_value': max(max(row) for row in data),\n            'min_value': min(min(row) for row in data)\n        }\n        \n        # Cache results\n        self.metrics_cache[cache_key] = heatmap_data\n        self.cache_expiry[cache_key] = datetime.now() + timedelta(hours=1)\n        \n        return heatmap_data\n    \n    def get_attack_vector_analysis(self) -> Dict[str, int]:\n        \"\"\"Analyze and return attack vector distribution\"\"\"\n        cache_key = 'attack_vectors'\n        \n        if self._is_cache_valid(cache_key):\n            return self.metrics_cache[cache_key]\n        \n        # Simulate attack vector data based on current threat landscape\n        attack_vectors = {\n            'Email/Phishing': random.randint(150, 300),\n            'Web Applications': random.randint(100, 200),\n            'Network Services': random.randint(80, 150),\n            'Malware': random.randint(60, 120),\n            'Social Engineering': random.randint(40, 80),\n            'Physical Access': random.randint(10, 30),\n            'Supply Chain': random.randint(5, 20),\n            'Cloud Services': random.randint(70, 140),\n            'Mobile Devices': random.randint(30, 70),\n            'IoT Devices': random.randint(25, 60),\n            'Insider Threats': random.randint(5, 25),\n            'API Abuse': random.randint(40, 90)\n        }\n        \n        # Cache results\n        self.metrics_cache[cache_key] = attack_vectors\n        self.cache_expiry[cache_key] = datetime.now() + timedelta(hours=6)\n        \n        return attack_vectors\n    \n    def detect_anomalies(self, data_stream: List[Dict[str, Any]], metric_type: str) -> List[Dict[str, Any]]:\n        \"\"\"Detect anomalies in data streams using statistical methods\"\"\"\n        anomalies = []\n        \n        if not data_stream or metric_type not in self.anomaly_thresholds:\n            return anomalies\n        \n        thresholds = self.anomaly_thresholds[metric_type]\n        \n        for metric_name, threshold_config in thresholds.items():\n            # Extract metric values from data stream\n            values = []\n            for data_point in data_stream:\n                if metric_name in data_point:\n                    values.append(data_point[metric_name])\n            \n            if len(values) < 3:  # Need minimum data points\n                continue\n            \n            # Calculate statistical measures\n            mean_val = statistics.mean(values)\n            std_dev = statistics.stdev(values) if len(values) > 1 else 0\n            \n            # Check for anomalies\n            for i, value in enumerate(values):\n                is_anomaly = False\n                anomaly_type = None\n                \n                # Check against absolute thresholds\n                if value < threshold_config['min'] or value > threshold_config['max']:\n                    is_anomaly = True\n                    anomaly_type = 'threshold_violation'\n                \n                # Check against statistical thresholds\n                elif std_dev > 0:\n                    z_score = abs(value - mean_val) / std_dev\n                    if z_score > threshold_config['std_dev_multiplier']:\n                        is_anomaly = True\n                        anomaly_type = 'statistical_outlier'\n                \n                if is_anomaly:\n                    anomaly = {\n                        'timestamp': data_stream[i].get('timestamp', datetime.now()),\n                        'metric_type': metric_type,\n                        'metric_name': metric_name,\n                        'value': value,\n                        'expected_range': {\n                            'min': mean_val - (std_dev * threshold_config['std_dev_multiplier']),\n                            'max': mean_val + (std_dev * threshold_config['std_dev_multiplier'])\n                        },\n                        'anomaly_type': anomaly_type,\n                        'severity': self._calculate_anomaly_severity(value, mean_val, std_dev),\n                        'confidence': self._calculate_anomaly_confidence(z_score if std_dev > 0 else 0)\n                    }\n                    anomalies.append(anomaly)\n        \n        return anomalies\n    \n    def correlate_events(self, events: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n        \"\"\"Correlate security events across different systems\"\"\"\n        correlations = []\n        \n        if len(events) < 2:\n            return correlations\n        \n        # Sort events by timestamp\n        sorted_events = sorted(events, key=lambda x: x.get('timestamp', datetime.now()))\n        \n        for rule in self.correlation_rules:\n            correlation_result = self._apply_correlation_rule(sorted_events, rule)\n            if correlation_result:\n                correlations.append(correlation_result)\n        \n        return correlations\n    \n    def calculate_risk_score(self, asset_data: Dict[str, Any], threat_data: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Calculate comprehensive risk score for assets\"\"\"\n        # Asset criticality weight (0.0 - 1.0)\n        criticality_weights = {\n            'Critical': 1.0,\n            'High': 0.8,\n            'Medium': 0.6,\n            'Low': 0.4\n        }\n        \n        asset_criticality = asset_data.get('criticality', 'Medium')\n        criticality_weight = criticality_weights.get(asset_criticality, 0.6)\n        \n        # Threat likelihood (0.0 - 1.0)\n        threat_likelihood = threat_data.get('likelihood', 0.5)\n        \n        # Vulnerability score (0.0 - 10.0, normalize to 0.0 - 1.0)\n        vulnerability_score = asset_data.get('vulnerability_score', 5.0) / 10.0\n        \n        # Impact score based on asset type and data sensitivity\n        impact_multipliers = {\n            'financial_data': 1.0,\n            'personal_data': 0.9,\n            'intellectual_property': 0.85,\n            'operational_data': 0.7,\n            'public_data': 0.3\n        }\n        \n        data_sensitivity = asset_data.get('data_sensitivity', 'operational_data')\n        impact_multiplier = impact_multipliers.get(data_sensitivity, 0.7)\n        \n        # Calculate base risk score\n        base_risk = (threat_likelihood * vulnerability_score * criticality_weight * impact_multiplier) * 10\n        \n        # Adjust for mitigating factors\n        mitigation_factor = 1.0\n        \n        # Security controls\n        security_controls = asset_data.get('security_controls', [])\n        mitigation_factor -= len(security_controls) * 0.05  # 5% reduction per control\n        \n        # Monitoring coverage\n        if asset_data.get('monitoring_enabled', False):\n            mitigation_factor -= 0.1\n        \n        # Update frequency\n        days_since_update = asset_data.get('days_since_update', 30)\n        if days_since_update > 30:\n            mitigation_factor += 0.1  # Increase risk for outdated systems\n        \n        # Calculate final risk score\n        final_risk_score = max(0.0, min(10.0, base_risk * max(0.1, mitigation_factor)))\n        \n        # Determine risk level\n        if final_risk_score >= 8.0:\n            risk_level = 'Critical'\n        elif final_risk_score >= 6.0:\n            risk_level = 'High'\n        elif final_risk_score >= 4.0:\n            risk_level = 'Medium'\n        else:\n            risk_level = 'Low'\n        \n        return {\n            'risk_score': round(final_risk_score, 2),\n            'risk_level': risk_level,\n            'components': {\n                'threat_likelihood': threat_likelihood,\n                'vulnerability_score': vulnerability_score,\n                'asset_criticality': criticality_weight,\n                'impact_multiplier': impact_multiplier,\n                'mitigation_factor': mitigation_factor\n            },\n            'recommendations': self._generate_risk_recommendations(final_risk_score, asset_data)\n        }\n    \n    def generate_executive_summary(self, time_period: str = 'last_7_days') -> Dict[str, Any]:\n        \"\"\"Generate executive summary of security posture\"\"\"\n        current_time = datetime.now()\n        \n        # Define time range\n        if time_period == 'last_24_hours':\n            start_time = current_time - timedelta(days=1)\n        elif time_period == 'last_7_days':\n            start_time = current_time - timedelta(days=7)\n        elif time_period == 'last_30_days':\n            start_time = current_time - timedelta(days=30)\n        else:\n            start_time = current_time - timedelta(days=7)\n        \n        # Simulate executive metrics\n        summary = {\n            'time_period': time_period,\n            'generated_at': current_time,\n            'overall_security_posture': self._calculate_security_posture(),\n            'key_metrics': {\n                'incidents_resolved': random.randint(15, 45),\n                'mean_resolution_time': f'{random.randint(2, 8)} hours',\n                'false_positive_rate': f'{random.uniform(2.0, 8.0):.1f}%',\n                'system_uptime': f'{random.uniform(99.0, 99.9):.2f}%',\n                'compliance_score': f'{random.uniform(85.0, 98.0):.1f}%'\n            },\n            'threat_landscape': {\n                'total_threats_detected': random.randint(100, 500),\n                'critical_threats': random.randint(2, 8),\n                'threats_blocked': random.randint(95, 490),\n                'new_threat_types': random.randint(1, 5)\n            },\n            'top_threats': [\n                {'name': 'Phishing Campaigns', 'count': random.randint(50, 150), 'trend': 'increasing'},\n                {'name': 'Malware Attempts', 'count': random.randint(30, 100), 'trend': 'stable'},\n                {'name': 'Network Intrusions', 'count': random.randint(10, 50), 'trend': 'decreasing'},\n                {'name': 'Data Exfiltration', 'count': random.randint(5, 25), 'trend': 'stable'}\n            ],\n            'recommendations': [\n                'Increase user security awareness training frequency',\n                'Update endpoint protection policies',\n                'Review and strengthen network segmentation',\n                'Implement additional monitoring for cloud services'\n            ],\n            'investments_roi': {\n                'security_tools': f'{random.randint(150, 300)}% ROI',\n                'staff_training': f'{random.randint(200, 400)}% ROI',\n                'threat_intelligence': f'{random.randint(180, 350)}% ROI'\n            }\n        }\n        \n        return summary\n    \n    def _calculate_mttd(self) -> float:\n        \"\"\"Calculate Mean Time to Detection\"\"\"\n        # Simulate MTTD calculation\n        detection_times = [random.uniform(5.0, 45.0) for _ in range(20)]\n        return round(statistics.mean(detection_times), 1)\n    \n    def _calculate_mttr(self) -> float:\n        \"\"\"Calculate Mean Time to Response\"\"\"\n        # Simulate MTTR calculation\n        response_times = [random.uniform(15.0, 120.0) for _ in range(20)]\n        return round(statistics.mean(response_times), 1)\n    \n    def _calculate_security_score(self) -> float:\n        \"\"\"Calculate overall security score\"\"\"\n        # Simulate security score based on multiple factors\n        base_score = 8.5\n        \n        # Random variations\n        score_adjustment = random.uniform(-1.0, 1.0)\n        \n        return round(max(0.0, min(10.0, base_score + score_adjustment)), 1)\n    \n    def _calculate_threat_volume(self) -> int:\n        \"\"\"Calculate current threat volume\"\"\"\n        # Simulate threat volume\n        base_volume = 75\n        daily_variation = random.randint(-20, 30)\n        \n        return max(0, base_volume + daily_variation)\n    \n    def _calculate_false_positive_rate(self) -> float:\n        \"\"\"Calculate false positive rate\"\"\"\n        # Simulate FP rate\n        return round(random.uniform(0.02, 0.08), 3)\n    \n    def _calculate_trend(self, metric_name: str, current_value: float) -> float:\n        \"\"\"Calculate trend for a metric\"\"\"\n        # Store current value in historical data\n        self.historical_data[metric_name].append({\n            'timestamp': datetime.now(),\n            'value': current_value\n        })\n        \n        # Keep only last 30 data points\n        self.historical_data[metric_name] = self.historical_data[metric_name][-30:]\n        \n        # Calculate trend\n        if len(self.historical_data[metric_name]) < 2:\n            return 0.0\n        \n        recent_values = [point['value'] for point in self.historical_data[metric_name][-5:]]\n        older_values = [point['value'] for point in self.historical_data[metric_name][-10:-5]]\n        \n        if not older_values:\n            return 0.0\n        \n        recent_avg = statistics.mean(recent_values)\n        older_avg = statistics.mean(older_values)\n        \n        trend = recent_avg - older_avg\n        return round(trend, 2)\n    \n    def _calculate_anomaly_severity(self, value: float, mean_val: float, std_dev: float) -> str:\n        \"\"\"Calculate severity of detected anomaly\"\"\"\n        if std_dev == 0:\n            return 'Medium'\n        \n        z_score = abs(value - mean_val) / std_dev\n        \n        if z_score > 4.0:\n            return 'Critical'\n        elif z_score > 3.0:\n            return 'High'\n        elif z_score > 2.0:\n            return 'Medium'\n        else:\n            return 'Low'\n    \n    def _calculate_anomaly_confidence(self, z_score: float) -> float:\n        \"\"\"Calculate confidence level for anomaly detection\"\"\"\n        # Higher z-score = higher confidence\n        confidence = min(0.95, 0.5 + (z_score * 0.1))\n        return round(confidence, 3)\n    \n    def _apply_correlation_rule(self, events: List[Dict[str, Any]], rule: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Apply correlation rule to event list\"\"\"\n        rule_name = rule['name']\n        conditions = rule['conditions']\n        \n        if rule_name == 'Coordinated Attack Pattern':\n            return self._check_coordinated_attack(events, conditions)\n        elif rule_name == 'Lateral Movement Detection':\n            return self._check_lateral_movement(events, conditions)\n        elif rule_name == 'Data Exfiltration Chain':\n            return self._check_exfiltration_chain(events, conditions)\n        \n        return None\n    \n    def _check_coordinated_attack(self, events: List[Dict[str, Any]], conditions: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Check for coordinated attack patterns\"\"\"\n        time_window = conditions['time_window']\n        min_systems = conditions['min_systems']\n        \n        # Group events by time windows\n        current_time = datetime.now()\n        window_start = current_time - timedelta(seconds=time_window)\n        \n        recent_events = [e for e in events if e.get('timestamp', datetime.now()) > window_start]\n        \n        if len(recent_events) < min_systems:\n            return None\n        \n        # Check for similar attack patterns\n        attack_types = [e.get('attack_type', 'unknown') for e in recent_events]\n        most_common = Counter(attack_types).most_common(1)\n        \n        if most_common and most_common[0][1] >= min_systems:\n            return {\n                'rule_name': 'Coordinated Attack Pattern',\n                'confidence': 0.85,\n                'affected_systems': len(set(e.get('system', 'unknown') for e in recent_events)),\n                'attack_type': most_common[0][0],\n                'event_count': len(recent_events),\n                'time_span': f'{time_window} seconds'\n            }\n        \n        return None\n    \n    def _check_lateral_movement(self, events: List[Dict[str, Any]], conditions: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Check for lateral movement patterns\"\"\"\n        time_window = conditions['time_window']\n        min_hops = conditions['min_hops']\n        \n        # Look for sequential system compromises\n        compromise_events = [e for e in events if e.get('event_type') == 'system_compromise']\n        \n        if len(compromise_events) < min_hops:\n            return None\n        \n        # Check temporal sequence\n        systems_compromised = []\n        for event in compromise_events:\n            system = event.get('system')\n            if system and system not in systems_compromised:\n                systems_compromised.append(system)\n        \n        if len(systems_compromised) >= min_hops:\n            return {\n                'rule_name': 'Lateral Movement Detection',\n                'confidence': 0.78,\n                'systems_compromised': systems_compromised,\n                'hop_count': len(systems_compromised),\n                'time_span': f'{time_window} seconds'\n            }\n        \n        return None\n    \n    def _check_exfiltration_chain(self, events: List[Dict[str, Any]], conditions: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n        \"\"\"Check for data exfiltration chains\"\"\"\n        time_window = conditions['time_window']\n        sequence = conditions['sequence']\n        \n        # Look for file access followed by network transfer\n        file_events = [e for e in events if e.get('event_type') == 'file_access']\n        network_events = [e for e in events if e.get('event_type') == 'network_transfer']\n        \n        for file_event in file_events:\n            file_time = file_event.get('timestamp', datetime.now())\n            \n            # Look for network events within time window\n            for network_event in network_events:\n                network_time = network_event.get('timestamp', datetime.now())\n                \n                if abs((network_time - file_time).total_seconds()) <= time_window:\n                    data_size = network_event.get('data_size_mb', 0)\n                    \n                    if data_size >= conditions['data_threshold']:\n                        return {\n                            'rule_name': 'Data Exfiltration Chain',\n                            'confidence': 0.92,\n                            'file_accessed': file_event.get('file_path', 'unknown'),\n                            'data_transferred_mb': data_size,\n                            'destination': network_event.get('destination', 'unknown'),\n                            'time_span': f'{abs((network_time - file_time).total_seconds())} seconds'\n                        }\n        \n        return None\n    \n    def _calculate_security_posture(self) -> Dict[str, Any]:\n        \"\"\"Calculate overall security posture\"\"\"\n        # Simulate security posture calculation\n        posture_score = random.uniform(7.5, 9.2)\n        \n        if posture_score >= 9.0:\n            posture_level = 'Excellent'\n            posture_color = 'green'\n        elif posture_score >= 8.0:\n            posture_level = 'Good'\n            posture_color = 'lightgreen'\n        elif posture_score >= 7.0:\n            posture_level = 'Fair'\n            posture_color = 'yellow'\n        else:\n            posture_level = 'Poor'\n            posture_color = 'red'\n        \n        return {\n            'score': round(posture_score, 1),\n            'level': posture_level,\n            'color': posture_color,\n            'trend': random.choice(['improving', 'stable', 'declining'])\n        }\n    \n    def _generate_risk_recommendations(self, risk_score: float, asset_data: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate risk mitigation recommendations\"\"\"\n        recommendations = []\n        \n        if risk_score >= 8.0:\n            recommendations.extend([\n                'Immediate isolation and incident response required',\n                'Deploy additional monitoring and protection',\n                'Conduct thorough security assessment'\n            ])\n        elif risk_score >= 6.0:\n            recommendations.extend([\n                'Increase monitoring frequency',\n                'Apply security patches immediately',\n                'Review and update security controls'\n            ])\n        elif risk_score >= 4.0:\n            recommendations.extend([\n                'Schedule security update within 48 hours',\n                'Review access controls and permissions',\n                'Consider additional security controls'\n            ])\n        else:\n            recommendations.append('Continue regular monitoring and maintenance')\n        \n        # Asset-specific recommendations\n        if not asset_data.get('monitoring_enabled', False):\n            recommendations.append('Enable continuous monitoring')\n        \n        if asset_data.get('days_since_update', 0) > 30:\n            recommendations.append('Update system and apply security patches')\n        \n        if len(asset_data.get('security_controls', [])) < 3:\n            recommendations.append('Implement additional security controls')\n        \n        return recommendations\n    \n    def _is_cache_valid(self, cache_key: str) -> bool:\n        \"\"\"Check if cached data is still valid\"\"\"\n        if cache_key not in self.cache_expiry:\n            return False\n        \n        return datetime.now() < self.cache_expiry[cache_key]\n","size_bytes":27334},"utils/threat_intelligence.py":{"content":"import os\nimport requests\nimport json\nimport hashlib\nimport time\nfrom datetime import datetime, timedelta\nfrom typing import Dict, Any, List, Optional, Tuple\nimport random\nfrom collections import defaultdict\nimport uuid\n\nclass ThreatIntelligence:\n    \"\"\"Threat intelligence integration and management system\"\"\"\n    \n    def __init__(self):\n        self.api_keys = self._load_api_keys()\n        self.threat_feeds = {}\n        self.ioc_database = defaultdict(list)\n        self.threat_actors = {}\n        self.campaign_tracking = {}\n        self.reputation_cache = {}\n        self.cache_expiry = {}\n        self.feed_sources = self._initialize_feed_sources()\n        self.threat_categories = self._initialize_threat_categories()\n        self._initialize_sample_data()\n        \n    def _load_api_keys(self) -> Dict[str, str]:\n        \"\"\"Load API keys from environment variables\"\"\"\n        return {\n            'virustotal': os.getenv('VIRUSTOTAL_API_KEY', 'demo_vt_key'),\n            'shodan': os.getenv('SHODAN_API_KEY', 'demo_shodan_key'),\n            'xforce': os.getenv('XFORCE_API_KEY', 'demo_xforce_key'),\n            'otx': os.getenv('OTX_API_KEY', 'demo_otx_key'),\n            'threatcrowd': os.getenv('THREATCROWD_API_KEY', 'demo_tc_key'),\n            'hybrid_analysis': os.getenv('HYBRID_ANALYSIS_API_KEY', 'demo_ha_key'),\n            'urlvoid': os.getenv('URLVOID_API_KEY', 'demo_urlvoid_key'),\n            'abuseipdb': os.getenv('ABUSEIPDB_API_KEY', 'demo_abuseipdb_key')\n        }\n    \n    def _initialize_feed_sources(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Initialize threat intelligence feed sources\"\"\"\n        return {\n            'VirusTotal': {\n                'type': 'commercial',\n                'categories': ['malware', 'urls', 'domains', 'ips'],\n                'api_endpoint': 'https://www.virustotal.com/vtapi/v2/',\n                'rate_limit': 4,  # requests per minute\n                'enabled': True,\n                'last_updated': None,\n                'confidence': 0.95\n            },\n            'Shodan': {\n                'type': 'commercial',\n                'categories': ['network', 'vulnerabilities', 'infrastructure'],\n                'api_endpoint': 'https://api.shodan.io/',\n                'rate_limit': 1,\n                'enabled': False,\n                'last_updated': None,\n                'confidence': 0.85\n            },\n            'IBM X-Force': {\n                'type': 'commercial',\n                'categories': ['threats', 'vulnerabilities', 'malware'],\n                'api_endpoint': 'https://api.xforce.ibmcloud.com/',\n                'rate_limit': 5000,  # per month\n                'enabled': False,\n                'last_updated': None,\n                'confidence': 0.90\n            },\n            'OTX AlienVault': {\n                'type': 'community',\n                'categories': ['iocs', 'pulses', 'malware'],\n                'api_endpoint': 'https://otx.alienvault.com/api/v1/',\n                'rate_limit': 10000,  # per hour\n                'enabled': True,\n                'last_updated': None,\n                'confidence': 0.80\n            },\n            'Malware Bazaar': {\n                'type': 'free',\n                'categories': ['malware_samples', 'signatures'],\n                'api_endpoint': 'https://mb-api.abuse.ch/api/v1/',\n                'rate_limit': 1000,  # per day\n                'enabled': True,\n                'last_updated': None,\n                'confidence': 0.88\n            },\n            'ThreatCrowd': {\n                'type': 'free',\n                'categories': ['domains', 'ips', 'emails'],\n                'api_endpoint': 'https://www.threatcrowd.org/searchApi/v2/',\n                'rate_limit': 1,  # per second\n                'enabled': True,\n                'last_updated': None,\n                'confidence': 0.75\n            },\n            'URLVoid': {\n                'type': 'freemium',\n                'categories': ['urls', 'domains'],\n                'api_endpoint': 'https://api.urlvoid.com/1000/',\n                'rate_limit': 200,  # per day (free)\n                'enabled': True,\n                'last_updated': None,\n                'confidence': 0.82\n            },\n            'AbuseIPDB': {\n                'type': 'freemium',\n                'categories': ['ips', 'abuse'],\n                'api_endpoint': 'https://api.abuseipdb.com/api/v2/',\n                'rate_limit': 1000,  # per day (free)\n                'enabled': True,\n                'last_updated': None,\n                'confidence': 0.87\n            }\n        }\n    \n    def _initialize_threat_categories(self) -> Dict[str, Dict[str, Any]]:\n        \"\"\"Initialize threat categories and classifications\"\"\"\n        return {\n            'malware': {\n                'types': ['trojan', 'ransomware', 'spyware', 'adware', 'rootkit', 'worm', 'virus'],\n                'severity_mapping': {'trojan': 'high', 'ransomware': 'critical', 'spyware': 'high'},\n                'indicators': ['file_hash', 'registry_key', 'mutex', 'network_callback']\n            },\n            'network': {\n                'types': ['c2_server', 'malicious_domain', 'phishing_url', 'exploit_kit'],\n                'severity_mapping': {'c2_server': 'critical', 'phishing_url': 'high'},\n                'indicators': ['ip_address', 'domain', 'url', 'ssl_certificate']\n            },\n            'vulnerabilities': {\n                'types': ['cve', 'zero_day', 'configuration_issue', 'weak_credential'],\n                'severity_mapping': {'zero_day': 'critical', 'cve': 'variable'},\n                'indicators': ['cve_id', 'affected_software', 'exploit_code']\n            },\n            'actors': {\n                'types': ['apt_group', 'cybercriminal', 'hacktivist', 'insider_threat'],\n                'severity_mapping': {'apt_group': 'critical', 'cybercriminal': 'high'},\n                'indicators': ['ttps', 'infrastructure', 'tools', 'targets']\n            }\n        }\n    \n    def _initialize_sample_data(self):\n        \"\"\"Initialize with sample threat intelligence data\"\"\"\n        # Sample IOCs\n        sample_iocs = [\n            {\n                'type': 'ip',\n                'value': '198.51.100.42',\n                'threat_type': 'c2_server',\n                'confidence': 0.95,\n                'first_seen': datetime.now() - timedelta(days=5),\n                'last_seen': datetime.now() - timedelta(hours=2),\n                'source': 'VirusTotal',\n                'tags': ['apt', 'malware', 'backdoor'],\n                'description': 'Command and control server for advanced persistent threat'\n            },\n            {\n                'type': 'domain',\n                'value': 'malicious-example.com',\n                'threat_type': 'phishing',\n                'confidence': 0.88,\n                'first_seen': datetime.now() - timedelta(days=3),\n                'last_seen': datetime.now() - timedelta(hours=6),\n                'source': 'OTX AlienVault',\n                'tags': ['phishing', 'credential_theft'],\n                'description': 'Domain hosting phishing pages targeting banking credentials'\n            },\n            {\n                'type': 'hash',\n                'value': 'a1b2c3d4e5f6789012345678901234567890abcdef',\n                'threat_type': 'ransomware',\n                'confidence': 0.97,\n                'first_seen': datetime.now() - timedelta(days=1),\n                'last_seen': datetime.now() - timedelta(minutes=30),\n                'source': 'Malware Bazaar',\n                'tags': ['ransomware', 'encryption', 'wannacry'],\n                'description': 'WannaCry ransomware variant with improved evasion techniques'\n            }\n        ]\n        \n        for ioc in sample_iocs:\n            self.ioc_database[ioc['type']].append(ioc)\n        \n        # Sample threat actors\n        self.threat_actors = {\n            'APT28': {\n                'aliases': ['Fancy Bear', 'Sofacy', 'Pawn Storm'],\n                'origin': 'Russia',\n                'active_since': '2007',\n                'targets': ['government', 'military', 'aerospace'],\n                'ttps': ['spear_phishing', 'zero_day_exploits', 'credential_theft'],\n                'tools': ['X-Agent', 'Sofacy', 'Chopstick'],\n                'recent_activity': datetime.now() - timedelta(days=7),\n                'threat_level': 'critical'\n            },\n            'Lazarus Group': {\n                'aliases': ['Hidden Cobra', 'Guardians of Peace'],\n                'origin': 'North Korea',\n                'active_since': '2009',\n                'targets': ['financial', 'cryptocurrency', 'entertainment'],\n                'ttps': ['destructive_attacks', 'financial_theft', 'espionage'],\n                'tools': ['WannaCry', 'PowerRatankba', 'Brambul'],\n                'recent_activity': datetime.now() - timedelta(days=12),\n                'threat_level': 'critical'\n            }\n        }\n    \n    def get_global_threats(self) -> List[Dict[str, Any]]:\n        \"\"\"Get current global threat landscape\"\"\"\n        current_threats = [\n            {\n                'name': 'Advanced Ransomware Campaign',\n                'severity': 'Critical',\n                'first_seen': datetime.now() - timedelta(days=2),\n                'affected_systems': ['Windows', 'Linux'],\n                'description': 'New ransomware variant targeting enterprise networks with double extortion tactics',\n                'attribution': 'Unknown',\n                'iocs': ['multiple file hashes', 'C2 domains', 'registry modifications'],\n                'mitigation': 'Update endpoint protection, backup verification, network segmentation'\n            },\n            {\n                'name': 'Supply Chain Compromise',\n                'severity': 'High',\n                'first_seen': datetime.now() - timedelta(days=5),\n                'affected_systems': ['Software Distribution', 'Package Managers'],\n                'description': 'Malicious packages discovered in popular software repositories',\n                'attribution': 'APT Group',\n                'iocs': ['package signatures', 'domain registrations'],\n                'mitigation': 'Verify package integrity, restrict software installation sources'\n            },\n            {\n                'name': 'Cloud Infrastructure Attacks',\n                'severity': 'High',\n                'first_seen': datetime.now() - timedelta(days=3),\n                'affected_systems': ['AWS', 'Azure', 'GCP'],\n                'description': 'Targeted attacks against misconfigured cloud services and storage buckets',\n                'attribution': 'Multiple Groups',\n                'iocs': ['IP ranges', 'user agents', 'access patterns'],\n                'mitigation': 'Review cloud configurations, enable logging, implement IAM best practices'\n            },\n            {\n                'name': 'Mobile Banking Trojans',\n                'severity': 'Medium',\n                'first_seen': datetime.now() - timedelta(days=7),\n                'affected_systems': ['Android', 'iOS'],\n                'description': 'Banking trojans targeting mobile applications with overlay attacks',\n                'attribution': 'Cybercriminal Groups',\n                'iocs': ['app signatures', 'C2 communications'],\n                'mitigation': 'Mobile device management, app store verification, user education'\n            },\n            {\n                'name': 'IoT Botnet Expansion',\n                'severity': 'Medium',\n                'first_seen': datetime.now() - timedelta(days=10),\n                'affected_systems': ['IoT Devices', 'Smart Home'],\n                'description': 'Botnet targeting IoT devices with default credentials for DDoS attacks',\n                'attribution': 'Mirai Successor',\n                'iocs': ['default credentials', 'scanning patterns', 'C2 infrastructure'],\n                'mitigation': 'Change default passwords, network segmentation, firmware updates'\n            }\n        ]\n        \n        return current_threats\n    \n    def get_latest_iocs(self) -> List[Dict[str, Any]]:\n        \"\"\"Get latest indicators of compromise\"\"\"\n        all_iocs = []\n        \n        # Collect IOCs from all categories\n        for ioc_type, iocs in self.ioc_database.items():\n            for ioc in iocs:\n                ioc_entry = {\n                    'type': ioc_type,\n                    'value': ioc['value'],\n                    'threat_type': ioc['threat_type'],\n                    'confidence': ioc['confidence'],\n                    'source': ioc['source'],\n                    'first_seen': ioc['first_seen'].strftime('%Y-%m-%d %H:%M'),\n                    'tags': ', '.join(ioc['tags']),\n                    'description': ioc['description']\n                }\n                all_iocs.append(ioc_entry)\n        \n        # Sort by first_seen date (most recent first)\n        all_iocs.sort(key=lambda x: x['first_seen'], reverse=True)\n        \n        return all_iocs[:50]  # Return top 50 most recent\n    \n    def lookup_indicator(self, indicator: str, indicator_type: str) -> Dict[str, Any]:\n        \"\"\"Look up indicator in threat intelligence sources\"\"\"\n        lookup_result = {\n            'indicator': indicator,\n            'type': indicator_type,\n            'found': False,\n            'sources': [],\n            'threat_score': 0,\n            'confidence': 0.0,\n            'first_seen': None,\n            'last_seen': None,\n            'threat_types': [],\n            'descriptions': [],\n            'related_indicators': []\n        }\n        \n        # Check local IOC database first\n        local_results = self._check_local_iocs(indicator, indicator_type)\n        if local_results:\n            lookup_result.update(local_results)\n            lookup_result['found'] = True\n        \n        # Query external sources (simulate API calls)\n        external_results = self._query_external_sources(indicator, indicator_type)\n        if external_results:\n            lookup_result = self._merge_lookup_results(lookup_result, external_results)\n        \n        return lookup_result\n    \n    def check_reputation(self, indicator: str, indicator_type: str) -> Dict[str, Any]:\n        \"\"\"Check reputation of indicator across multiple sources\"\"\"\n        cache_key = f\"{indicator_type}:{indicator}\"\n        \n        # Check cache first\n        if self._is_cache_valid(cache_key):\n            return self.reputation_cache[cache_key]\n        \n        reputation_result = {\n            'indicator': indicator,\n            'type': indicator_type,\n            'reputation_score': 0,  # 0-100, higher is more malicious\n            'verdict': 'unknown',\n            'source_results': {},\n            'risk_factors': [],\n            'recommendations': []\n        }\n        \n        # Simulate checking multiple reputation sources\n        sources = ['VirusTotal', 'IBM X-Force', 'ThreatCrowd', 'URLVoid', 'AbuseIPDB']\n        malicious_votes = 0\n        total_votes = 0\n        \n        for source in sources:\n            if not self.feed_sources.get(source, {}).get('enabled', False):\n                continue\n            \n            # Simulate API call results\n            result = self._simulate_reputation_check(indicator, indicator_type, source)\n            reputation_result['source_results'][source] = result\n            \n            if result['responded']:\n                total_votes += 1\n                if result['malicious']:\n                    malicious_votes += 1\n        \n        # Calculate overall reputation score\n        if total_votes > 0:\n            reputation_result['reputation_score'] = int((malicious_votes / total_votes) * 100)\n        \n        # Determine verdict\n        if reputation_result['reputation_score'] >= 70:\n            reputation_result['verdict'] = 'malicious'\n        elif reputation_result['reputation_score'] >= 30:\n            reputation_result['verdict'] = 'suspicious'\n        elif reputation_result['reputation_score'] > 0:\n            reputation_result['verdict'] = 'potentially_malicious'\n        else:\n            reputation_result['verdict'] = 'clean'\n        \n        # Generate risk factors and recommendations\n        reputation_result['risk_factors'] = self._generate_risk_factors(reputation_result)\n        reputation_result['recommendations'] = self._generate_recommendations(reputation_result)\n        \n        # Cache results\n        self.reputation_cache[cache_key] = reputation_result\n        self.cache_expiry[cache_key] = datetime.now() + timedelta(hours=6)\n        \n        return reputation_result\n    \n    def test_integration(self, source_name: str) -> bool:\n        \"\"\"Test integration with threat intelligence source\"\"\"\n        if source_name not in self.feed_sources:\n            return False\n        \n        source_config = self.feed_sources[source_name]\n        \n        # Simulate API connectivity test\n        try:\n            # In a real implementation, this would make an actual API call\n            time.sleep(0.5)  # Simulate network delay\n            \n            # Simulate success/failure based on configuration\n            if source_config.get('enabled', False):\n                success_rate = 0.9  # 90% success rate\n            else:\n                success_rate = 0.3  # 30% success rate for disabled sources\n            \n            return random.random() < success_rate\n            \n        except Exception as e:\n            print(f\"Integration test failed for {source_name}: {e}\")\n            return False\n    \n    def update_threat_feeds(self) -> Dict[str, Any]:\n        \"\"\"Update threat intelligence feeds from all sources\"\"\"\n        update_results = {\n            'started_at': datetime.now(),\n            'sources_updated': [],\n            'sources_failed': [],\n            'new_indicators': 0,\n            'updated_indicators': 0,\n            'errors': []\n        }\n        \n        for source_name, source_config in self.feed_sources.items():\n            if not source_config.get('enabled', False):\n                continue\n            \n            try:\n                # Simulate feed update\n                result = self._update_source_feed(source_name, source_config)\n                \n                if result['success']:\n                    update_results['sources_updated'].append(source_name)\n                    update_results['new_indicators'] += result.get('new_indicators', 0)\n                    update_results['updated_indicators'] += result.get('updated_indicators', 0)\n                    \n                    # Update last updated timestamp\n                    source_config['last_updated'] = datetime.now()\n                else:\n                    update_results['sources_failed'].append(source_name)\n                    update_results['errors'].append(f\"{source_name}: {result.get('error', 'Unknown error')}\")\n                \n            except Exception as e:\n                update_results['sources_failed'].append(source_name)\n                update_results['errors'].append(f\"{source_name}: {str(e)}\")\n        \n        update_results['completed_at'] = datetime.now()\n        update_results['duration'] = (update_results['completed_at'] - update_results['started_at']).total_seconds()\n        \n        return update_results\n    \n    def get_threat_actor_profile(self, actor_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get detailed threat actor profile\"\"\"\n        actor = self.threat_actors.get(actor_name)\n        \n        if not actor:\n            return None\n        \n        # Enhance with recent activity and campaigns\n        enhanced_profile = actor.copy()\n        enhanced_profile.update({\n            'campaigns': self._get_actor_campaigns(actor_name),\n            'infrastructure': self._get_actor_infrastructure(actor_name),\n            'victims': self._get_actor_victims(actor_name),\n            'evolution': self._get_actor_evolution(actor_name)\n        })\n        \n        return enhanced_profile\n    \n    def search_threat_intelligence(self, query: str, search_type: str = 'all') -> List[Dict[str, Any]]:\n        \"\"\"Search across threat intelligence database\"\"\"\n        results = []\n        \n        # Search IOCs\n        if search_type in ['all', 'iocs']:\n            for ioc_type, iocs in self.ioc_database.items():\n                for ioc in iocs:\n                    if (query.lower() in ioc['value'].lower() or \n                        query.lower() in ioc['description'].lower() or\n                        any(query.lower() in tag.lower() for tag in ioc['tags'])):\n                        \n                        results.append({\n                            'result_type': 'ioc',\n                            'ioc_type': ioc_type,\n                            'value': ioc['value'],\n                            'threat_type': ioc['threat_type'],\n                            'confidence': ioc['confidence'],\n                            'source': ioc['source'],\n                            'description': ioc['description']\n                        })\n        \n        # Search threat actors\n        if search_type in ['all', 'actors']:\n            for actor_name, actor_data in self.threat_actors.items():\n                if (query.lower() in actor_name.lower() or\n                    any(query.lower() in alias.lower() for alias in actor_data.get('aliases', [])) or\n                    any(query.lower() in target.lower() for target in actor_data.get('targets', []))):\n                    \n                    results.append({\n                        'result_type': 'threat_actor',\n                        'name': actor_name,\n                        'aliases': actor_data.get('aliases', []),\n                        'origin': actor_data.get('origin', 'Unknown'),\n                        'threat_level': actor_data.get('threat_level', 'medium'),\n                        'description': f\"Threat actor active since {actor_data.get('active_since', 'unknown')}\"\n                    })\n        \n        return results\n    \n    def _check_local_iocs(self, indicator: str, indicator_type: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Check indicator against local IOC database\"\"\"\n        if indicator_type not in self.ioc_database:\n            return None\n        \n        for ioc in self.ioc_database[indicator_type]:\n            if ioc['value'] == indicator:\n                return {\n                    'sources': [ioc['source']],\n                    'threat_score': int(ioc['confidence'] * 100),\n                    'confidence': ioc['confidence'],\n                    'first_seen': ioc['first_seen'],\n                    'last_seen': ioc['last_seen'],\n                    'threat_types': [ioc['threat_type']],\n                    'descriptions': [ioc['description']]\n                }\n        \n        return None\n    \n    def _query_external_sources(self, indicator: str, indicator_type: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Query external threat intelligence sources\"\"\"\n        # Simulate external API queries\n        # In a real implementation, this would make actual API calls\n        \n        external_result = {\n            'sources': [],\n            'threat_score': 0,\n            'confidence': 0.0,\n            'threat_types': [],\n            'descriptions': []\n        }\n        \n        # Simulate VirusTotal lookup\n        if self.feed_sources['VirusTotal']['enabled']:\n            vt_result = self._simulate_virustotal_lookup(indicator, indicator_type)\n            if vt_result:\n                external_result['sources'].append('VirusTotal')\n                external_result['threat_score'] = max(external_result['threat_score'], vt_result['score'])\n                external_result['confidence'] = max(external_result['confidence'], vt_result['confidence'])\n                external_result['threat_types'].extend(vt_result['types'])\n                external_result['descriptions'].extend(vt_result['descriptions'])\n        \n        # Simulate other source lookups\n        for source_name in ['OTX AlienVault', 'Malware Bazaar', 'ThreatCrowd']:\n            if self.feed_sources[source_name]['enabled'] and random.random() < 0.7:\n                external_result['sources'].append(source_name)\n        \n        return external_result if external_result['sources'] else None\n    \n    def _simulate_virustotal_lookup(self, indicator: str, indicator_type: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Simulate VirusTotal API lookup\"\"\"\n        # Simulate API response based on indicator characteristics\n        if indicator_type == 'hash':\n            # File hash lookup\n            detection_rate = random.uniform(0.0, 0.8)\n            if detection_rate > 0.1:\n                return {\n                    'score': int(detection_rate * 100),\n                    'confidence': 0.95,\n                    'types': ['malware'],\n                    'descriptions': [f'Malware detected by {int(detection_rate * 70)} engines']\n                }\n        elif indicator_type == 'ip':\n            # IP reputation lookup\n            if random.random() < 0.3:  # 30% chance of malicious IP\n                return {\n                    'score': random.randint(60, 95),\n                    'confidence': 0.85,\n                    'types': ['c2_server', 'malware_distribution'],\n                    'descriptions': ['IP associated with malware distribution']\n                }\n        elif indicator_type == 'domain':\n            # Domain reputation lookup\n            if random.random() < 0.25:  # 25% chance of malicious domain\n                return {\n                    'score': random.randint(50, 90),\n                    'confidence': 0.80,\n                    'types': ['phishing', 'malware_hosting'],\n                    'descriptions': ['Domain hosting malicious content']\n                }\n        \n        return None\n    \n    def _simulate_reputation_check(self, indicator: str, indicator_type: str, source: str) -> Dict[str, Any]:\n        \"\"\"Simulate reputation check for a single source\"\"\"\n        result = {\n            'source': source,\n            'responded': random.random() < 0.9,  # 90% response rate\n            'malicious': False,\n            'score': 0,\n            'details': {}\n        }\n        \n        if result['responded']:\n            # Simulate malicious detection based on source reliability\n            source_confidence = self.feed_sources[source]['confidence']\n            detection_probability = 0.1 * source_confidence  # Base 10% scaled by confidence\n            \n            result['malicious'] = random.random() < detection_probability\n            if result['malicious']:\n                result['score'] = random.randint(70, 100)\n                result['details'] = {\n                    'threat_types': random.sample(['malware', 'phishing', 'spam', 'botnet'], \n                                                random.randint(1, 2)),\n                    'last_seen': datetime.now() - timedelta(days=random.randint(0, 30))\n                }\n            else:\n                result['score'] = random.randint(0, 20)\n        \n        return result\n    \n    def _generate_risk_factors(self, reputation_result: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate risk factors based on reputation results\"\"\"\n        risk_factors = []\n        \n        if reputation_result['reputation_score'] >= 70:\n            risk_factors.append('High malicious consensus across multiple sources')\n        elif reputation_result['reputation_score'] >= 30:\n            risk_factors.append('Moderate suspicion from reputation sources')\n        \n        # Check source-specific factors\n        for source, result in reputation_result['source_results'].items():\n            if result.get('malicious', False):\n                risk_factors.append(f'Flagged as malicious by {source}')\n        \n        if not risk_factors:\n            risk_factors.append('No significant risk factors identified')\n        \n        return risk_factors\n    \n    def _generate_recommendations(self, reputation_result: Dict[str, Any]) -> List[str]:\n        \"\"\"Generate recommendations based on reputation results\"\"\"\n        recommendations = []\n        \n        if reputation_result['reputation_score'] >= 70:\n            recommendations.extend([\n                'Block indicator immediately',\n                'Investigate any related activity',\n                'Add to threat intelligence feeds'\n            ])\n        elif reputation_result['reputation_score'] >= 30:\n            recommendations.extend([\n                'Monitor indicator closely',\n                'Consider temporary blocking',\n                'Increase logging for related activity'\n            ])\n        else:\n            recommendations.append('Continue normal monitoring')\n        \n        return recommendations\n    \n    def _update_source_feed(self, source_name: str, source_config: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Update threat intelligence from a specific source\"\"\"\n        # Simulate feed update process\n        time.sleep(random.uniform(0.5, 2.0))  # Simulate API call time\n        \n        success = random.random() < 0.85  # 85% success rate\n        \n        if success:\n            new_indicators = random.randint(5, 50)\n            updated_indicators = random.randint(0, 20)\n            \n            # Simulate adding new IOCs to database\n            for _ in range(random.randint(1, 5)):\n                ioc_type = random.choice(['ip', 'domain', 'hash', 'url'])\n                ioc_value = self._generate_sample_ioc_value(ioc_type)\n                \n                new_ioc = {\n                    'type': ioc_type,\n                    'value': ioc_value,\n                    'threat_type': random.choice(['malware', 'phishing', 'c2_server', 'botnet']),\n                    'confidence': random.uniform(0.7, 0.95),\n                    'first_seen': datetime.now(),\n                    'last_seen': datetime.now(),\n                    'source': source_name,\n                    'tags': random.sample(['apt', 'malware', 'phishing', 'botnet', 'trojan'], \n                                        random.randint(1, 3)),\n                    'description': f'Threat indicator from {source_name} feed'\n                }\n                \n                self.ioc_database[ioc_type].append(new_ioc)\n            \n            return {\n                'success': True,\n                'new_indicators': new_indicators,\n                'updated_indicators': updated_indicators\n            }\n        else:\n            return {\n                'success': False,\n                'error': random.choice([\n                    'API rate limit exceeded',\n                    'Authentication failed',\n                    'Network timeout',\n                    'Service temporarily unavailable'\n                ])\n            }\n    \n    def _generate_sample_ioc_value(self, ioc_type: str) -> str:\n        \"\"\"Generate sample IOC value for testing\"\"\"\n        if ioc_type == 'ip':\n            return f\"{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}.{random.randint(1, 255)}\"\n        elif ioc_type == 'domain':\n            domains = ['malicious-site.com', 'phishing-bank.net', 'c2-server.org', 'botnet-controller.biz']\n            return random.choice(domains)\n        elif ioc_type == 'hash':\n            return hashlib.sha256(f\"sample_malware_{random.randint(1000, 9999)}\".encode()).hexdigest()\n        elif ioc_type == 'url':\n            return f\"http://malicious-site.com/path/{random.randint(100, 999)}\"\n        else:\n            return f\"sample_{ioc_type}_{random.randint(1000, 9999)}\"\n    \n    def _merge_lookup_results(self, local_result: Dict[str, Any], external_result: Dict[str, Any]) -> Dict[str, Any]:\n        \"\"\"Merge lookup results from local and external sources\"\"\"\n        merged = local_result.copy()\n        \n        merged['sources'].extend(external_result['sources'])\n        merged['threat_score'] = max(merged['threat_score'], external_result['threat_score'])\n        merged['confidence'] = max(merged['confidence'], external_result['confidence'])\n        merged['threat_types'].extend(external_result['threat_types'])\n        merged['descriptions'].extend(external_result['descriptions'])\n        \n        # Remove duplicates\n        merged['sources'] = list(set(merged['sources']))\n        merged['threat_types'] = list(set(merged['threat_types']))\n        merged['descriptions'] = list(set(merged['descriptions']))\n        \n        return merged\n    \n    def _get_actor_campaigns(self, actor_name: str) -> List[Dict[str, Any]]:\n        \"\"\"Get recent campaigns for threat actor\"\"\"\n        campaigns = [\n            {\n                'name': f'{actor_name} Campaign 2024-Q3',\n                'start_date': datetime.now() - timedelta(days=45),\n                'status': 'active',\n                'targets': ['financial_services', 'government'],\n                'techniques': ['spear_phishing', 'watering_hole']\n            }\n        ]\n        return campaigns\n    \n    def _get_actor_infrastructure(self, actor_name: str) -> Dict[str, List[str]]:\n        \"\"\"Get infrastructure associated with threat actor\"\"\"\n        return {\n            'domains': [f'{actor_name.lower().replace(\" \", \"-\")}-c2.com'],\n            'ip_addresses': ['203.0.113.42', '198.51.100.123'],\n            'ssl_certificates': ['CN=fake-cert.com']\n        }\n    \n    def _get_actor_victims(self, actor_name: str) -> List[str]:\n        \"\"\"Get known victims of threat actor\"\"\"\n        return ['Organization A', 'Government Agency B', 'Financial Institution C']\n    \n    def _get_actor_evolution(self, actor_name: str) -> Dict[str, Any]:\n        \"\"\"Get evolution information for threat actor\"\"\"\n        return {\n            'new_techniques': ['living_off_the_land', 'cloud_exploitation'],\n            'tool_updates': ['new_backdoor_variant', 'improved_persistence'],\n            'targeting_changes': ['expanded_geography', 'new_sectors']\n        }\n    \n    def _is_cache_valid(self, cache_key: str) -> bool:\n        \"\"\"Check if cached data is still valid\"\"\"\n        if cache_key not in self.cache_expiry:\n            return False\n        \n        return datetime.now() < self.cache_expiry[cache_key]\n","size_bytes":34101}},"version":1}